!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.16 (develop) - 29 Jul 2025 17:17
!
!1-10全来自src文件
!1.dataStructures.jl:数据结构   2.FvCFD.jl:主求解函数(subroutine solve)writeoutput_d
!3.boundaryConditions.jl:边界条件
!4.constitutiveRelations.jl:状态变量与通量推导公式   5.JST.jl:通量残差   
!6.mesh.jl:网格    7.numerics.jl:梯度,面值插值,面通量到单元格通量
!8.output.jl:输出文件    9.timeDiscretizations.jl:更新解    
!10.vectorFunctions.jl:向量计算函数
!11.NACA0012.jl:初始化 (来自Examples的文件)
!1.dataStructures.jl:数据结构 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
MODULE BUFLOWMODULE_DIFF
!    use iso_fortran_env
! 2. 再禁用默认类型
  USE TYPESMODULE
  IMPLICIT NONE
  INTRINSIC VERIFY, FINDLOC, SYSTEM, MATMUL, DOT_PRODUCT, MOVE_ALLOC, &
&     NEW_LINE, HUGE, INT
! 仅保留外部声明
  EXTERNAL DPOTRF, DPOTRI
! 面索引列表（动态数组）
!$AD NONDIFF
! 点索引列表（动态数组）
!$AD NONDIFF
!    include 'tapenade_includes.f90'  ! <<< 仅 Tapenade 用，原编译时注释   
  TYPE CELLL
      INTEGER(kind=8), ALLOCATABLE :: faceindices(:)
      INTEGER(kind=8), ALLOCATABLE :: pointindices(:)
  END TYPE CELLL
  TYPE SOLUTIONSTATE
      REAL(kind=8), ALLOCATABLE :: cellstate(:, :)
      REAL(kind=8), ALLOCATABLE :: cellfluxes(:, :)
      REAL(kind=8), ALLOCATABLE :: cellprimitives(:, :)
      REAL(kind=8), ALLOCATABLE :: fluxresiduals(:, :)
      REAL(kind=8), ALLOCATABLE :: facefluxes(:, :)
  END TYPE SOLUTIONSTATE
  TYPE MESHH
      INTEGER(kind=8), ALLOCATABLE :: cells(:, :)
      REAL(kind=8), ALLOCATABLE :: cvols(:)
      REAL(kind=8), ALLOCATABLE :: ccenters(:, :)
      REAL(kind=8), ALLOCATABLE :: cellsizes(:, :)
      INTEGER(kind=8), ALLOCATABLE :: faces(:, :)
      REAL(kind=8), ALLOCATABLE :: favecs(:, :)
      REAL(kind=8), ALLOCATABLE :: fcenters(:, :)
      INTEGER(kind=8), ALLOCATABLE :: boundaryfaces(:, :)
  END TYPE MESHH
  TYPE MESHH_DIFF
      REAL(kind=8), DIMENSION(:), ALLOCATABLE :: cvols
      REAL(kind=8), DIMENSION(:, :), ALLOCATABLE :: ccenters
      REAL(kind=8), DIMENSION(:, :), ALLOCATABLE :: favecs
      REAL(kind=8), DIMENSION(:, :), ALLOCATABLE :: fcenters
  END TYPE MESHH_DIFF
  TYPE FLUIDD
      REAL(kind=8) :: cp
      REAL(kind=8) :: r
      REAL(kind=8) :: gammaa
  END TYPE FLUIDD
! 当前仿真时间
! 当前已执行的时间步数
! 下一次写输出的时间点
! 总仿真时间
  TYPE SOLVERSTATUS
      REAL(kind=8) :: currenttime
      INTEGER(kind=8) :: ntimesteps
      REAL(kind=8) :: nextoutputtime
      REAL(kind=8) :: endtime
  END TYPE SOLVERSTATUS
  TYPE SOLVERSTATUS_DIFF
      REAL(kind=8) :: currenttime
  END TYPE SOLVERSTATUS_DIFF
! 面的节点索引
! 或者如果 FaceType 未定义，同时添加 FaceType 定义!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  TYPE FACETYPE
      INTEGER(kind=8), ALLOCATABLE :: points(:)
  END TYPE FACETYPE
  TYPE FACEARRAY
      TYPE(FACETYPE), ALLOCATABLE :: faces(:)
  END TYPE FACEARRAY
! 边界类型（用整数标识）
! 边界参数（如压力、速度等）
  TYPE BOUNDARYCONDITION
      INTEGER(kind=8) :: type
      REAL(kind=8), ALLOCATABLE :: params(:)
  END TYPE BOUNDARYCONDITION
! 定义边界类型常量
  INTEGER(kind=8), PARAMETER :: wallboundary=1
  INTEGER(kind=8), PARAMETER :: emptyboundary=2
  INTEGER(kind=8), PARAMETER :: inletboundary=3
  INTEGER(kind=8), PARAMETER :: outletboundary=4
!$AD NONDIFF
  TYPE CELLLARRAY
      TYPE(CELLL), ALLOCATABLE :: cells(:)
  END TYPE CELLLARRAY
! 第1列：是否截断（逻辑值）
! 第2列：实际时间步长（实数）
! 在模块开头的类型定义部分添加
  TYPE RESTRICTRESULT
      LOGICAL :: needtruncate
      REAL(kind=8) :: actualdt
  END TYPE RESTRICTRESULT
  TYPE RESTRICTRESULT_DIFF
      REAL(kind=8) :: actualdt
  END TYPE RESTRICTRESULT_DIFF
  TYPE MESHDATA
      REAL(kind=8), ALLOCATABLE :: points(:, :)
      TYPE(FACEARRAY) :: faces
      INTEGER(kind=8), ALLOCATABLE :: owner(:), neighbour(:)
      CHARACTER(len=100), ALLOCATABLE :: boundarynames(:)
      INTEGER(kind=8), ALLOCATABLE :: boundarynumfaces(:), &
&     boundarystartfaces(:)
  END TYPE MESHDATA
  TYPE MESHDATA_DIFF
      REAL(kind=8), DIMENSION(:, :), ALLOCATABLE :: points
  END TYPE MESHDATA_DIFF
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

CONTAINS
!  Differentiation of initializeuniformsolution3d in forward (tangent) mode (with options i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4
! i4 dr8 r4):
!   Plus diff mem management of: sol:out
!2.FvCFD.jl:主求解函数(subroutine solve)!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!   
!######################### 初始化 ###########################
!# 创建一个均匀初始解（所有单元的原始变量均相同）
  SUBROUTINE INITIALIZEUNIFORMSOLUTION3D_D(mesh, p, t, ux, uy, uz, sol, &
&   sold)
    IMPLICIT NONE
    TYPE(MESHH), INTENT(IN) :: mesh
    REAL(kind=8), INTENT(IN) :: p, t, ux, uy, uz
    REAL(kind=8), ALLOCATABLE, INTENT(OUT) :: sol(:, :)
    REAL(kind=8), ALLOCATABLE, INTENT(OUT) :: sold(:, :)
    INTEGER(kind=8) :: ncells, meshinfo(4)
    INTEGER(kind=8) :: nvars, c, ndims
    REAL(kind=8), ALLOCATABLE :: initialvalues(:)
    ndims = 3
    CALL UNSTRUCTUREDMESHINFO(mesh, meshinfo)
    ncells = meshinfo(1)
! P, T, 和每个方向的速度
    nvars = 2 + ndims
    ALLOCATE(sold(ncells, nvars), source=0.0d0)
    ALLOCATE(sol(ncells, nvars), source=0.0d0)
    ALLOCATE(initialvalues(nvars), source=0.0d0)
! 修改1: 修正数组构造器语法
! 先构造完整数组
    initialvalues = (/p, t, ux, uy, uz/)
! 再进行切片
    initialvalues = initialvalues(1:nvars)
    DO c=1,ncells
      sol(c, :) = initialvalues
    END DO
  END SUBROUTINE INITIALIZEUNIFORMSOLUTION3D_D

!2.FvCFD.jl:主求解函数(subroutine solve)!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!   
!######################### 初始化 ###########################
!# 创建一个均匀初始解（所有单元的原始变量均相同）
  SUBROUTINE INITIALIZEUNIFORMSOLUTION3D(mesh, p, t, ux, uy, uz, sol)
    IMPLICIT NONE
    TYPE(MESHH), INTENT(IN) :: mesh
    REAL(kind=8), INTENT(IN) :: p, t, ux, uy, uz
    REAL(kind=8), ALLOCATABLE, INTENT(OUT) :: sol(:, :)
    INTEGER(kind=8) :: ncells, meshinfo(4)
    INTEGER(kind=8) :: nvars, c, ndims
    REAL(kind=8), ALLOCATABLE :: initialvalues(:)
    ndims = 3
    CALL UNSTRUCTUREDMESHINFO(mesh, meshinfo)
    ncells = meshinfo(1)
! P, T, 和每个方向的速度
    nvars = 2 + ndims
    ALLOCATE(sol(ncells, nvars), source=0.0d0)
    ALLOCATE(initialvalues(nvars), source=0.0d0)
! 修改1: 修正数组构造器语法
! 先构造完整数组
    initialvalues = (/p, t, ux, uy, uz/)
! 再进行切片
    initialvalues = initialvalues(1:nvars)
    DO c=1,ncells
      sol(c, :) = initialvalues
    END DO
  END SUBROUTINE INITIALIZEUNIFORMSOLUTION3D

!  Differentiation of cfl in forward (tangent) mode (with options i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4):
!   variations   of useful results: [alloc*facevel in cfl] [alloc*cellrhot in cfl]
!                [alloc*facerhot in cfl] cfll
!   with respect to varying inputs: [alloc*(sln.cellprimitives) in decodesolution_3d]
!                [alloc*(mesh.ccenters) in openfoammesh] [alloc*(mesh.cvols) in openfoammesh]
!                [alloc*(mesh.fcenters) in openfoammesh] [alloc*(mesh.favecs) in openfoammesh]
!                [alloc*(*sln.facefluxes) in solve] [alloc*(*sln.cellstate) in solve]
!                [alloc*(*sln.cellprimitives) in solve] *([alloc*sln in solve].cellstate)
!                *([alloc*sln in solve].cellprimitives) *([alloc*sln in solve].facefluxes)
!                [alloc*facevel in cfl] [alloc*cellrhot in cfl]
!                [alloc*facerhot in cfl]
!   Plus diff mem management of: mesh.cvols:in mesh.ccenters:in
!                mesh.favecs:in mesh.fcenters:in sln.cellstate:in
!                sln.cellprimitives:in sln.facefluxes:in
! ######################### CFL计算 ###########################
! 根据当前速度、温度估算各单元的CFL数
!julia程序里CFL!(CFL, mesh::Mesh, sln::SolutionState, fluid::Fluid, dt=1)的第一项fill!(CFL, 0.0)被强制为0
  SUBROUTINE CFL_D(ncells, mesh, meshd, sln, slnd, fluid, dt, cfll, &
&   cflld)
    IMPLICIT NONE
    INTEGER(kind=8), INTENT(IN) :: ncells
! 函数返回值（原输出参数）
    REAL(kind=8), INTENT(OUT) :: cfll(ncells)
    REAL(kind=8), INTENT(OUT) :: cflld(ncells)
    TYPE(MESHH), INTENT(IN) :: mesh
    TYPE(MESHH_DIFF), INTENT(IN) :: meshd
    TYPE(SOLUTIONSTATE), INTENT(IN) :: sln
    TYPE(SOLUTIONSTATE), INTENT(IN) :: slnd
    TYPE(FLUIDD), INTENT(IN) :: fluid
    REAL(kind=8), INTENT(IN) :: dt
    INTEGER(kind=8) :: nfaces, nboundaries, nbdryfaces, meshinfo(4)
    INTEGER(kind=8) :: f, ownercell, neighbourcell
    REAL(kind=8), ALLOCATABLE :: facerhot(:, :), cellrhot(:, :)
    REAL(kind=8), ALLOCATABLE :: facerhotd(:, :), cellrhotd(:, :)
    REAL(kind=8) :: facerho, facet, flux, a, dt_val, mag_val, dott
    REAL(kind=8) :: facerhod, facetd, fluxd, ad, mag_vald, dottd
    REAL(kind=8), ALLOCATABLE :: facevel(:), positionn(:)
    REAL(kind=8), ALLOCATABLE :: faceveld(:)
    INTRINSIC ABS
    INTRINSIC SQRT
    REAL(kind=8) :: abs0
    REAL(kind=8) :: abs0d
    REAL(kind=8) :: arg1
    REAL(kind=8) :: arg1d
    REAL(kind=8), DIMENSION(3) :: temp
    REAL(kind=8) :: temp0
    REAL(kind=8), DIMENSION(ncells) :: temp1
    CALL UNSTRUCTUREDMESHINFO(mesh, meshinfo)
    nfaces = meshinfo(2)
    nboundaries = meshinfo(3)
    nbdryfaces = meshinfo(4)
    cfll = 0.0d0
! 插值得到面上的密度和温度
    ALLOCATE(facerhotd(nfaces, 2), source=0.0d0)
    facerhotd = 0.0_8
    ALLOCATE(facerhot(nfaces, 2), source=0.0d0)
    ALLOCATE(cellrhotd(ncells, 2), source=0.0d0)
    cellrhotd = 0.0_8
    ALLOCATE(cellrhot(ncells, 2), source=0.0d0)
! ② 手动拼接两列数据（第1列：密度；第2列：温度）
! 第1列：单元格密度（来自 cellState 第1列）
    cellrhotd(:, 1) = slnd%cellstate(:, 1)
    cellrhot(:, 1) = sln%cellstate(:, 1)
! 第2列：单元格温度（来自 cellPrimitives 第2
    cellrhotd(:, 2) = slnd%cellprimitives(:, 2)
    cellrhot(:, 2) = sln%cellprimitives(:, 2)
! ③ 调用 linInterp_3D 插值到面
    CALL LININTERP_3D_D(mesh, meshd, cellrhot, cellrhotd, facerhot, &
&                 facerhotd)
    ALLOCATE(faceveld(3), source=0.0d0)
    faceveld = 0.0_8
    ALLOCATE(facevel(3), source=0.0d0)
    ALLOCATE(positionn(3), source=0.0d0)
    cflld = 0.0_8
    DO f=1,nfaces
      ownercell = mesh%faces(f, 1)
      neighbourcell = mesh%faces(f, 2)
      facerhod = facerhotd(f, 1)
      facerho = facerhot(f, 1)
      facetd = facerhotd(f, 2)
      facet = facerhot(f, 2)
      IF (neighbourcell .EQ. -1) THEN
! 边界面，用cell值替代
        facerhod = slnd%cellstate(ownercell, 1)
        facerho = sln%cellstate(ownercell, 1)
        facetd = slnd%cellprimitives(ownercell, 2)
        facet = sln%cellprimitives(ownercell, 2)
      END IF
      temp = sln%facefluxes(f, 1:3)/facerho
      faceveld = (slnd%facefluxes(f, 1:3)-temp*facerhod)/facerho
      facevel = temp
      CALL DOT_PRODUCT_REAL_D(facevel, faceveld, mesh%favecs(f, :), &
&                       meshd%favecs(f, :), dott, dottd, 3)
      IF (dott .GE. 0.) THEN
        abs0d = dottd
        abs0 = dott
      ELSE
        abs0d = -dottd
        abs0 = -dott
      END IF
      fluxd = dt*abs0d
      flux = abs0*dt
      IF (facet .LE. 0.0d0) THEN
        positionn = mesh%fcenters(f, :)
!			    print*, "Warning: Negative temperature at face ", f, ": ", positionn
      END IF
! 计算声速
      arg1d = fluid%gammaa*fluid%r*facetd
      arg1 = fluid%gammaa*fluid%r*facet
      temp0 = SQRT(arg1)
      IF (arg1 .EQ. 0.0) THEN
        ad = arg1d/(2.0*temp0)!0.0_8
      ELSE
        ad = arg1d/(2.0*temp0)
      END IF
      a = temp0
      CALL MAG_D(mesh%favecs(f, :), meshd%favecs(f, :), mag_val, &
&          mag_vald)
      fluxd = fluxd + dt*(a*mag_vald+mag_val*ad)
      flux = flux + mag_val*a*dt
! 将该face的流量贡献给相邻两个cell
      cflld(ownercell) = cflld(ownercell) + fluxd
      cfll(ownercell) = cfll(ownercell) + flux
      IF (neighbourcell .GT. -1) THEN
        cflld(neighbourcell) = cflld(neighbourcell) + fluxd
        cfll(neighbourcell) = cfll(neighbourcell) + flux
      END IF
    END DO
    IF (ALLOCATED(faceveld)) THEN
      DEALLOCATE(faceveld)
    END IF
    DEALLOCATE(facevel)
    DEALLOCATE(positionn)
! 虽然没有return,但在 Julia 中，函数的返回值默认是最后一个表达式的值
! 除以两倍体积，符合CFL定义
    temp1 = cfll/(2.0d0*mesh%cvols)
    cflld = cflld/(2.0d0*mesh%cvols)-cfll*meshd%cvols/(2.0d0*mesh%cvols*mesh%cvols)
    cfll = temp1
    IF (ALLOCATED(facerhotd)) THEN
      DEALLOCATE(facerhotd)
    END IF
    DEALLOCATE(facerhot)
    IF (ALLOCATED(cellrhotd)) THEN
      DEALLOCATE(cellrhotd)
    END IF
    DEALLOCATE(cellrhot)
  END SUBROUTINE CFL_D

! ######################### CFL计算 ###########################
! 根据当前速度、温度估算各单元的CFL数
!julia程序里CFL!(CFL, mesh::Mesh, sln::SolutionState, fluid::Fluid, dt=1)的第一项fill!(CFL, 0.0)被强制为0
  SUBROUTINE CFL(ncells, mesh, sln, fluid, dt, cfll)
    IMPLICIT NONE
    INTEGER(kind=8), INTENT(IN) :: ncells
! 函数返回值（原输出参数）
    REAL(kind=8), INTENT(OUT) :: cfll(ncells)
    TYPE(MESHH), INTENT(IN) :: mesh
    TYPE(SOLUTIONSTATE), INTENT(IN) :: sln
    TYPE(FLUIDD), INTENT(IN) :: fluid
    REAL(kind=8), INTENT(IN) :: dt
    INTEGER(kind=8) :: nfaces, nboundaries, nbdryfaces, meshinfo(4)
    INTEGER(kind=8) :: f, ownercell, neighbourcell
    REAL(kind=8), ALLOCATABLE :: facerhot(:, :), cellrhot(:, :)
    REAL(kind=8) :: facerho, facet, flux, a, dt_val, mag_val, dott
    REAL(kind=8), ALLOCATABLE :: facevel(:), positionn(:)
    INTRINSIC ABS
    INTRINSIC SQRT
    REAL(kind=8) :: abs0
    REAL(kind=8) :: arg1
    CALL UNSTRUCTUREDMESHINFO(mesh, meshinfo)
    nfaces = meshinfo(2)
    nboundaries = meshinfo(3)
    nbdryfaces = meshinfo(4)
    cfll = 0.0d0
! 插值得到面上的密度和温度
    ALLOCATE(facerhot(nfaces, 2), source=0.0d0)
    ALLOCATE(cellrhot(ncells, 2), source=0.0d0)
! ② 手动拼接两列数据（第1列：密度；第2列：温度）
! 第1列：单元格密度（来自 cellState 第1列）
    cellrhot(:, 1) = sln%cellstate(:, 1)
! 第2列：单元格温度（来自 cellPrimitives 第2
    cellrhot(:, 2) = sln%cellprimitives(:, 2)
! ③ 调用 linInterp_3D 插值到面
    CALL LININTERP_3D(mesh, cellrhot, facerhot)
    ALLOCATE(facevel(3), source=0.0d0)
    ALLOCATE(positionn(3), source=0.0d0)
    DO f=1,nfaces
      ownercell = mesh%faces(f, 1)
      neighbourcell = mesh%faces(f, 2)
      facerho = facerhot(f, 1)
      facet = facerhot(f, 2)
      IF (neighbourcell .EQ. -1) THEN
! 边界面，用cell值替代
        facerho = sln%cellstate(ownercell, 1)
        facet = sln%cellprimitives(ownercell, 2)
      END IF
      facevel = sln%facefluxes(f, 1:3)/facerho
      CALL DOT_PRODUCT_REAL(facevel, mesh%favecs(f, :), dott, 3)
      IF (dott .GE. 0.) THEN
        abs0 = dott
      ELSE
        abs0 = -dott
      END IF
      flux = abs0*dt
      IF (facet .LE. 0.0d0) THEN
        positionn = mesh%fcenters(f, :)
!			    print*, "Warning: Negative temperature at face ", f, ": ", positionn
      END IF
! 计算声速
      arg1 = fluid%gammaa*fluid%r*facet
      a = SQRT(arg1)
      CALL MAG(mesh%favecs(f, :), mag_val)
      flux = flux + mag_val*a*dt
! 将该face的流量贡献给相邻两个cell
      cfll(ownercell) = cfll(ownercell) + flux
      IF (neighbourcell .GT. -1) cfll(neighbourcell) = cfll(&
&         neighbourcell) + flux
    END DO
    DEALLOCATE(facevel)
    DEALLOCATE(positionn)
! 虽然没有return,但在 Julia 中，函数的返回值默认是最后一个表达式的值
! 除以两倍体积，符合CFL定义
    cfll = cfll/(2.0d0*mesh%cvols)
    DEALLOCATE(facerhot)
    DEALLOCATE(cellrhot)
  END SUBROUTINE CFL

!  Differentiation of populatesolution in forward (tangent) mode (with options i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4)
!:
!   Plus diff mem management of: sln.cellstate:in sln.cellfluxes:in-out
!                sln.cellprimitives:in-out sln.fluxresiduals:in
!                sln.facefluxes:in
! ######################### 解结构初始化 ###########################
! 构建SolutionState结构体，并初始化各变量矩阵
  SUBROUTINE POPULATESOLUTION_D(cellprimitives, ncells, nfaces, fluid, &
&   ndims, sln, slnd)
    IMPLICIT NONE
    REAL(kind=8), INTENT(IN) :: cellprimitives(:, :)
    INTEGER(kind=8), INTENT(IN) :: ncells, nfaces
    TYPE(FLUIDD), INTENT(IN) :: fluid
    INTEGER(kind=8), INTENT(IN), OPTIONAL :: ndims
    TYPE(SOLUTIONSTATE), INTENT(INOUT) :: sln
    TYPE(SOLUTIONSTATE), INTENT(INOUT) :: slnd
    INTEGER(kind=8) :: nconservedvars, nfluxes, ndims_val
    INTRINSIC PRESENT
! 默认维数
    ndims_val = 3
    IF (PRESENT(ndims)) ndims_val = ndims
    nconservedvars = 2 + ndims_val
    nfluxes = nconservedvars*ndims_val
! 分配结构体数组
!		allocate(sln%cellPrimitives(nCells, 5))
!		allocate(sln%cellState(nCells, nConservedVars))
!		allocate(sln%cellFluxes(nCells, nFluxes))
!		allocate(sln%fluxResiduals(nCells, nConservedVars))
!		allocate(sln%faceFluxes(nFaces, nFluxes))
! 赋初值
    sln%cellprimitives = cellprimitives
    WRITE(*, *) 'slnd%cellstate(微分):'
	write(*,'(I5,*(E12.5))') 2210, slnd%cellstate(2210,:)
	WRITE(*, *) 'slnd%cellprimitives(微分):'
	write(*,'(I5,*(E12.5))') 2210, slnd%cellprimitives(2210,:)
    CALL ENCODEPRIMITIVES3D(cellprimitives, fluid, sln%cellstate)
    sln%cellfluxes = 0.0d0
    sln%fluxresiduals = 0.0d0
    sln%facefluxes = 0.0d0
! 用解码函数填充原始变量和通量
    CALL DECODESOLUTION_3D_D(sln, slnd, fluid)
  END SUBROUTINE POPULATESOLUTION_D

! ######################### 解结构初始化 ###########################
! 构建SolutionState结构体，并初始化各变量矩阵
  SUBROUTINE POPULATESOLUTION(cellprimitives, ncells, nfaces, fluid, &
&   ndims, sln)
    IMPLICIT NONE
    REAL(kind=8), INTENT(IN) :: cellprimitives(:, :)
    INTEGER(kind=8), INTENT(IN) :: ncells, nfaces
    TYPE(FLUIDD), INTENT(IN) :: fluid
    INTEGER(kind=8), INTENT(IN), OPTIONAL :: ndims
    TYPE(SOLUTIONSTATE), INTENT(INOUT) :: sln
    INTEGER(kind=8) :: nconservedvars, nfluxes, ndims_val
    INTRINSIC PRESENT
! 默认维数
    ndims_val = 3
    IF (PRESENT(ndims)) ndims_val = ndims
    nconservedvars = 2 + ndims_val
    nfluxes = nconservedvars*ndims_val
! 分配结构体数组
!		allocate(sln%cellPrimitives(nCells, 5))
!		allocate(sln%cellState(nCells, nConservedVars))
!		allocate(sln%cellFluxes(nCells, nFluxes))
!		allocate(sln%fluxResiduals(nCells, nConservedVars))
!		allocate(sln%faceFluxes(nFaces, nFluxes))
! 赋初值
    sln%cellprimitives = cellprimitives
    CALL ENCODEPRIMITIVES3D(cellprimitives, fluid, sln%cellstate)
    sln%cellfluxes = 0.0d0
    sln%fluxresiduals = 0.0d0
    sln%facefluxes = 0.0d0
! 用解码函数填充原始变量和通量
    CALL DECODESOLUTION_3D(sln, fluid)
  END SUBROUTINE POPULATESOLUTION

!  Differentiation of restricttimestep in forward (tangent) mode (with options i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4)
!:
!   variations   of useful results: res.actualdt
!   with respect to varying inputs: status_val.currenttime
! ######################### 时间步长调整 ###########################
! 判断是否需要限制当前时间步大小$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
  SUBROUTINE RESTRICTTIMESTEP_D(status_val, status_vald, desireddt, res&
&   , resd)
    IMPLICIT NONE
    TYPE(SOLVERSTATUS), INTENT(IN) :: status_val
    TYPE(SOLVERSTATUS_DIFF), INTENT(IN) :: status_vald
    REAL(kind=8), INTENT(IN) :: desireddt
! 使用派生类型作为返回值
    TYPE(RESTRICTRESULT), INTENT(INOUT) :: res
    TYPE(RESTRICTRESULT_DIFF), INTENT(INOUT) :: resd
    REAL(kind=8) :: maxstep
    REAL(kind=8) :: maxstepd
    INTRINSIC MIN
    IF (status_val%endtime - status_val%currenttime .GT. status_val%&
&       nextoutputtime - status_val%currenttime) THEN
      maxstepd = -status_vald%currenttime
      maxstep = status_val%nextoutputtime - status_val%currenttime
    ELSE
      maxstepd = -status_vald%currenttime
      maxstep = status_val%endtime - status_val%currenttime
    END IF
    IF (desireddt .GT. maxstep) THEN
! 第1列：需要截断
      res%needtruncate = .true.
! 第2列：实际时间步长
      resd%actualdt = maxstepd
      res%actualdt = maxstep
    ELSE
! 第1列：不需要截断
      res%needtruncate = .false.
! 第2列：实际时间步长
      res%actualdt = desireddt
      resd%actualdt = 0.0_8
    END IF
  END SUBROUTINE RESTRICTTIMESTEP_D

! ######################### 时间步长调整 ###########################
! 判断是否需要限制当前时间步大小$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
  SUBROUTINE RESTRICTTIMESTEP(status_val, desireddt, res)
    IMPLICIT NONE
    TYPE(SOLVERSTATUS), INTENT(IN) :: status_val
    REAL(kind=8), INTENT(IN) :: desireddt
! 使用派生类型作为返回值
    TYPE(RESTRICTRESULT), INTENT(INOUT) :: res
    REAL(kind=8) :: maxstep
    INTRINSIC MIN
    IF (status_val%endtime - status_val%currenttime .GT. status_val%&
&       nextoutputtime - status_val%currenttime) THEN
      maxstep = status_val%nextoutputtime - status_val%currenttime
    ELSE
      maxstep = status_val%endtime - status_val%currenttime
    END IF
    IF (desireddt .GT. maxstep) THEN
! 第1列：需要截断
      res%needtruncate = .true.
! 第2列：实际时间步长
      res%actualdt = maxstep
    ELSE
! 第1列：不需要截断
      res%needtruncate = .false.
! 第2列：实际时间步长
      res%actualdt = desireddt
    END IF
  END SUBROUTINE RESTRICTTIMESTEP

!  Differentiation of adjusttimestep_lts in forward (tangent) mode (with options i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r
!4):
!   variations   of useful results: dt output
!   with respect to varying inputs: dt status_val.currenttime
! $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
! targetCFL初始值为0.2
! 用于局部时间步长方法 (Local Time Stepping)
  SUBROUTINE ADJUSTTIMESTEP_LTS_D(targetcfl, dt, dtd, status_val, &
&   status_vald, output, outputd)
    IMPLICIT NONE
! 目标CFL数
    REAL(kind=8), INTENT(IN) :: targetcfl
! 时间步长数组（修改第一个元素）
    REAL(kind=8), INTENT(INOUT) :: dt(:)
    REAL(kind=8), INTENT(INOUT) :: dtd(:)
! 求解器状态
    TYPE(SOLVERSTATUS), INTENT(IN) :: status_val
    TYPE(SOLVERSTATUS_DIFF), INTENT(IN) :: status_vald
! 返回数组：[writeOutputThisIteration(逻辑值转为实数), dt(1), CFL]		
    REAL(kind=8), INTENT(INOUT) :: output(3)
    REAL(kind=8), INTENT(INOUT) :: outputd(3)
    TYPE(RESTRICTRESULT) :: res
    TYPE(RESTRICTRESULT_DIFF) :: resd
! 实际CFL数
    REAL(kind=8) :: cfll
    REAL(kind=8) :: cflld
    INTRINSIC MERGE
    REAL(real64) :: result1
! 根据当前时间步数调整CFL（前10步逐渐增加到目标值）
    IF (status_val%ntimesteps .LT. 10) THEN
      cfll = (status_val%ntimesteps+1)*targetcfl/10
    ELSE
      cfll = targetcfl
    END IF
! 调用restrictTimeStep限制时间步长
    CALL RESTRICTTIMESTEP_D(status_val, status_vald, cfll, res, resd)
! 直接将限制后的时间步长赋值给dt(1)
    cflld = resd%actualdt
    cfll = res%actualdt
    dtd(1) = cflld
    dt(1) = cfll
    PRINT*, 'bdt', dt(1)
! 修正：数组构造器使用逗号分隔，续行符正确
! 第1元素：是否输出
! 这里事实上dt，但只能输出标量，那就只能输出dt(1),也即CFLL了
    result1 = MERGE(1.0_real64, 0.0_real64, res%needtruncate)
    outputd = (/0.0_8, dtd(1), cflld/)
    output = (/result1, dt(1), cfll/)
! 新增：打印函数内部的output(3)，验证是否为0.5
  END SUBROUTINE ADJUSTTIMESTEP_LTS_D

! $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
! targetCFL初始值为0.2
! 用于局部时间步长方法 (Local Time Stepping)
  SUBROUTINE ADJUSTTIMESTEP_LTS(targetcfl, dt, status_val, output)
    IMPLICIT NONE
! 目标CFL数
    REAL(kind=8), INTENT(IN) :: targetcfl
! 时间步长数组（修改第一个元素）
    REAL(kind=8), INTENT(INOUT) :: dt(:)
! 求解器状态
    TYPE(SOLVERSTATUS), INTENT(IN) :: status_val
! 返回数组：[writeOutputThisIteration(逻辑值转为实数), dt(1), CFL]		
    REAL(kind=8), INTENT(INOUT) :: output(3)
    TYPE(RESTRICTRESULT) :: res
! 实际CFL数
    REAL(kind=8) :: cfll
    INTRINSIC MERGE
    REAL(real64) :: result1
! 根据当前时间步数调整CFL（前10步逐渐增加到目标值）
    IF (status_val%ntimesteps .LT. 10) THEN
      cfll = (status_val%ntimesteps+1)*targetcfl/10
    ELSE
      cfll = targetcfl
    END IF
! 调用restrictTimeStep限制时间步长
    CALL RESTRICTTIMESTEP(status_val, cfll, res)
! 直接将限制后的时间步长赋值给dt(1)
    cfll = res%actualdt
    dt(1) = cfll
    PRINT*, 'bdt', dt(1)
! 修正：数组构造器使用逗号分隔，续行符正确
! 第1元素：是否输出
! 这里事实上dt，但只能输出标量，那就只能输出dt(1),也即CFLL了
    result1 = MERGE(1.0_real64, 0.0_real64, res%needtruncate)
    output = (/result1, dt(1), cfll/)
! 新增：打印函数内部的output(3)，验证是否为0.5
  END SUBROUTINE ADJUSTTIMESTEP_LTS

!  Differentiation of advancestatus in forward (tangent) mode (with options i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4):
!   variations   of useful results: status_val.currenttime
!   with respect to varying inputs: cfll status_val.currenttime
! 更新时间步状态
  SUBROUTINE ADVANCESTATUS_D(status_val, status_vald, dt, cfll, cflld, &
&   timeintegrationfn, silent)
    IMPLICIT NONE
    TYPE(SOLVERSTATUS), INTENT(INOUT) :: status_val
    TYPE(SOLVERSTATUS_DIFF), INTENT(INOUT) :: status_vald
    REAL(kind=8), INTENT(IN) :: dt(:), cfll
    REAL(kind=8), INTENT(IN) :: cflld
    CHARACTER(len=*), INTENT(IN) :: timeintegrationfn
    LOGICAL, INTENT(IN) :: silent
! 更新时间步数量
    status_val%ntimesteps = status_val%ntimesteps + 1
! 如果是LTSEuler时间推进方式，则累加模拟时间
!if (timeIntegrationFn == 'LTSEuler')
    status_vald%currenttime = status_vald%currenttime + cflld
    status_val%currenttime = status_val%currenttime + cfll
! 输出信息（可选）
    IF (.NOT.silent) WRITE(*, '(A,I5,A,F9.4,A,F9.4)') 'Timestep: ', &
&                    status_val%ntimesteps, ', simTime: ', status_val%&
&                    currenttime, ', Max CFLL: ', cfll
  END SUBROUTINE ADVANCESTATUS_D

! 更新时间步状态
  SUBROUTINE ADVANCESTATUS(status_val, dt, cfll, timeintegrationfn, &
&   silent)
    IMPLICIT NONE
    TYPE(SOLVERSTATUS), INTENT(INOUT) :: status_val
    REAL(kind=8), INTENT(IN) :: dt(:), cfll
    CHARACTER(len=*), INTENT(IN) :: timeintegrationfn
    LOGICAL, INTENT(IN) :: silent
! 更新时间步数量
    status_val%ntimesteps = status_val%ntimesteps + 1
! 如果是LTSEuler时间推进方式，则累加模拟时间
!if (timeIntegrationFn == 'LTSEuler')
    status_val%currenttime = status_val%currenttime + cfll
! 输出信息（可选）
    IF (.NOT.silent) WRITE(*, '(A,I5,A,F9.4,A,F9.4)') 'Timestep: ', &
&                    status_val%ntimesteps, ', simTime: ', status_val%&
&                    currenttime, ', Max CFLL: ', cfll
  END SUBROUTINE ADVANCESTATUS

! 默认空气属性初始化函数
  SUBROUTINE FLUIDDD(fluid)
    IMPLICIT NONE
    TYPE(FLUIDD), INTENT(OUT) :: fluid
    fluid%cp = 1005.0d0
    fluid%r = 287.05d0
    fluid%gammaa = 1.4d0
  END SUBROUTINE FLUIDDD

!  Differentiation of solve in forward (tangent) mode (with options i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4):
!   variations   of useful results: cellprimitives
!   with respect to varying inputs: [alloc*(mesh.ccenters) in openfoammesh]
!                [alloc*(mesh.cvols) in openfoammesh] [alloc*(mesh.fcenters) in openfoammesh]
!                [alloc*(mesh.favecs) in openfoammesh]
!   Plus diff mem management of: [alloc*sln in solve].cellstate:in-out
!                [alloc*sln in solve].cellfluxes:in-out [alloc*sln in solve].cellprimitives:in-out
!                [alloc*sln in solve].fluxresiduals:in-out [alloc*sln in solve].facefluxes:in-out
!                point_update:in mesh.cvols:in mesh.ccenters:in
!                mesh.favecs:in mesh.fcenters:in
! ######################### 主求解函数 ###########################
! CFD主循环
! 原行过长，拆分为多行
  SUBROUTINE SOLVE_D(mesh, meshd, meshpath, cellprimitives, &
&   cellprimitivesd, boundaryconditions, point_update, point_updated)
    IMPLICIT NONE
! 仅保留必要输入参数（移除已知参数的输入）
    TYPE(MESHH), INTENT(IN) :: mesh
    TYPE(MESHH_DIFF), INTENT(IN) :: meshd
    CHARACTER(len=*), INTENT(IN) :: meshpath
! 输入：变形网格点
    REAL*8, ALLOCATABLE, INTENT(IN) :: point_update(:, :)
    REAL*8, ALLOCATABLE, INTENT(IN) :: point_updated(:, :)
    REAL(kind=8), INTENT(INOUT) :: cellprimitives(:, :)
    REAL(kind=8), INTENT(INOUT) :: cellprimitivesd(:, :)
    TYPE(BOUNDARYCONDITION), INTENT(IN) :: boundaryconditions(:)
! 函数返回值（重命名避免与函数名冲突，不改变功能）
!real(kind=8), allocatable :: solve_result(:,:)		
! 内部变量声明（完全保留原逻辑）
    INTEGER(kind=8) :: ncells, nfaces, nboundaries, nbdryfaces, meshinfo&
&   (4), tsresult(3)
    TYPE(SOLUTIONSTATE), ALLOCATABLE :: sln
    TYPE(SOLUTIONSTATE), ALLOCATABLE :: slnd
    REAL(kind=8), ALLOCATABLE :: dt(:)
    REAL(kind=8), ALLOCATABLE :: dtd(:)
    TYPE(SOLVERSTATUS) :: status_val
    TYPE(SOLVERSTATUS_DIFF) :: status_vald
    REAL(kind=8), ALLOCATABLE :: cflvec(:)
    REAL(kind=8) :: cfll, ltsresult(3)
    REAL(kind=8) :: cflld, ltsresultd(3)
    LOGICAL :: writeoutputthisiteration, silent, restart, &
&   createrestartfile, createvtkoutput
    CHARACTER(len=32) :: timeintegrationfn, fluxfunction
    REAL(kind=8) :: initdt, endtime, outputinterval, targetcfl
    TYPE(FLUIDD) :: fluid
    CHARACTER(len=256) :: restartfile
! 新增：用于输出的变量!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1
! 循环变量、总点数、单元顶点数
    INTEGER(kind=8) :: i, j, npts, npointspercell, l
! 存储单元的顶点索引（假设最多8个顶点）
    INTEGER(kind=8) :: pointindices(8)
    INTEGER(kind=8) :: nconservedvars, nfluxes, ndims_val, print_num
    INTRINSIC ABS
    INTRINSIC NEW_LINE
    INTRINSIC SIZE
    INTRINSIC MIN
    REAL(kind=8) :: abs0
    INTEGER(kind=8) :: min1
! 设置已知参数的默认值（直接固定，不再通过输入修改）
! 已知时间积分方法
    timeintegrationfn = 'LTSEuler'
! 已知通量函数
    fluxfunction = 'unstructured_JSTFlux'
! 已知初始时间步
    initdt = 0.0000001
! 已知总仿真时间!!!!!
    endtime = 1
! 已知输出间隔
    outputinterval = 25
! 已知目标CFL数
    targetcfl = 0.5
! 已知流体属性
    CALL FLUIDDD(fluid)
! 已知静默模式
    silent = .false.
! 已知不重启
    restart = .false.
! 已知创建重启文件
    createrestartfile = .true.
! 已知创建VTK输出
    createvtkoutput = .true.
! 已知重启文件路径
    restartfile = 'FvCFDRestart.txt'
! 以下代码完全保留原逻辑，不做任何修改
    IF (.NOT.silent) PRINT*, 'Initializing Simulation'
    CALL UNSTRUCTUREDMESHINFO(mesh, meshinfo)
    ncells = meshinfo(1)
    nfaces = meshinfo(2)
    nboundaries = meshinfo(3)
    nbdryfaces = meshinfo(4)
!!!!!!!!!!!!!!!!!!!!!!!!!!!!这些代码原来是populateSolution里面的!!!!!!!!!!!!!!!!!!!!!!!
! 默认维数
    ndims_val = 3
!		if (present(nDims)) nDims_val = nDims
    nconservedvars = 2 + ndims_val
    nfluxes = nconservedvars*ndims_val
    ALLOCATE(slnd)
    ALLOCATE(sln)
! 分配结构体数组
    ALLOCATE(slnd%cellprimitives(ncells, 5), source=0.0d0)
    ALLOCATE(sln%cellprimitives(ncells, 5), source=0.0d0)
    ALLOCATE(slnd%cellstate(ncells, nconservedvars), source=0.0d0)
    ALLOCATE(sln%cellstate(ncells, nconservedvars), source=0.0d0)
    ALLOCATE(slnd%cellfluxes(ncells, nfluxes), source=0.0d0)
    ALLOCATE(sln%cellfluxes(ncells, nfluxes), source=0.0d0)
    ALLOCATE(slnd%fluxresiduals(ncells, nconservedvars), source=0.0d0)
    ALLOCATE(sln%fluxresiduals(ncells, nconservedvars), source=0.0d0)
    ALLOCATE(slnd%facefluxes(nfaces, nfluxes), source=0.0d0)
    ALLOCATE(sln%facefluxes(nfaces, nfluxes), source=0.0d0)
! 赋初值
    slnd%cellprimitives = 0.0_8
    sln%cellprimitives = cellprimitives
!$AD OUTPUT sln%cellPrimitives  ! 输出可微
    CALL ENCODEPRIMITIVES3D(cellprimitives, fluid, sln%cellstate)
    slnd%cellfluxes = 0.0_8
    sln%cellfluxes = 0.0d0
    slnd%fluxresiduals = 0.0_8
    sln%fluxresiduals = 0.0d0
    slnd%facefluxes = 0.0_8
    sln%facefluxes = 0.0d0
    CALL POPULATESOLUTION_D(cellprimitives, ncells, nfaces, fluid, &
&                     3_int64, sln, slnd)
	WRITE(*, *) 'cellFluxes:'
!		do i = 1, min(5, size(sln%cellFluxes,1))
!		    write(*,'(I5,*(E12.5))') i, sln%cellFluxes(i,:)
    WRITE(*, '(I5,*(E12.5))') 2210, sln%cellfluxes(2210, :)
    write(*,'(I5,*(E12.5))') 2305, sln%cellFluxes(2305,:)
!		end do
    WRITE(*, *) 'slnd%cellFluxes(微分):'
!		do i = 1, min(5, size(slnd%cellFluxes,1))
!		    write(*,'(I5,*(E12.5))') i, slnd%cellFluxes(i,:)
	write(*,'(I5,*(E12.5))') 2210, slnd%cellFluxes(2210,:)
	write(*,'(I5,*(E12.5))') 2305, slnd%cellFluxes(2305,:)
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!这里的cellstate没问题,cellprimite和cellfulex也基本没问题
    ALLOCATE(dtd(ncells), source=0.0d0)
    ALLOCATE(dt(ncells), source=0.0d0)
    IF (timeintegrationfn .EQ. 'LTSEuler') THEN
      dtd = 0.0_8
      dt = 0.0d0
    ELSE
      dtd = 0.0_8
      dt = initdt
    END IF
    status_val = SOLVERSTATUS(0, 0, outputinterval, endtime)
    ALLOCATE(cflvec(ncells), source=0.0d0)
    cflvec = 0.0d0
    IF (.NOT.silent) PRINT*, 'Starting iterations'
    PRINT*, 'a2'
    status_vald%currenttime = 0.0_8
!这里primitives没问题
    DO WHILE (status_val%currenttime .LT. status_val%endtime)
      ltsresultd = 0.0_8
      CALL ADJUSTTIMESTEP_LTS_D(targetcfl, dt, dtd, status_val, &
&                         status_vald, ltsresult, ltsresultd)
      IF (ltsresult(1) - 1.0d0 .GE. 0.) THEN
        abs0 = ltsresult(1) - 1.0d0
      ELSE
        abs0 = -(ltsresult(1)-1.0d0)
      END IF
! 转换逻辑值
      writeoutputthisiteration = abs0 .LT. 1d-10
      dtd(1) = ltsresultd(2)
      dt(1) = ltsresult(2)
      cflld = ltsresultd(3)
      cfll = ltsresult(3)
      PRINT*, 'adt', dt(1)
      CALL LTSEULER_D(mesh, meshd, sln, slnd, boundaryconditions, fluid&
&               , dt, dtd)
!#dt和CFL都是向量，列数为1，行数为cells	    	    		    
! CFLL*ones(size(dt)将标量CFLL扩展为与dt同维度的数组
! 原错误行：merge(dt, CFLL*ones(size(dt)), ...)
! 修正为：使用repeat函数创建标量数组或直接初始化数组
!原julia和现在的Fortran：dt都是向量，CFL是标量
      CALL ADVANCESTATUS_D(status_val, status_vald, dt, cfll, cflld, &
&                    timeintegrationfn, silent)
      IF (writeoutputthisiteration) status_val%nextoutputtime = &
&         status_val%nextoutputtime + outputinterval
    END DO
! 简化后的输出：仅保留单元索引和流场数据!!!!!!!!!!!!!!!!!!!!
    PRINT*, NEW_LINE('a')//'=== 前100个单元的流场数据 ==='
    PRINT*, '总单元数: ', ncells
    PRINT*, '流场数据维度: ', SIZE(sln%cellprimitives, 1), '×', &
&   SIZE(sln%cellprimitives, 2), '（行×列）'
    PRINT*, '格式：单元索引 | P | T | Ux | Uy | Uz'
    IF (15 .GT. ncells) THEN
      min1 = ncells
    ELSE
      min1 = 15
    END IF
! 输出前100个单元的流场数据（仅整数和实数，避免格式冲突）
    DO i=1,min1
!		if (i == 2210) then
! P（科学计数法，14位宽，6位小数）
! T
! Ux
! Uy
! Uz  ! U分量（实数）
      WRITE(*, '(I5, 5ES14.6)') i, sln%cellprimitives(i, 1), sln%&
&     cellprimitives(i, 2), sln%cellprimitives(i, 3), sln%cellprimitives&
&     (i, 4), sln%cellprimitives(i, 5)
!		end if
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    END DO
    cellprimitivesd = slnd%cellprimitives
    cellprimitives = sln%cellprimitives
    IF (5 .GT. ncells) THEN
      print_num = ncells
    ELSE
      print_num = 5
    END IF
    PRINT*, NEW_LINE('a')//&
&   '=== 前5个单元的 cellprimitivesd 数据 ==='
    PRINT*, '格式：单元索引 | dP | dT | dUx | dUy | dUz'
!		WRITE(*, '(I5, 5F12.6)') 2210, &
!		        cellprimitivesd(2210, 1),  &  ! dP
!		        cellprimitivesd(2210, 2),  &  ! dT
!		        cellprimitivesd(2210, 3),  &  ! dUx
!		        cellprimitivesd(2210, 4),  &  ! dUy
!		        cellprimitivesd(2210, 5)     ! dUz	
!		DO i = 1, print_num
! 输出每个单元的 cellprimitivesd 分量（假设为5列，与 cellprimitives 一致）
!		    WRITE(*, '(I5, 5F12.6)') i, &
!		        cellprimitivesd(i, 1),  &  ! dP
!		        cellprimitivesd(i, 2),  &  ! dT
!		        cellprimitivesd(i, 3),  &  ! dUx
!		        cellprimitivesd(i, 4),  &  ! dUy
!		        cellprimitivesd(i, 5)     ! dUz
!		END DO
	call writeoutput_d(sln%cellprimitives, cellprimitivesd, restartfile, meshpath&
	, createrestartfile, createvtkoutput, point_update)
!    CALL WRITEOUTPUT(sln%cellprimitives, restartfile, meshpath, &
!&              createrestartfile, createvtkoutput, point_update)
    IF (ALLOCATED(dtd)) THEN
      DEALLOCATE(dtd)
    END IF
    DEALLOCATE(dt)
    DEALLOCATE(cflvec)
  END SUBROUTINE SOLVE_D

! ######################### 主求解函数 ###########################
! CFD主循环
! 原行过长，拆分为多行
  SUBROUTINE SOLVE(mesh, meshpath, cellprimitives, boundaryconditions, &
&   point_update)
    IMPLICIT NONE
! 仅保留必要输入参数（移除已知参数的输入）
    TYPE(MESHH), INTENT(IN) :: mesh
    CHARACTER(len=*), INTENT(IN) :: meshpath
! 输入：变形网格点
    REAL*8, ALLOCATABLE, INTENT(IN) :: point_update(:, :)
    REAL(kind=8), INTENT(INOUT) :: cellprimitives(:, :)
    TYPE(BOUNDARYCONDITION), INTENT(IN) :: boundaryconditions(:)
! 函数返回值（重命名避免与函数名冲突，不改变功能）
!real(kind=8), allocatable :: solve_result(:,:)		
! 内部变量声明（完全保留原逻辑）
    INTEGER(kind=8) :: ncells, nfaces, nboundaries, nbdryfaces, meshinfo&
&   (4), tsresult(3)
    TYPE(SOLUTIONSTATE), ALLOCATABLE :: sln
    REAL(kind=8), ALLOCATABLE :: dt(:)
    TYPE(SOLVERSTATUS) :: status_val
    REAL(kind=8), ALLOCATABLE :: cflvec(:)
    REAL(kind=8) :: cfll, ltsresult(3)
    LOGICAL :: writeoutputthisiteration, silent, restart, &
&   createrestartfile, createvtkoutput
    CHARACTER(len=32) :: timeintegrationfn, fluxfunction
    REAL(kind=8) :: initdt, endtime, outputinterval, targetcfl
    TYPE(FLUIDD) :: fluid
    CHARACTER(len=256) :: restartfile
! 新增：用于输出的变量!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!1
! 循环变量、总点数、单元顶点数
    INTEGER(kind=8) :: i, j, npts, npointspercell, l
! 存储单元的顶点索引（假设最多8个顶点）
    INTEGER(kind=8) :: pointindices(8)
    INTEGER(kind=8) :: nconservedvars, nfluxes, ndims_val, print_num
    INTRINSIC ABS
    INTRINSIC NEW_LINE
    INTRINSIC SIZE
    INTRINSIC MIN
    REAL(kind=8) :: abs0
    INTEGER(kind=8) :: min1
! 设置已知参数的默认值（直接固定，不再通过输入修改）
! 已知时间积分方法
    timeintegrationfn = 'LTSEuler'
! 已知通量函数
    fluxfunction = 'unstructured_JSTFlux'
! 已知初始时间步
    initdt = 0.0000001
! 已知总仿真时间!!!!!
    endtime = 2500
! 已知输出间隔
    outputinterval = 25
! 已知目标CFL数
    targetcfl = 0.5
! 已知流体属性
    CALL FLUIDDD(fluid)
! 已知静默模式
    silent = .false.
! 已知不重启
    restart = .false.
! 已知创建重启文件
    createrestartfile = .true.
! 已知创建VTK输出
    createvtkoutput = .true.
! 已知重启文件路径
    restartfile = 'FvCFDRestart.txt'
! 以下代码完全保留原逻辑，不做任何修改
    IF (.NOT.silent) PRINT*, 'Initializing Simulation'
    CALL UNSTRUCTUREDMESHINFO(mesh, meshinfo)
    ncells = meshinfo(1)
    nfaces = meshinfo(2)
    nboundaries = meshinfo(3)
    nbdryfaces = meshinfo(4)
!!!!!!!!!!!!!!!!!!!!!!!!!!!!这些代码原来是populateSolution里面的!!!!!!!!!!!!!!!!!!!!!!!
! 默认维数
    ndims_val = 3
!		if (present(nDims)) nDims_val = nDims
    nconservedvars = 2 + ndims_val
    nfluxes = nconservedvars*ndims_val
    ALLOCATE(sln)
! 分配结构体数组
    ALLOCATE(sln%cellprimitives(ncells, 5), source=0.0d0)
    ALLOCATE(sln%cellstate(ncells, nconservedvars), source=0.0d0)
    ALLOCATE(sln%cellfluxes(ncells, nfluxes), source=0.0d0)
    ALLOCATE(sln%fluxresiduals(ncells, nconservedvars), source=0.0d0)
    ALLOCATE(sln%facefluxes(nfaces, nfluxes), source=0.0d0)
! 赋初值
    sln%cellprimitives = cellprimitives
!$AD OUTPUT sln%cellPrimitives  ! 输出可微
    CALL ENCODEPRIMITIVES3D(cellprimitives, fluid, sln%cellstate)
    sln%cellfluxes = 0.0d0
    sln%fluxresiduals = 0.0d0
    sln%facefluxes = 0.0d0
    CALL POPULATESOLUTION(cellprimitives, ncells, nfaces, fluid, 3_int64&
&                   , sln)
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!这里的cellstate没问题,cellprimite和cellfulex也基本没问题
    ALLOCATE(dt(ncells), source=0.0d0)
    IF (timeintegrationfn .EQ. 'LTSEuler') THEN
      dt = 0.0d0
    ELSE
      dt = initdt
    END IF
    status_val = SOLVERSTATUS(0, 0, outputinterval, endtime)
    ALLOCATE(cflvec(ncells), source=0.0d0)
    cflvec = 0.0d0
    IF (.NOT.silent) PRINT*, 'Starting iterations'
    PRINT*, 'a2'
!这里primitives没问题
    DO WHILE (status_val%currenttime .LT. status_val%endtime)
      CALL ADJUSTTIMESTEP_LTS(targetcfl, dt, status_val, ltsresult)
      IF (ltsresult(1) - 1.0d0 .GE. 0.) THEN
        abs0 = ltsresult(1) - 1.0d0
      ELSE
        abs0 = -(ltsresult(1)-1.0d0)
      END IF
! 转换逻辑值
      writeoutputthisiteration = abs0 .LT. 1d-10
      dt(1) = ltsresult(2)
      cfll = ltsresult(3)
      PRINT*, 'adt', dt(1)
      CALL LTSEULER(mesh, sln, boundaryconditions, fluid, dt)
!#dt和CFL都是向量，列数为1，行数为cells	    	    		    
! CFLL*ones(size(dt)将标量CFLL扩展为与dt同维度的数组
! 原错误行：merge(dt, CFLL*ones(size(dt)), ...)
! 修正为：使用repeat函数创建标量数组或直接初始化数组
!原julia和现在的Fortran：dt都是向量，CFL是标量
      CALL ADVANCESTATUS(status_val, dt, cfll, timeintegrationfn, silent&
&                 )
      IF (writeoutputthisiteration) status_val%nextoutputtime = &
&         status_val%nextoutputtime + outputinterval
    END DO
! 简化后的输出：仅保留单元索引和流场数据!!!!!!!!!!!!!!!!!!!!
    PRINT*, NEW_LINE('a')//'=== 前100个单元的流场数据 ==='
    PRINT*, '总单元数: ', ncells
    PRINT*, '流场数据维度: ', SIZE(sln%cellprimitives, 1), '×', &
&   SIZE(sln%cellprimitives, 2), '（行×列）'
    PRINT*, '格式：单元索引 | P | T | Ux | Uy | Uz'
    IF (15 .GT. ncells) THEN
      min1 = ncells
    ELSE
      min1 = 15
    END IF
! 输出前100个单元的流场数据（仅整数和实数，避免格式冲突）
    DO i=1,min1
!		if (i == 2210) then
! P（科学计数法，14位宽，6位小数）
! T
! Ux
! Uy
! Uz  ! U分量（实数）
      WRITE(*, '(I5, 5ES14.6)') i, sln%cellprimitives(i, 1), sln%&
&     cellprimitives(i, 2), sln%cellprimitives(i, 3), sln%cellprimitives&
&     (i, 4), sln%cellprimitives(i, 5)
!		end if
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    END DO
    cellprimitives = sln%cellprimitives
    IF (5 .GT. ncells) THEN
      print_num = ncells
    ELSE
      print_num = 5
    END IF
    PRINT*, NEW_LINE('a')//&
&   '=== 前5个单元的 cellprimitivesd 数据 ==='
    PRINT*, '格式：单元索引 | dP | dT | dUx | dUy | dUz'
!		WRITE(*, '(I5, 5F12.6)') 2210, &
!		        cellprimitivesd(2210, 1),  &  ! dP
!		        cellprimitivesd(2210, 2),  &  ! dT
!		        cellprimitivesd(2210, 3),  &  ! dUx
!		        cellprimitivesd(2210, 4),  &  ! dUy
!		        cellprimitivesd(2210, 5)     ! dUz	
!		DO i = 1, print_num
! 输出每个单元的 cellprimitivesd 分量（假设为5列，与 cellprimitives 一致）
!		    WRITE(*, '(I5, 5F12.6)') i, &
!		        cellprimitivesd(i, 1),  &  ! dP
!		        cellprimitivesd(i, 2),  &  ! dT
!		        cellprimitivesd(i, 3),  &  ! dUx
!		        cellprimitivesd(i, 4),  &  ! dUy
!		        cellprimitivesd(i, 5)     ! dUz
!		END DO
!		call writeoutput_d(sln%cellprimitives, cellprimitivesd, restartfile, meshpath, &  ! 新增cellprimitivesd
!&              createrestartfile, createvtkoutput, point_update)
    CALL WRITEOUTPUT(sln%cellprimitives, restartfile, meshpath, &
&              createrestartfile, createvtkoutput, point_update)
    DEALLOCATE(dt)
    DEALLOCATE(cflvec)
  END SUBROUTINE SOLVE

!  Differentiation of updateinletboundary in forward (tangent) mode (with options i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 
!r4):
!   variations   of useful results: [alloc*(*sln.facefluxes) in solve]
!                *([alloc*sln in solve].facefluxes)
!   with respect to varying inputs: [alloc*(sln.cellprimitives) in decodesolution_3d]
!                [alloc*(*sln.facefluxes) in solve] [alloc*(*sln.cellprimitives) in solve]
!                *([alloc*sln in solve].cellprimitives) *([alloc*sln in solve].facefluxes)
!   Plus diff mem management of: sln.cellprimitives:in sln.facefluxes:in
! end
! 3.boundaryConditions.jl!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! 为一些特殊的边界（如入口，出口，壁面，0梯度边界等）设置特殊的条件即边界条件（例如壁面
!质量通量为0）
! ######################### 边界条件实现 #########################
! 这些边界条件函数的作用是：
!  1. 在求解器中补充内部面通量计算之外的“边界面通量”；
!  2. 在 JST 等数值格式中，内部面通量由通量函数计算，但边界面需要专门强制设置；
!  3. 每个函数实现一种常见边界条件，如超音速入口、出口、壁面、对称等。
! ------------ 亚音速入口边界条件（使用总压/总温）------------
! 输入变量为总压、总温、入口速度方向单位向量（nx, ny, nz）
! 算法来自 FUN3D 求解器：在边界计算静态压强和温度，再重建变量
  SUBROUTINE UPDATEINLETBOUNDARY_D(mesh, sln, slnd, boundarynumber, &
&   inletconditions, fluid)
    IMPLICIT NONE
    TYPE(MESHH), INTENT(IN) :: mesh
    TYPE(SOLUTIONSTATE), INTENT(INOUT) :: sln
    TYPE(SOLUTIONSTATE), INTENT(INOUT) :: slnd
    INTEGER(kind=8), INTENT(IN) :: boundarynumber
! [总压Pt, 总温Tt, 速度方向nx, ny]
    REAL(kind=8), INTENT(IN) :: inletconditions(4)
    TYPE(FLUIDD), INTENT(IN) :: fluid
    INTEGER(kind=8) :: face, ownercell
    INTEGER(kind=8), SAVE :: stat=0
    INTEGER(kind=8), ALLOCATABLE :: currentboundary(:)
    REAL(kind=8) :: pt, tt, nx, ny, nz, gammaa, r
    REAL(kind=8) :: adjustedvelocity, machnum, e
    REAL(kind=8) :: adjustedvelocityd, machnumd, ed
    REAL(kind=8) :: primitives(5), state(5), velunitvector(3), &
&   boundaryfluxes(15)
    REAL(kind=8) :: primitivesd(5), stated(5), velunitvectord(3), &
&   boundaryfluxesd(15)
    INTEGER(kind=8) :: ncells, nfaces, nfaceperbdry, face_idx
    INTRINSIC SIZE
    INTRINSIC ABS
    INTRINSIC SQRT
    INTRINSIC SUM
    REAL(kind=8) :: abs0
    REAL(kind=8) :: abs0d
    REAL(kind=8) :: arg1
    REAL(kind=8) :: arg1d
    REAL(kind=8) :: result1
    REAL(kind=8) :: result1d
    REAL(kind=8), DIMENSION(3) :: arg10
    REAL(kind=8), DIMENSION(3) :: arg10d
    DOUBLE PRECISION :: temp
    REAL(kind=8) :: temp0
    REAL(kind=8) :: tempd
    REAL(kind=8) :: temp1
    REAL(kind=8) :: temp2
    nfaces = SIZE(mesh%faces, 1)
    ncells = SIZE(sln%cellstate, 1)
    gammaa = fluid%gammaa
    r = fluid%r
    pt = inletconditions(1)
    tt = inletconditions(2)
    nx = inletconditions(3)
    ny = inletconditions(4)
    nz = 0.0d0
    velunitvector = (/nx, ny, nz/)
    nfaceperbdry = SIZE(mesh%boundaryfaces, 2)
    ALLOCATE(currentboundary(nfaceperbdry), stat=stat)
    currentboundary = mesh%boundaryfaces(boundarynumber, :)
    primitivesd = 0.0_8
    stated = 0.0_8
    DO face=1,nfaceperbdry
      face_idx = currentboundary(face)
!exit 语句的作用是立即终止当前所在的循环
!nFacePerBdry是所有的边界面,currentBoundary
      IF (face_idx .EQ. 0) THEN
        EXIT
      ELSE
        ownercell = mesh%faces(face_idx, 1)
        velunitvectord = 0.0_8
        CALL DOT_PRODUCT_REAL_D(velunitvector, velunitvectord, sln%&
&                         cellprimitives(ownercell, 3:5), slnd%&
&                         cellprimitives(ownercell, 3:5), &
&                         adjustedvelocity, adjustedvelocityd, 3)
        temp = 2.0d0*gammaa*r
        primitivesd(2) = -((gammaa-1.0d0)*2*adjustedvelocity*&
&         adjustedvelocityd/temp)
        primitives(2) = tt - (gammaa-1.0d0)*(adjustedvelocity*&
&         adjustedvelocity/temp)
        IF (adjustedvelocity .GE. 0.) THEN
          abs0d = adjustedvelocityd
          abs0 = adjustedvelocity
        ELSE
          abs0d = -adjustedvelocityd
          abs0 = -adjustedvelocity
        END IF
        arg1d = gammaa*r*primitivesd(2)
        arg1 = gammaa*r*primitives(2)
        temp0 = SQRT(arg1)
        IF (arg1 .EQ. 0.0) THEN
          result1d = 0.0_8
        ELSE
          result1d = arg1d/(2.0*temp0)
        END IF
        result1 = temp0
        machnumd = (abs0d-abs0*result1d/result1)/result1
        machnum = abs0/result1
        temp1 = (gammaa-1.0d0)*(machnum*machnum)/2.0d0 + 1.0d0
        temp2 = -(gammaa/(gammaa-1.0d0))
        IF (temp1 .LE. 0.0 .AND. (temp2 .EQ. 0.0 .OR. temp2 .NE. INT(&
&           temp2))) THEN
          tempd = 0.0_8
        ELSE
          tempd = temp2*temp1**(temp2-1)*(gammaa-1.0d0)*2*machnum*&
&           machnumd/2.0d0
        END IF
        primitivesd(1) = pt*tempd
        primitives(1) = pt*temp1**temp2
        primitivesd(3:5) = velunitvector*adjustedvelocityd
        primitives(3:5) = adjustedvelocity*velunitvector
        CALL IDEALGASRHO_D(primitives(2), primitivesd(2), primitives(1)&
&                    , primitivesd(1), r, state(1), stated(1))
        stated(2:4) = state(1)*primitivesd(3:5) + primitives(3:5)*stated&
&         (1)
        state(2:4) = primitives(3:5)*state(1)
        CALL CALPERFECTENERGY_D(primitives(2), primitivesd(2), fluid, e&
&                         , ed)
        arg10d = 2*primitives(3:5)*primitivesd(3:5)
        arg10 = primitives(3:5)**2
        temp2 = e + 0.5d0*SUM(arg10)
        stated(5) = temp2*stated(1) + state(1)*(ed+0.5d0*SUM(arg10d))
        state(5) = state(1)*temp2
        boundaryfluxes = 0.0d0
        boundaryfluxesd = 0.0_8
        CALL CALCULATEFLUXES3D_D(boundaryfluxes, boundaryfluxesd, &
&                          primitives, primitivesd, state, stated)
        slnd%facefluxes(face_idx, :) = boundaryfluxesd
        sln%facefluxes(face_idx, :) = boundaryfluxes
      END IF
    END DO
    DEALLOCATE(currentboundary)
  END SUBROUTINE UPDATEINLETBOUNDARY_D

! end
! 3.boundaryConditions.jl!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! 为一些特殊的边界（如入口，出口，壁面，0梯度边界等）设置特殊的条件即边界条件（例如壁面
!质量通量为0）
! ######################### 边界条件实现 #########################
! 这些边界条件函数的作用是：
!  1. 在求解器中补充内部面通量计算之外的“边界面通量”；
!  2. 在 JST 等数值格式中，内部面通量由通量函数计算，但边界面需要专门强制设置；
!  3. 每个函数实现一种常见边界条件，如超音速入口、出口、壁面、对称等。
! ------------ 亚音速入口边界条件（使用总压/总温）------------
! 输入变量为总压、总温、入口速度方向单位向量（nx, ny, nz）
! 算法来自 FUN3D 求解器：在边界计算静态压强和温度，再重建变量
  SUBROUTINE UPDATEINLETBOUNDARY(mesh, sln, boundarynumber, &
&   inletconditions, fluid)
    IMPLICIT NONE
    TYPE(MESHH), INTENT(IN) :: mesh
    TYPE(SOLUTIONSTATE), INTENT(INOUT) :: sln
    INTEGER(kind=8), INTENT(IN) :: boundarynumber
! [总压Pt, 总温Tt, 速度方向nx, ny]
    REAL(kind=8), INTENT(IN) :: inletconditions(4)
    TYPE(FLUIDD), INTENT(IN) :: fluid
    INTEGER(kind=8) :: face, ownercell
    INTEGER(kind=8), SAVE :: stat=0
    INTEGER(kind=8), ALLOCATABLE :: currentboundary(:)
    REAL(kind=8) :: pt, tt, nx, ny, nz, gammaa, r
    REAL(kind=8) :: adjustedvelocity, machnum, e
    REAL(kind=8) :: primitives(5), state(5), velunitvector(3), &
&   boundaryfluxes(15)
    INTEGER(kind=8) :: ncells, nfaces, nfaceperbdry, face_idx
    INTRINSIC SIZE
    INTRINSIC ABS
    INTRINSIC SQRT
    INTRINSIC SUM
    REAL(kind=8) :: abs0
    REAL(kind=8) :: arg1
    REAL(kind=8) :: result1
    REAL(kind=8), DIMENSION(3) :: arg10
    nfaces = SIZE(mesh%faces, 1)
    ncells = SIZE(sln%cellstate, 1)
    gammaa = fluid%gammaa
    r = fluid%r
    pt = inletconditions(1)
    tt = inletconditions(2)
    nx = inletconditions(3)
    ny = inletconditions(4)
    nz = 0.0d0
    velunitvector = (/nx, ny, nz/)
    nfaceperbdry = SIZE(mesh%boundaryfaces, 2)
    ALLOCATE(currentboundary(nfaceperbdry), stat=stat)
    currentboundary = mesh%boundaryfaces(boundarynumber, :)
    DO face=1,nfaceperbdry
      face_idx = currentboundary(face)
!exit 语句的作用是立即终止当前所在的循环
!nFacePerBdry是所有的边界面,currentBoundary
      IF (face_idx .EQ. 0) THEN
        GOTO 100
      ELSE
        ownercell = mesh%faces(face_idx, 1)
        CALL DOT_PRODUCT_REAL(velunitvector, sln%cellprimitives(&
&                       ownercell, 3:5), adjustedvelocity, 3)
        primitives(2) = tt - (gammaa-1.0d0)/(2.0d0*gammaa*r)*&
&         adjustedvelocity**2
        IF (adjustedvelocity .GE. 0.) THEN
          abs0 = adjustedvelocity
        ELSE
          abs0 = -adjustedvelocity
        END IF
        arg1 = gammaa*r*primitives(2)
        result1 = SQRT(arg1)
        machnum = abs0/result1
        primitives(1) = pt*(1.0d0+(gammaa-1.0d0)/2.0d0*machnum**2)**(-(&
&         gammaa/(gammaa-1.0d0)))
        primitives(3:5) = adjustedvelocity*velunitvector
        CALL IDEALGASRHO(primitives(2), primitives(1), r, state(1))
        state(2:4) = primitives(3:5)*state(1)
        CALL CALPERFECTENERGY(primitives(2), fluid, e)
        arg10 = primitives(3:5)**2
        state(5) = state(1)*(e+0.5d0*SUM(arg10))
        boundaryfluxes = 0.0d0
        CALL CALCULATEFLUXES3D(boundaryfluxes, primitives, state)
        sln%facefluxes(face_idx, :) = boundaryfluxes
      END IF
    END DO
 100 DEALLOCATE(currentboundary)
  END SUBROUTINE UPDATEINLETBOUNDARY

!  Differentiation of updateoutletboundary in forward (tangent) mode (with options i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8
! r4):
!   variations   of useful results: [alloc*(*sln.facefluxes) in solve]
!                *([alloc*sln in solve].facefluxes)
!   with respect to varying inputs: [alloc*(sln.cellfluxes) in decodesolution_3d]
!                [alloc*(sln.cellprimitives) in decodesolution_3d]
!                [alloc*(*sln.facefluxes) in solve] [alloc*(*sln.cellfluxes) in solve]
!                [alloc*(*sln.cellprimitives) in solve] *([alloc*sln in solve].cellfluxes)
!                *([alloc*sln in solve].cellprimitives) *([alloc*sln in solve].facefluxes)
!   Plus diff mem management of: sln.cellstate:in sln.cellfluxes:in
!                sln.cellprimitives:in sln.facefluxes:in
! ------------ 压力出口边界条件 ------------
! 设定出口压力（压强），修正通量中包含压强项的部分
  SUBROUTINE UPDATEOUTLETBOUNDARY_D(mesh, sln, slnd, boundarynumber, &
&   outletpressure, fluid)
    IMPLICIT NONE
    TYPE(MESHH), INTENT(IN) :: mesh
    TYPE(SOLUTIONSTATE), INTENT(INOUT) :: sln
    TYPE(SOLUTIONSTATE), INTENT(INOUT) :: slnd
    INTEGER(kind=8), INTENT(IN) :: boundarynumber
    REAL(kind=8), INTENT(IN) :: outletpressure(:)
    TYPE(FLUIDD), INTENT(IN) :: fluid
    INTEGER(kind=8) :: nfluxes, face, ownercell, flux, d
    INTEGER(kind=8), SAVE :: stat=0
    INTEGER(kind=8), ALLOCATABLE :: currentboundary(:)
    REAL(kind=8) :: outletpressuree, origp
    REAL(kind=8) :: origpd
    INTEGER(kind=8) :: ncells, nfaces, nfaceperbdry, face_idx
    INTRINSIC SIZE
    nfaces = SIZE(mesh%faces, 1)
    ncells = SIZE(sln%cellstate, 1)
    nfluxes = SIZE(sln%cellfluxes, 2)
    nfaceperbdry = SIZE(mesh%boundaryfaces, 2)
    ALLOCATE(currentboundary(nfaceperbdry), stat=stat)
    IF (stat .NE. 0) THEN
      STOP
    ELSE
      currentboundary = mesh%boundaryfaces(boundarynumber, :)
      outletpressuree = outletpressure(1)
      DO face=1,nfaceperbdry
        face_idx = currentboundary(face)
        IF (face_idx .EQ. 0) THEN
          EXIT
        ELSE
          ownercell = mesh%faces(face_idx, 1)
! 复制通量（零梯度假设）
          DO flux=1,nfluxes
            slnd%facefluxes(face_idx, flux) = slnd%cellfluxes(ownercell&
&             , flux)
            sln%facefluxes(face_idx, flux) = sln%cellfluxes(ownercell, &
&             flux)
          END DO
          origpd = slnd%cellprimitives(ownercell, 1)
          origp = sln%cellprimitives(ownercell, 1)
          DO flux=1,3
            slnd%facefluxes(face_idx, 4*flux) = slnd%facefluxes(face_idx&
&             , 4*flux) - origpd
            sln%facefluxes(face_idx, 4*flux) = sln%facefluxes(face_idx, &
&             4*flux) + (outletpressuree-origp)
          END DO
          DO d=1,3
            slnd%facefluxes(face_idx, 12+d) = slnd%facefluxes(face_idx, &
&             12+d) + (outletpressuree-origp)*slnd%cellprimitives(&
&             ownercell, 2+d) - sln%cellprimitives(ownercell, 2+d)*&
&             origpd
            sln%facefluxes(face_idx, 12+d) = sln%facefluxes(face_idx, 12&
&             +d) + sln%cellprimitives(ownercell, 2+d)*(outletpressuree-&
&             origp)
          END DO
        END IF
      END DO
      DEALLOCATE(currentboundary)
    END IF
  END SUBROUTINE UPDATEOUTLETBOUNDARY_D

! ------------ 压力出口边界条件 ------------
! 设定出口压力（压强），修正通量中包含压强项的部分
  SUBROUTINE UPDATEOUTLETBOUNDARY(mesh, sln, boundarynumber, &
&   outletpressure, fluid)
    IMPLICIT NONE
    TYPE(MESHH), INTENT(IN) :: mesh
    TYPE(SOLUTIONSTATE), INTENT(INOUT) :: sln
    INTEGER(kind=8), INTENT(IN) :: boundarynumber
    REAL(kind=8), INTENT(IN) :: outletpressure(:)
    TYPE(FLUIDD), INTENT(IN) :: fluid
    INTEGER(kind=8) :: nfluxes, face, ownercell, flux, d
    INTEGER(kind=8), SAVE :: stat=0
    INTEGER(kind=8), ALLOCATABLE :: currentboundary(:)
    REAL(kind=8) :: outletpressuree, origp
    INTEGER(kind=8) :: ncells, nfaces, nfaceperbdry, face_idx
    INTRINSIC SIZE
    nfaces = SIZE(mesh%faces, 1)
    ncells = SIZE(sln%cellstate, 1)
    nfluxes = SIZE(sln%cellfluxes, 2)
    nfaceperbdry = SIZE(mesh%boundaryfaces, 2)
    ALLOCATE(currentboundary(nfaceperbdry), stat=stat)
    IF (stat .NE. 0) THEN
      STOP
    ELSE
      currentboundary = mesh%boundaryfaces(boundarynumber, :)
      outletpressuree = outletpressure(1)
      DO face=1,nfaceperbdry
        face_idx = currentboundary(face)
        IF (face_idx .EQ. 0) THEN
          GOTO 100
        ELSE
          ownercell = mesh%faces(face_idx, 1)
! 复制通量（零梯度假设）
          DO flux=1,nfluxes
            sln%facefluxes(face_idx, flux) = sln%cellfluxes(ownercell, &
&             flux)
          END DO
          origp = sln%cellprimitives(ownercell, 1)
          DO flux=1,3
            sln%facefluxes(face_idx, 4*flux) = sln%facefluxes(face_idx, &
&             4*flux) + (outletpressuree-origp)
          END DO
          DO d=1,3
            sln%facefluxes(face_idx, 12+d) = sln%facefluxes(face_idx, 12&
&             +d) + sln%cellprimitives(ownercell, 2+d)*(outletpressuree-&
&             origp)
          END DO
        END IF
      END DO
 100  DEALLOCATE(currentboundary)
    END IF
  END SUBROUTINE UPDATEOUTLETBOUNDARY

!  Differentiation of updatewallboundary in forward (tangent) mode (with options i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r
!4):
!   variations   of useful results: [alloc*(*sln.facefluxes) in solve]
!                *([alloc*sln in solve].facefluxes)
!   with respect to varying inputs: [alloc*(sln.cellprimitives) in decodesolution_3d]
!                [alloc*(*sln.facefluxes) in solve] [alloc*(*sln.cellprimitives) in solve]
!                *([alloc*sln in solve].cellprimitives) *([alloc*sln in solve].facefluxes)
!   Plus diff mem management of: sln.cellstate:in sln.cellprimitives:in
!                sln.facefluxes:in
! ------------ 壁面边界条件（不可穿透）------------
! 设置动量通量 = 压力，质量和能量通量 = 0
  SUBROUTINE UPDATEWALLBOUNDARY_D(mesh, sln, slnd, boundarynumber, &
&   dummy1, dummy2)
    IMPLICIT NONE
    TYPE(MESHH), INTENT(IN) :: mesh
    TYPE(SOLUTIONSTATE), INTENT(INOUT) :: sln
    TYPE(SOLUTIONSTATE), INTENT(INOUT) :: slnd
    INTEGER(kind=8), INTENT(IN) :: boundarynumber
    REAL(kind=8), INTENT(IN), OPTIONAL :: dummy1(:)
    TYPE(FLUIDD), INTENT(IN) :: dummy2
    INTEGER(kind=8) :: face
    INTEGER(kind=8), SAVE :: stat=0
    INTEGER(kind=8) :: i
    INTEGER(kind=8), ALLOCATABLE :: currentboundary(:)
    REAL(kind=8) :: facep
    REAL(kind=8) :: facepd
    INTEGER(kind=8) :: ncells, nfaces, nfaceperbdry, face_idx, ownercell
    INTEGER(kind=8) :: realfacecount
    INTRINSIC SIZE
    INTRINSIC MAX
! 注意：假设mesh中存储了每个边界的真实面数（需在OpenFOAMMesh中保存）
! 若未保存，需通过其他方式获取（如传入参数）
! 假设列数即真实面数（不准确）
    realfacecount = SIZE(mesh%boundaryfaces, 2)
! 变量初始化
    nfaces = SIZE(mesh%faces, 1)
    ncells = SIZE(sln%cellstate, 1)
    nfaceperbdry = SIZE(mesh%boundaryfaces, 2)
! 分配currentBoundary并复制数据
    ALLOCATE(currentboundary(nfaceperbdry), stat=stat)
    IF (stat .NE. 0) THEN
      STOP
    ELSE
      currentboundary = mesh%boundaryfaces(boundarynumber, :)
! 计算当前边界的真实面数
      realfacecount = 0
      DO i=1,nfaceperbdry
        IF (currentboundary(i) .EQ. 0) THEN
          EXIT
        ELSE
          realfacecount = realfacecount + 1
        END IF
      END DO
! ====================== 遍历有效面并检查索引 ======================
! 修正：使用realFaceCount作为循环上限，而非遍历到0
      DO face=1,realfacecount
        face_idx = currentboundary(face)
! 检查face_idx有效性（防止随机值越界）
        IF (.NOT.(face_idx .LT. 1 .OR. face_idx .GT. nfaces)) THEN
          IF (mesh%faces(face_idx, 1) .LT. mesh%faces(face_idx, 2)) THEN
            ownercell = mesh%faces(face_idx, 2)
          ELSE
            ownercell = mesh%faces(face_idx, 1)
          END IF
! ====================== 执行边界条件逻辑 ======================
! 压力
          facepd = slnd%cellprimitives(ownercell, 1)
          facep = sln%cellprimitives(ownercell, 1)
! 检查 faceFluxes 赋值是否越界
! x动量
          slnd%facefluxes(face_idx, 4) = facepd
          sln%facefluxes(face_idx, 4) = facep
! y动量
          slnd%facefluxes(face_idx, 8) = facepd
          sln%facefluxes(face_idx, 8) = facep
! z动量
          slnd%facefluxes(face_idx, 12) = facepd
          sln%facefluxes(face_idx, 12) = facep
! 质量通量
          slnd%facefluxes(face_idx, 1:3) = 0.0_8
          sln%facefluxes(face_idx, 1:3) = 0.0d0
! 能量通量
          slnd%facefluxes(face_idx, 13:15) = 0.0_8
          sln%facefluxes(face_idx, 13:15) = 0.0d0
        END IF
      END DO
      DEALLOCATE(currentboundary)
    END IF
  END SUBROUTINE UPDATEWALLBOUNDARY_D

! ------------ 壁面边界条件（不可穿透）------------
! 设置动量通量 = 压力，质量和能量通量 = 0
  SUBROUTINE UPDATEWALLBOUNDARY(mesh, sln, boundarynumber, dummy1, &
&   dummy2)
    IMPLICIT NONE
    TYPE(MESHH), INTENT(IN) :: mesh
    TYPE(SOLUTIONSTATE), INTENT(INOUT) :: sln
    INTEGER(kind=8), INTENT(IN) :: boundarynumber
    REAL(kind=8), INTENT(IN), OPTIONAL :: dummy1(:)
    TYPE(FLUIDD), INTENT(IN) :: dummy2
    INTEGER(kind=8) :: face
    INTEGER(kind=8), SAVE :: stat=0
    INTEGER(kind=8) :: i
    INTEGER(kind=8), ALLOCATABLE :: currentboundary(:)
    REAL(kind=8) :: facep
    INTEGER(kind=8) :: ncells, nfaces, nfaceperbdry, face_idx, ownercell
    INTEGER(kind=8) :: realfacecount
    INTRINSIC SIZE
    INTRINSIC MAX
! 注意：假设mesh中存储了每个边界的真实面数（需在OpenFOAMMesh中保存）
! 若未保存，需通过其他方式获取（如传入参数）
! 假设列数即真实面数（不准确）
    realfacecount = SIZE(mesh%boundaryfaces, 2)
! 变量初始化
    nfaces = SIZE(mesh%faces, 1)
    ncells = SIZE(sln%cellstate, 1)
    nfaceperbdry = SIZE(mesh%boundaryfaces, 2)
! 分配currentBoundary并复制数据
    ALLOCATE(currentboundary(nfaceperbdry), stat=stat)
    IF (stat .NE. 0) THEN
      STOP
    ELSE
      currentboundary = mesh%boundaryfaces(boundarynumber, :)
! 计算当前边界的真实面数
      realfacecount = 0
      DO i=1,nfaceperbdry
        IF (currentboundary(i) .EQ. 0) THEN
          GOTO 100
        ELSE
          realfacecount = realfacecount + 1
        END IF
      END DO
! ====================== 遍历有效面并检查索引 ======================
! 修正：使用realFaceCount作为循环上限，而非遍历到0
 100  DO face=1,realfacecount
        face_idx = currentboundary(face)
! 检查face_idx有效性（防止随机值越界）
        IF (.NOT.(face_idx .LT. 1 .OR. face_idx .GT. nfaces)) THEN
          IF (mesh%faces(face_idx, 1) .LT. mesh%faces(face_idx, 2)) THEN
            ownercell = mesh%faces(face_idx, 2)
          ELSE
            ownercell = mesh%faces(face_idx, 1)
          END IF
! ====================== 执行边界条件逻辑 ======================
! 压力
          facep = sln%cellprimitives(ownercell, 1)
! 检查 faceFluxes 赋值是否越界
! x动量
          sln%facefluxes(face_idx, 4) = facep
! y动量
          sln%facefluxes(face_idx, 8) = facep
! z动量
          sln%facefluxes(face_idx, 12) = facep
! 质量通量
          sln%facefluxes(face_idx, 1:3) = 0.0d0
! 能量通量
          sln%facefluxes(face_idx, 13:15) = 0.0d0
        END IF
      END DO
      DEALLOCATE(currentboundary)
    END IF
  END SUBROUTINE UPDATEWALLBOUNDARY

! ------------ Empty 边界条件（2D 网格边界等）------------
! 什么也不做，占位函数（如周期边界或计算域外）
  SUBROUTINE UPDATEEMPTYBOUNDARY(mesh, sln, boundarynumber, dummy1, &
&   dummy2)
    IMPLICIT NONE
    TYPE(MESHH), INTENT(IN) :: mesh
    TYPE(SOLUTIONSTATE), INTENT(INOUT) :: sln
    INTEGER(kind=8), INTENT(IN) :: boundarynumber
    REAL(kind=8), INTENT(IN), OPTIONAL :: dummy1(:)
    TYPE(FLUIDD), INTENT(IN) :: dummy2
! 空边界什么都不改，直接返回
  END SUBROUTINE UPDATEEMPTYBOUNDARY

!  Differentiation of updateboundaryconditions in forward (tangent) mode (with options i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4
! dr8 r4):
!   variations   of useful results: [alloc*(*sln.facefluxes) in solve]
!                *([alloc*sln in solve].facefluxes)
!   with respect to varying inputs: [alloc*(sln.cellfluxes) in decodesolution_3d]
!                [alloc*(sln.cellprimitives) in decodesolution_3d]
!                [alloc*(*sln.facefluxes) in solve] [alloc*(*sln.cellfluxes) in solve]
!                [alloc*(*sln.cellprimitives) in solve] *([alloc*sln in solve].cellfluxes)
!                *([alloc*sln in solve].cellprimitives) *([alloc*sln in solve].facefluxes)
!   Plus diff mem management of: sln.cellstate:in sln.cellfluxes:in
!                sln.cellprimitives:in sln.facefluxes:in
! 原调用处跟下面变量名一样
! ------------ 应用所有边界条件的统一入口 ------------
  SUBROUTINE UPDATEBOUNDARYCONDITIONS_D(mesh, sln, slnd, &
&   boundaryconditions, nboundaries, fluid)
    IMPLICIT NONE
! 输入输出参数
    TYPE(MESHH), INTENT(IN) :: mesh
    TYPE(SOLUTIONSTATE), INTENT(INOUT) :: sln
    TYPE(SOLUTIONSTATE), INTENT(INOUT) :: slnd
    TYPE(BOUNDARYCONDITION), INTENT(IN) :: boundaryconditions(:)
    INTEGER(kind=8), INTENT(IN) :: nboundaries
    TYPE(FLUIDD), INTENT(IN) :: fluid
! 局部变量
    INTEGER(kind=8) :: boundarynumber
    INTEGER(kind=8) :: ncells, nfaces, nvars, dim1, dim2
! 边界类型枚举定义
    INTEGER(kind=8), PARAMETER :: wallboundary=1
    INTEGER(kind=8), PARAMETER :: emptyboundary=2
    INTEGER(kind=8), PARAMETER :: inletboundary=3
    INTEGER(kind=8), PARAMETER :: outletboundary=4
    INTRINSIC SIZE
    INTRINSIC ALLOCATED
! 获取网格信息
    ncells = SIZE(sln%cellstate, 1)
    nfaces = SIZE(mesh%faces, 1)
    nvars = SIZE(sln%cellstate, 2)
    dim1 = 0
    dim2 = 0
    IF (ALLOCATED(sln%facefluxes)) THEN
      dim1 = SIZE(sln%facefluxes, 1)
      dim2 = SIZE(sln%facefluxes, 2)
    END IF
! 遍历边界
    DO boundarynumber=1,nboundaries
      SELECT CASE (boundaryconditions(boundarynumber)%type)
      CASE (wallboundary)
        CALL UPDATEWALLBOUNDARY_D(mesh, sln, slnd, boundarynumber, &
&                           boundaryconditions(boundarynumber)%params, &
&                           fluid)
      CASE (emptyboundary)
        CALL UPDATEEMPTYBOUNDARY(mesh, sln, boundarynumber, &
&                          boundaryconditions(boundarynumber)%params, &
&                          fluid)
      CASE (inletboundary)
        CALL UPDATEINLETBOUNDARY_D(mesh, sln, slnd, boundarynumber, &
&                            boundaryconditions(boundarynumber)%params, &
&                            fluid)
      CASE (outletboundary)
        CALL UPDATEOUTLETBOUNDARY_D(mesh, sln, slnd, boundarynumber, &
&                             boundaryconditions(boundarynumber)%params&
&                             , fluid)
      CASE DEFAULT
        GOTO 100
      END SELECT
    END DO
    GOTO 110
 100 STOP
 110 CONTINUE
  END SUBROUTINE UPDATEBOUNDARYCONDITIONS_D

! 原调用处跟下面变量名一样
! ------------ 应用所有边界条件的统一入口 ------------
  SUBROUTINE UPDATEBOUNDARYCONDITIONS(mesh, sln, boundaryconditions, &
&   nboundaries, fluid)
    IMPLICIT NONE
! 输入输出参数
    TYPE(MESHH), INTENT(IN) :: mesh
    TYPE(SOLUTIONSTATE), INTENT(INOUT) :: sln
    TYPE(BOUNDARYCONDITION), INTENT(IN) :: boundaryconditions(:)
    INTEGER(kind=8), INTENT(IN) :: nboundaries
    TYPE(FLUIDD), INTENT(IN) :: fluid
! 局部变量
    INTEGER(kind=8) :: boundarynumber
    INTEGER(kind=8) :: ncells, nfaces, nvars, dim1, dim2
! 边界类型枚举定义
    INTEGER(kind=8), PARAMETER :: wallboundary=1
    INTEGER(kind=8), PARAMETER :: emptyboundary=2
    INTEGER(kind=8), PARAMETER :: inletboundary=3
    INTEGER(kind=8), PARAMETER :: outletboundary=4
    INTRINSIC SIZE
    INTRINSIC ALLOCATED
! 获取网格信息
    ncells = SIZE(sln%cellstate, 1)
    nfaces = SIZE(mesh%faces, 1)
    nvars = SIZE(sln%cellstate, 2)
    dim1 = 0
    dim2 = 0
    IF (ALLOCATED(sln%facefluxes)) THEN
      dim1 = SIZE(sln%facefluxes, 1)
      dim2 = SIZE(sln%facefluxes, 2)
    END IF
! 遍历边界
    DO boundarynumber=1,nboundaries
      SELECT CASE (boundaryconditions(boundarynumber)%type)
      CASE (wallboundary)
        CALL UPDATEWALLBOUNDARY(mesh, sln, boundarynumber, &
&                         boundaryconditions(boundarynumber)%params, &
&                         fluid)
      CASE (emptyboundary)
        CALL UPDATEEMPTYBOUNDARY(mesh, sln, boundarynumber, &
&                          boundaryconditions(boundarynumber)%params, &
&                          fluid)
      CASE (inletboundary)
        CALL UPDATEINLETBOUNDARY(mesh, sln, boundarynumber, &
&                          boundaryconditions(boundarynumber)%params, &
&                          fluid)
      CASE (outletboundary)
        CALL UPDATEOUTLETBOUNDARY(mesh, sln, boundarynumber, &
&                           boundaryconditions(boundarynumber)%params, &
&                           fluid)
      CASE DEFAULT
        STOP
      END SELECT
    END DO
  END SUBROUTINE UPDATEBOUNDARYCONDITIONS

!  Differentiation of idealgasrho in forward (tangent) mode (with options i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4):
!   variations   of useful results: rho_val
!   with respect to varying inputs: p t
! 4.constitutiveRelations.jl!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! ######################### Internal/Private functions #######################
! 内部函数：理想气体状态方程和能量计算
! 根据理想气体状态方程计算密度 rho = P / (R*T)
  SUBROUTINE IDEALGASRHO_D(t, td, p, pd, r, rho_val, rho_vald)
    IMPLICIT NONE
    REAL(kind=8), INTENT(IN) :: t, p, r
    REAL(kind=8), INTENT(IN) :: td, pd
    REAL(kind=8), INTENT(OUT) :: rho_val
    REAL(kind=8), INTENT(OUT) :: rho_vald
    REAL(kind=8) :: temp
    temp = p/(r*t)
    rho_vald = (pd-temp*r*td)/(r*t)
    rho_val = temp
  END SUBROUTINE IDEALGASRHO_D

! 4.constitutiveRelations.jl!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! ######################### Internal/Private functions #######################
! 内部函数：理想气体状态方程和能量计算
! 根据理想气体状态方程计算密度 rho = P / (R*T)
  SUBROUTINE IDEALGASRHO(t, p, r, rho_val)
    IMPLICIT NONE
    REAL(kind=8), INTENT(IN) :: t, p, r
    REAL(kind=8), INTENT(OUT) :: rho_val
    rho_val = p/(r*t)
  END SUBROUTINE IDEALGASRHO

!  Differentiation of idealgasp in forward (tangent) mode (with options i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4):
!   variations   of useful results: p
!   with respect to varying inputs: t rho
! 根据理想气体状态方程计算压强 P = rho * R * T
  SUBROUTINE IDEALGASP_D(rho, rhod, t, td, r, p, pd)
    IMPLICIT NONE
    REAL(kind=8), INTENT(IN) :: rho, t
    REAL(kind=8), INTENT(IN) :: rhod, td
    REAL(kind=8), INTENT(IN) :: r
    REAL(kind=8), INTENT(OUT) :: p
    REAL(kind=8), INTENT(OUT) :: pd
! PV = mRT 推导得到 P = rho * R * T
    pd = r*(t*rhod+rho*td)
    p = rho*r*t
  END SUBROUTINE IDEALGASP_D

! 根据理想气体状态方程计算压强 P = rho * R * T
  SUBROUTINE IDEALGASP(rho, t, r, p)
    IMPLICIT NONE
    REAL(kind=8), INTENT(IN) :: rho, t
    REAL(kind=8), INTENT(IN) :: r
    REAL(kind=8), INTENT(OUT) :: p
! PV = mRT 推导得到 P = rho * R * T
    p = rho*r*t
  END SUBROUTINE IDEALGASP

!  Differentiation of calperfectenergy in forward (tangent) mode (with options i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4)
!:
!   variations   of useful results: e_val
!   with respect to varying inputs: t
! 计算理想气体的比内能 e = T * (Cp - R)
  SUBROUTINE CALPERFECTENERGY_D(t, td, fluid, e_val, e_vald)
    IMPLICIT NONE
    REAL(kind=8), INTENT(IN) :: t
    REAL(kind=8), INTENT(IN) :: td
    TYPE(FLUIDD), INTENT(IN) :: fluid
! 输出参数：原返回值
    REAL(kind=8), INTENT(OUT) :: e_val
    REAL(kind=8), INTENT(OUT) :: e_vald
    e_vald = (fluid%cp-fluid%r)*td
    e_val = t*(fluid%cp-fluid%r)
  END SUBROUTINE CALPERFECTENERGY_D

! 计算理想气体的比内能 e = T * (Cp - R)
  SUBROUTINE CALPERFECTENERGY(t, fluid, e_val)
    IMPLICIT NONE
    REAL(kind=8), INTENT(IN) :: t
    TYPE(FLUIDD), INTENT(IN) :: fluid
! 输出参数：原返回值
    REAL(kind=8), INTENT(OUT) :: e_val
    e_val = t*(fluid%cp-fluid%r)
  END SUBROUTINE CALPERFECTENERGY

!  Differentiation of calperfectt in forward (tangent) mode (with options i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4):
!   variations   of useful results: t
!   with respect to varying inputs: e
! 反过来，根据比内能 e 计算温度 T = e / (Cp - R)
  SUBROUTINE CALPERFECTT_D(e, ed, fluid, t, td)
    IMPLICIT NONE
    REAL(kind=8), INTENT(IN) :: e
    REAL(kind=8), INTENT(IN) :: ed
    TYPE(FLUIDD), INTENT(IN) :: fluid
    REAL(kind=8), INTENT(OUT) :: t
    REAL(kind=8), INTENT(OUT) :: td
    td = ed/(fluid%cp-fluid%r)
    t = e/(fluid%cp-fluid%r)
  END SUBROUTINE CALPERFECTT_D

! 反过来，根据比内能 e 计算温度 T = e / (Cp - R)
  SUBROUTINE CALPERFECTT(e, fluid, t)
    IMPLICIT NONE
    REAL(kind=8), INTENT(IN) :: e
    TYPE(FLUIDD), INTENT(IN) :: fluid
    REAL(kind=8), INTENT(OUT) :: t
    t = e/(fluid%cp-fluid%r)
  END SUBROUTINE CALPERFECTT

!  Differentiation of decodeprimitives3d in forward (tangent) mode (with options i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r
!4):
!   variations   of useful results: primitives
!   with respect to varying inputs: primitives cellstate
! ######################### Public functions (called by FvCFD.jl) #######################
! 公共函数：供外部模块（如 FvCFD.jl）调用
! =
!     从守恒变量 cellState 解码出原始变量 primitives（压强、温度、速度）
!     输入：
!         cellState: [rho, rho*Ux, rho*Uy, rho*Uz, rho*eV2] （守恒变量）
!         fluid: Fluid 类型，包含 Cp 和 R
!     输出：
!         primitives: [P, T, Ux, Uy, Uz]
! =#
  SUBROUTINE DECODEPRIMITIVES3D_D(primitives, primitivesd, cellstate, &
&   cellstated, fluid)
    IMPLICIT NONE
! 输入输出：原始变量（将被更新）
    REAL(kind=8), INTENT(INOUT) :: primitives(5)
    REAL(kind=8), INTENT(INOUT) :: primitivesd(5)
! 输入：守恒变量
    REAL(kind=8), INTENT(IN) :: cellstate(5)
    REAL(kind=8), INTENT(IN) :: cellstated(5)
    TYPE(FLUIDD), INTENT(IN) :: fluid
    REAL(kind=8) :: e, vel_mag, temp_t
    REAL(kind=8) :: ed, vel_magd, temp_td
    INTRINSIC SQRT
    REAL(kind=8) :: arg1
    REAL(kind=8) :: arg1d
    REAL(kind=8) :: temp
! 速度分量 Ux, Uy, Uz
! Ux
    temp = cellstate(2)/cellstate(1)
    primitivesd(3) = (cellstated(2)-temp*cellstated(1))/cellstate(1)
    primitives(3) = temp
! Uy
    temp = cellstate(3)/cellstate(1)
    primitivesd(4) = (cellstated(3)-temp*cellstated(1))/cellstate(1)
    primitives(4) = temp
! Uz
    temp = cellstate(4)/cellstate(1)
    primitivesd(5) = (cellstated(4)-temp*cellstated(1))/cellstate(1)
    primitives(5) = temp
! 动能与比内能
    arg1d = 2*primitives(3)*primitivesd(3) + 2*primitives(4)*primitivesd&
&     (4) + 2*primitives(5)*primitivesd(5)
    arg1 = primitives(3)**2 + primitives(4)**2 + primitives(5)**2
    temp = SQRT(arg1)
    IF (arg1 .EQ. 0.0) THEN
      vel_magd = 0.0_8
    ELSE
      vel_magd = arg1d/(2.0*temp)
    END IF
    vel_mag = temp
    temp = cellstate(5)/cellstate(1)
    ed = (cellstated(5)-temp*cellstated(1))/cellstate(1) - 0.5*2*vel_mag&
&     *vel_magd
    e = temp - 0.5*(vel_mag*vel_mag)
! 温度 T
    CALL CALPERFECTT_D(e, ed, fluid, primitives(2), primitivesd(2))
! 关键修改：用临时变量 temp_T 存储 primitives(2) 的值
    temp_td = primitivesd(2)
    temp_t = primitives(2)
! 压强 P = rho * R * T
    CALL IDEALGASP_D(cellstate(1), cellstated(1), temp_t, temp_td, fluid&
&              %r, primitives(1), primitivesd(1))
  END SUBROUTINE DECODEPRIMITIVES3D_D

! ######################### Public functions (called by FvCFD.jl) #######################
! 公共函数：供外部模块（如 FvCFD.jl）调用
! =
!     从守恒变量 cellState 解码出原始变量 primitives（压强、温度、速度）
!     输入：
!         cellState: [rho, rho*Ux, rho*Uy, rho*Uz, rho*eV2] （守恒变量）
!         fluid: Fluid 类型，包含 Cp 和 R
!     输出：
!         primitives: [P, T, Ux, Uy, Uz]
! =#
  SUBROUTINE DECODEPRIMITIVES3D(primitives, cellstate, fluid)
    IMPLICIT NONE
! 输入输出：原始变量（将被更新）
    REAL(kind=8), INTENT(INOUT) :: primitives(5)
! 输入：守恒变量
    REAL(kind=8), INTENT(IN) :: cellstate(5)
    TYPE(FLUIDD), INTENT(IN) :: fluid
    REAL(kind=8) :: e, vel_mag, temp_t
    INTRINSIC SQRT
    REAL(kind=8) :: arg1
! 速度分量 Ux, Uy, Uz
! Ux
    primitives(3) = cellstate(2)/cellstate(1)
! Uy
    primitives(4) = cellstate(3)/cellstate(1)
! Uz
    primitives(5) = cellstate(4)/cellstate(1)
! 动能与比内能
    arg1 = primitives(3)**2 + primitives(4)**2 + primitives(5)**2
    vel_mag = SQRT(arg1)
    e = cellstate(5)/cellstate(1) - 0.5*vel_mag**2
! 温度 T
    CALL CALPERFECTT(e, fluid, primitives(2))
! 关键修改：用临时变量 temp_T 存储 primitives(2) 的值
    temp_t = primitives(2)
! 压强 P = rho * R * T
    CALL IDEALGASP(cellstate(1), temp_t, fluid%r, primitives(1))
  END SUBROUTINE DECODEPRIMITIVES3D

! =
!     从原始变量 primitives 计算守恒变量 cellState
!     输入：
!         cellPrimitives: [P, T, Ux, Uy, Uz]，每行代表一个 cell
!         fluid: 流体属性，包含 Cp 和 R
!     输出：
!         cellState: [rho, rho*Ux, rho*Uy, rho*Uz, rho*eV2]
! =#
  SUBROUTINE ENCODEPRIMITIVES3D(cellprimitives, fluid, &
&   encodeprimitives3dd)
    IMPLICIT NONE
    REAL(kind=8), INTENT(IN) :: cellprimitives(:, :)
    TYPE(FLUIDD), INTENT(IN) :: fluid
    REAL(kind=8), ALLOCATABLE, INTENT(INOUT) :: encodeprimitives3dd(:, :&
&   )
    INTEGER(kind=8) :: ncells, c
    REAL(kind=8) :: e, mag_vel
    INTRINSIC SIZE
    ncells = SIZE(cellprimitives, 1)
! 初始化守恒变量矩阵
!		allocate(encodePrimitives3DD(nCells, 5))
    DO c=1,ncells
! 根据 T 和 P 计算密度
      CALL IDEALGASRHO(cellprimitives(c, 2), cellprimitives(c, 1), fluid&
&                %r, encodeprimitives3dd(c, 1))
! 计算动量项 rho * U
      encodeprimitives3dd(c, 2:4) = cellprimitives(c, 3:5)*&
&       encodeprimitives3dd(c, 1)
! 计算内能密度 e = T*(Cp - R)
      CALL CALPERFECTENERGY(cellprimitives(c, 2), fluid, e)
! 总能量 = rho * (e + 动能)
! 计算速度模长
      CALL MAG(cellprimitives(c, 3:5), mag_vel)
! 用临时变量 mag_vel 替代原 mag(...)
      encodeprimitives3dd(c, 5) = encodeprimitives3dd(c, 1)*(e+mag_vel**&
&       2/2.0d0)
    END DO
  END SUBROUTINE ENCODEPRIMITIVES3D

!  Differentiation of calculatefluxes3d in forward (tangent) mode (with options i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4
!):
!   variations   of useful results: out_fluxes
!   with respect to varying inputs: prim out_fluxes state
! =
!     根据 cell 的状态和原始变量，计算通量 fluxes（用于求解方程的显式格式）
!     输入：
!         fluxes: 输出通量向量（长度为15）
!         prim: 原始变量 [P, T, Ux, Uy, Uz]
!         state: 守恒变量 [rho, rho*Ux, rho*Uy, rho*Uz, rho*eV2]
!     输出：
!         无（直接修改 fluxes 向量）
! 
!     通量结构如下：
!         1-3: 质量通量 (rho*U)
!         4-12: 动量通量张量（3x3）
!         13-15: 能量通量 (rho*eV2*U + P*U)
! =#
! 原始变量primitives = Vector{Float64}(undef, 5)    5：[P, T, Ux, Uy, Uz]
! 守恒变量state = Vector{Float64}(undef, 5)   5:[ρ, ρUx, ρUy, ρUz, ρe]
! 函数名以 ! 结尾，它直接修改传入的 fluxes 数组，而不是返回一个新的数组。且在调用这个函数\E6\97
!\B6可不初始化fluex的值,且在调用这个函数时，可以直接使用输出的结果(无return)
  SUBROUTINE CALCULATEFLUXES3D_D(out_fluxes, out_fluxesd, prim, primd, &
&   state, stated)
    IMPLICIT NONE
! 输出：计算后的通量
    REAL(kind=8), INTENT(OUT) :: out_fluxes(15)
    REAL(kind=8), INTENT(OUT) :: out_fluxesd(15)
! 原始变量
    REAL(kind=8), INTENT(IN) :: prim(5)
    REAL(kind=8), INTENT(IN) :: primd(5)
! 守恒变量
    REAL(kind=8), INTENT(IN) :: state(5)
    REAL(kind=8), INTENT(IN) :: stated(5)
! 质量通量
! rho*Ux
    out_fluxesd(1) = stated(2)
    out_fluxes(1) = state(2)
! rho*Uy
    out_fluxesd(2) = stated(3)
    out_fluxes(2) = state(3)
! rho*Uz
    out_fluxesd(3) = stated(4)
    out_fluxes(3) = state(4)
! 动量通量
! x动量x通量
    out_fluxesd(4) = prim(3)*stated(2) + state(2)*primd(3) + primd(1)
    out_fluxes(4) = state(2)*prim(3) + prim(1)
! y动量x通量
    out_fluxesd(7) = prim(4)*stated(2) + state(2)*primd(4)
    out_fluxes(7) = state(2)*prim(4)
! z动量x通量
    out_fluxesd(10) = prim(5)*stated(2) + state(2)*primd(5)
    out_fluxes(10) = state(2)*prim(5)
! x动量y通量（对称）
    out_fluxesd(5) = out_fluxesd(7)
    out_fluxes(5) = out_fluxes(7)
! y动量y通量
    out_fluxesd(8) = prim(4)*stated(3) + state(3)*primd(4) + primd(1)
    out_fluxes(8) = state(3)*prim(4) + prim(1)
! z动量y通量
    out_fluxesd(11) = prim(5)*stated(3) + state(3)*primd(5)
    out_fluxes(11) = state(3)*prim(5)
! x动量z通量（对称）
    out_fluxesd(6) = out_fluxesd(10)
    out_fluxes(6) = out_fluxes(10)
! y动量z通量（对称）
    out_fluxesd(9) = out_fluxesd(11)
    out_fluxes(9) = out_fluxes(11)
! z动量z通量
    out_fluxesd(12) = prim(5)*stated(4) + state(4)*primd(5) + primd(1)
    out_fluxes(12) = state(4)*prim(5) + prim(1)
! 能量通量
    out_fluxesd(13) = (state(5)+prim(1))*primd(3) + prim(3)*stated(5) + &
&     prim(3)*primd(1)
    out_fluxes(13) = prim(3)*state(5) + prim(1)*prim(3)
    out_fluxesd(14) = (state(5)+prim(1))*primd(4) + prim(4)*stated(5) + &
&     prim(4)*primd(1)
    out_fluxes(14) = prim(4)*state(5) + prim(1)*prim(4)
    out_fluxesd(15) = (state(5)+prim(1))*primd(5) + prim(5)*stated(5) + &
&     prim(5)*primd(1)
    out_fluxes(15) = prim(5)*state(5) + prim(1)*prim(5)
  END SUBROUTINE CALCULATEFLUXES3D_D

! =
!     根据 cell 的状态和原始变量，计算通量 fluxes（用于求解方程的显式格式）
!     输入：
!         fluxes: 输出通量向量（长度为15）
!         prim: 原始变量 [P, T, Ux, Uy, Uz]
!         state: 守恒变量 [rho, rho*Ux, rho*Uy, rho*Uz, rho*eV2]
!     输出：
!         无（直接修改 fluxes 向量）
! 
!     通量结构如下：
!         1-3: 质量通量 (rho*U)
!         4-12: 动量通量张量（3x3）
!         13-15: 能量通量 (rho*eV2*U + P*U)
! =#
! 原始变量primitives = Vector{Float64}(undef, 5)    5：[P, T, Ux, Uy, Uz]
! 守恒变量state = Vector{Float64}(undef, 5)   5:[ρ, ρUx, ρUy, ρUz, ρe]
! 函数名以 ! 结尾，它直接修改传入的 fluxes 数组，而不是返回一个新的数组。且在调用这个函数\E6\97
!\B6可不初始化fluex的值,且在调用这个函数时，可以直接使用输出的结果(无return)
  SUBROUTINE CALCULATEFLUXES3D(out_fluxes, prim, state)
    IMPLICIT NONE
! 输出：计算后的通量
    REAL(kind=8), INTENT(OUT) :: out_fluxes(15)
! 原始变量
    REAL(kind=8), INTENT(IN) :: prim(5)
! 守恒变量
    REAL(kind=8), INTENT(IN) :: state(5)
! 质量通量
! rho*Ux
    out_fluxes(1) = state(2)
! rho*Uy
    out_fluxes(2) = state(3)
! rho*Uz
    out_fluxes(3) = state(4)
! 动量通量
! x动量x通量
    out_fluxes(4) = state(2)*prim(3) + prim(1)
! y动量x通量
    out_fluxes(7) = state(2)*prim(4)
! z动量x通量
    out_fluxes(10) = state(2)*prim(5)
! x动量y通量（对称）
    out_fluxes(5) = out_fluxes(7)
! y动量y通量
    out_fluxes(8) = state(3)*prim(4) + prim(1)
! z动量y通量
    out_fluxes(11) = state(3)*prim(5)
! x动量z通量（对称）
    out_fluxes(6) = out_fluxes(10)
! y动量z通量（对称）
    out_fluxes(9) = out_fluxes(11)
! z动量z通量
    out_fluxes(12) = state(4)*prim(5) + prim(1)
! 能量通量
    out_fluxes(13) = prim(3)*state(5) + prim(1)*prim(3)
    out_fluxes(14) = prim(4)*state(5) + prim(1)*prim(4)
    out_fluxes(15) = prim(5)*state(5) + prim(1)*prim(5)
  END SUBROUTINE CALCULATEFLUXES3D

!  Differentiation of unstructured_jsteps in forward (tangent) mode (with options i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 
!r4):
!   variations   of useful results: [alloc*facevals in maxinterp]
!                [alloc*grad in greengaussgrad] [alloc*facevals in greengaussgrad]
!                [alloc*eps in unstructured_jsteps] [alloc*eps4 in unstructured_jsteps]
!                [alloc*eps2 in unstructured_jsteps] [alloc*rj in unstructured_jsteps]
!                [alloc*sj in unstructured_jsteps] [alloc*gradp in unstructured_jsteps]
!                [alloc*p_matrix in unstructured_jsteps] [alloc*p in unstructured_jsteps]
!   with respect to varying inputs: [alloc*(sln.cellprimitives) in decodesolution_3d]
!                [alloc*facevals in maxinterp] [alloc*grad in greengaussgrad]
!                [alloc*facevals in greengaussgrad] [alloc*(mesh.ccenters) in openfoammesh]
!                [alloc*(mesh.cvols) in openfoammesh] [alloc*(mesh.fcenters) in openfoammesh]
!                [alloc*(mesh.favecs) in openfoammesh] [alloc*eps in unstructured_jsteps]
!                [alloc*eps4 in unstructured_jsteps] [alloc*eps2 in unstructured_jsteps]
!                [alloc*rj in unstructured_jsteps] [alloc*sj in unstructured_jsteps]
!                [alloc*gradp in unstructured_jsteps] [alloc*p_matrix in unstructured_jsteps]
!                [alloc*p in unstructured_jsteps] [alloc*(*sln.cellprimitives) in solve]
!                *([alloc*sln in solve].cellprimitives)
!   Plus diff mem management of: eps:out mesh.cvols:in mesh.ccenters:in
!                mesh.favecs:in mesh.fcenters:in sln.cellprimitives:in
! 5.JST.jl!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! 4-55(函数unstructured_JSTEps)计算 JST 方法中的二阶（eps2）和四阶（eps4）人工扩散系数
! 56-108(函数unstructured_JSTFlux)执行 JST 方法计算通量残差
  SUBROUTINE UNSTRUCTURED_JSTEPS_D(mesh, meshd, sln, slnd, fluid, eps, &
&   epsd)
    IMPLICIT NONE
! 输入参数
    TYPE(MESHH), INTENT(IN) :: mesh
    TYPE(MESHH_DIFF), INTENT(IN) :: meshd
    TYPE(SOLUTIONSTATE), INTENT(IN) :: sln
    TYPE(SOLUTIONSTATE), INTENT(IN) :: slnd
    TYPE(FLUIDD), INTENT(IN) :: fluid
! 输出结果：二维数组，第1列=eps2，第2列=eps4
    REAL(kind=8), ALLOCATABLE, INTENT(OUT) :: eps(:, :)
    REAL(kind=8), ALLOCATABLE, INTENT(OUT) :: epsd(:, :)
! 局部变量
    INTEGER(kind=8) :: ncells, nfaces, nboundaries, nbdryfaces, meshinfo&
&   (4)
    REAL(kind=8), ALLOCATABLE :: p(:), gradp(:, :), p_matrix(:, :), &
&   temp_grad(:, :, :)
    REAL(kind=8), ALLOCATABLE :: pd(:), gradpd(:, :), p_matrixd(:, :), &
&   temp_gradd(:, :, :)
    REAL(kind=8), ALLOCATABLE :: sj(:), sjcount(:), rj(:), rjsjf(:, :)
    REAL(kind=8), ALLOCATABLE :: sjd(:), rjd(:), rjsjfd(:, :)
    REAL(kind=8), ALLOCATABLE :: eps2(:), eps4(:)
    REAL(kind=8), ALLOCATABLE :: eps2d(:), eps4d(:)
    INTEGER(kind=8) :: f, ownercell, neighbourcell, c, nvars
    REAL(kind=8) :: d(3), op, np, farownerp, farneighbourp, epsilonn, &
&   dot_ownercell, dot_neighbourcell
    REAL(kind=8) :: dd(3), opd, npd, farownerpd, farneighbourpd, &
&   dot_ownercelld, dot_neighbourcelld
! JST系数默认值
    REAL(kind=8) :: k2_val, k4_val, c4_val, vec_mag
    REAL(kind=8) :: vec_magd
    INTRINSIC SIZE
    INTRINSIC ABS
    INTRINSIC MAX
    INTRINSIC SQRT
    INTRINSIC REAL
    REAL(kind=8) :: x1
    REAL(kind=8) :: x1d
    REAL(kind=8) :: x2
    REAL(kind=8) :: x2d
    REAL(kind=8) :: abs0
    REAL(kind=8) :: abs0d
    REAL(kind=8) :: abs1
    REAL(kind=8) :: abs1d
    DOUBLE PRECISION :: max1
    DOUBLE PRECISION :: max1d
    REAL(kind=8) :: max2
    REAL(kind=8) :: max2d
    REAL(kind=8) :: max3
    REAL(kind=8) :: max3d
    REAL(kind=8) :: abs2
    REAL(kind=8) :: abs2d
    REAL(kind=8) :: abs3
    REAL(kind=8) :: abs3d
    REAL(kind=8) :: abs4
    REAL(kind=8) :: abs4d
    REAL(kind=8) :: abs5
    REAL(kind=8) :: abs5d
    DOUBLE PRECISION :: result1
    DOUBLE PRECISION :: result1d
    REAL(kind=8) :: temp
    DOUBLE PRECISION :: temp0
! 1. 设置JST系数默认值（可选参数未输入时使用）
! 默认k2
    k2_val = 0.5d0
! 默认k4
    k4_val = 1.0d0/32.0d0
! 默认c4
    c4_val = 1.0d0
! 2. 获取网格信息（单元数、面数等）
    CALL UNSTRUCTUREDMESHINFO(mesh, meshinfo)
    ncells = meshinfo(1)
    nfaces = meshinfo(2)
    nboundaries = meshinfo(3)
    nbdryfaces = meshinfo(4)
! 3. 提取压力并计算压力梯度（用于激波检测）
    ALLOCATE(pd(ncells), source=0.0d0)
    pd = 0.0_8
    ALLOCATE(p(ncells), source=0.0d0)
! 压力（原始变量第1列）
    pd = slnd%cellprimitives(:, 1)
    p = sln%cellprimitives(:, 1)
! 转换为二维矩阵（适配greenGaussGrad函数输入要求）
    ALLOCATE(p_matrixd(ncells, 1), source=0.0d0)
    p_matrixd = 0.0_8
    ALLOCATE(p_matrix(ncells, 1), source=0.0d0)
    p_matrixd(:, 1) = pd
    p_matrix(:, 1) = p
!    ALLOCATE(temp_gradd(ncells, 1, 3))
!    ALLOCATE(temp_grad(ncells, 1, 3))
	allocate(temp_gradd(nCells, 1, 3), source=0.0d0) 
	allocate(temp_grad(nCells, 1, 3), source=0.0d0) 
! 临时存储梯度（单元数×1变量×3方向×）
    nvars = SIZE(p_matrix, 2)
! 计算压力梯度
    CALL GREENGAUSSGRAD_D(mesh, meshd, p_matrix, p_matrixd, .false., &
&                   temp_grad, temp_gradd)
    ALLOCATE(gradpd(ncells, 3), source=0.0d0)
    gradpd = 0.0_8
    ALLOCATE(gradp(ncells, 3), source=0.0d0)
    gradPd = temp_gradd(:, :, 1)
    gradP = temp_grad(:, :, 1)
! 明确提取x方向梯度（第2维第1个元素）
 !   gradpd(:, 1) = temp_gradd(:, 1, 1)
!    gradp(:, 1) = temp_grad(:, 1, 1)
! 明确提取y方向梯度（第2维第2个元素）
!    gradpd(:, 2) = temp_gradd(:, 1, 2)
!    gradp(:, 2) = temp_grad(:, 1, 2)
! 明确提取z方向梯度（第2维第3个元素）  ! 提取压力梯度（第1个变量的梯度）
!    gradpd(:, 3) = temp_gradd(:, 1, 3)
!    gradp(:, 3) = temp_grad(:, 1, 3)
! 4. 计算激波传感器（shock sensor）sj
    ALLOCATE(sjd(ncells), source=0.0d0)
    sjd = 0.0_8
    ALLOCATE(sj(ncells), source=0.0d0)
    ALLOCATE(sjcount(ncells), source=0.0d0)
! 激波传感器值
    sjd = 0.0_8
    sj = 0.0d0
! 计数：每个单元被多少面访问
    sjcount = 0.0d0
! 防止除零的小量
    epsilonn = 1.0d-10
! 只处理内部面（排除边界面）
    DO f=1,nfaces-nbdryfaces
      ownercell = mesh%faces(f, 1)
      neighbourcell = mesh%faces(f, 2)
! 单元质心向量差（neighbour - owner）
      dd = meshd%ccenters(neighbourcell, :) - meshd%ccenters(ownercell, &
&       :)
      d = mesh%ccenters(neighbourcell, :) - mesh%ccenters(ownercell, :)
! 提取压力值
      opd = pd(ownercell)
      op = p(ownercell)
      npd = pd(neighbourcell)
      np = p(neighbourcell)
      CALL DOT_PRODUCT_REAL_D(d, dd, gradp(ownercell, :), gradpd(&
&                       ownercell, :), dot_ownercell, dot_ownercelld, 3)
      CALL DOT_PRODUCT_REAL_D(d, dd, gradp(neighbourcell, :), gradpd(&
&                       neighbourcell, :), dot_neighbourcell, &
&                       dot_neighbourcelld, 3)
! 构造远端虚拟单元压力（基于梯度外推）
      farownerpd = npd - 2.0d0*dot_ownercelld
      farownerp = np - 2.0d0*dot_ownercell
      farneighbourpd = opd + 2.0d0*dot_neighbourcelld
      farneighbourp = op + 2.0d0*dot_neighbourcell
      IF (np - 2.0d0*op + farownerp .GE. 0.) THEN
        abs0d = npd - 2.0d0*opd + farownerpd
        abs0 = np - 2.0d0*op + farownerp
      ELSE
        abs0d = 2.0d0*opd - npd - farownerpd
        abs0 = -(np-2.0d0*op+farownerp)
      END IF
      IF (np - op .GE. 0.) THEN
        abs2d = npd - opd
        abs2 = np - op
      ELSE
        abs2d = opd - npd
        abs2 = -(np-op)
      END IF
      IF (op - farownerp .GE. 0.) THEN
        abs4d = opd - farownerpd
        abs4 = op - farownerp
      ELSE
        abs4d = farownerpd - opd
        abs4 = -(op-farownerp)
      END IF
      x1d = abs2d + abs4d
      x1 = abs2 + abs4
      IF (x1 .LT. epsilonn) THEN
        max2 = epsilonn
        max2d = x1d
      ELSE
        max2d = x1d
        max2 = x1
      END IF
! 计算激波传感器值（累加）
      temp = abs0/max2
      sjd(ownercell) = sjd(ownercell) + 2*temp*(abs0d-temp*max2d)/max2
      sj(ownercell) = sj(ownercell) + temp*temp
      sjcount(ownercell) = sjcount(ownercell) + 1
      IF (op - 2.0d0*np + farneighbourp .GE. 0.) THEN
        abs1d = opd - 2.0d0*npd + farneighbourpd
        abs1 = op - 2.0d0*np + farneighbourp
      ELSE
        abs1d = 2.0d0*npd - opd - farneighbourpd
        abs1 = -(op-2.0d0*np+farneighbourp)
      END IF
      IF (farneighbourp - np .GE. 0.) THEN
        abs3d = farneighbourpd - npd
        abs3 = farneighbourp - np
      ELSE
        abs3d = npd - farneighbourpd
        abs3 = -(farneighbourp-np)
      END IF
      IF (np - op .GE. 0.) THEN
        abs5d = npd - opd
        abs5 = np - op
      ELSE
        abs5d = opd - npd
        abs5 = -(np-op)
      END IF
      x2d = abs3d + abs5d
      x2 = abs3 + abs5
      IF (x2 .LT. epsilonn) THEN
        max3 = epsilonn
        max3d = x2d
      ELSE
        max3d = x2d
        max3 = x2
      END IF
      temp = abs1/max3
      sjd(neighbourcell) = sjd(neighbourcell) + 2*temp*(abs1d-temp*max3d&
&       )/max3
      sj(neighbourcell) = sj(neighbourcell) + temp*temp
      sjcount(neighbourcell) = sjcount(neighbourcell) + 1
    END DO
! 5. 计算谱半径（rj）和平均激波传感器（sj）
    ALLOCATE(rjd(ncells), source=0.0d0)
    rjd = 0.0_8
    ALLOCATE(rj(ncells), source=0.0d0)
! 谱半径 = 流速 + 声速
    DO c=1,ncells
! 谱半径：|速度| + 声速
! 原错误行拆分为两步：1. 调用mag获取模长；2. 计算rj(c)
! 第一步：调用mag，结果存到vec_mag
      CALL MAG_D(sln%cellprimitives(c, 3:5), slnd%cellprimitives(c, 3:5)&
&          , vec_mag, vec_magd)
      IF (1.0d-10 .LT. fluid%gammaa*fluid%r*sln%cellprimitives(c, 2)) &
&     THEN
        max1d = fluid%gammaa*fluid%r*slnd%cellprimitives(c, 2)
        max1 = fluid%gammaa*fluid%r*sln%cellprimitives(c, 2)
      ELSE
        max1 = 1.0d-10
        max1d = fluid%gammaa*fluid%r*slnd%cellprimitives(c, 2)
      END IF
      temp0 = SQRT(max1)
      IF (max1 .EQ. 0.0) THEN
        result1d = max1d/(2.0*temp0)
      ELSE
        result1d = max1d/(2.0*temp0)
      END IF
      result1 = temp0
      rjd(c) = vec_magd + REAL(result1d, kind=8)
      rj(c) = vec_mag + REAL(result1, kind=8)
! 平均sj（按面数平均）
      IF (sjcount(c) .GT. 0) THEN
        sjd(c) = sjd(c)/sjcount(c)
        sj(c) = sj(c)/sjcount(c)
      END IF
    END DO
! 6. 插值到面（取两侧单元最大值）
    ALLOCATE(rjsjfd(nfaces, 2), source=0.0d0)
    ALLOCATE(rjsjf(nfaces, 2), source=0.0d0)
! 第1列=rj，第2列=sj
! 调用插值函数
    CALL MAXINTERP_D(mesh, sj, sjd, rj, rjd, rjsjf, rjsjfd)
! 7. 计算JST格式的耗散系数eps2和eps4
    ALLOCATE(eps2d(nfaces), source=0.0d0)
    eps2d = 0.0_8
    ALLOCATE(eps2(nfaces), source=0.0d0)
    ALLOCATE(eps4d(nfaces), source=0.0d0)
    eps4d = 0.0_8
    ALLOCATE(eps4(nfaces), source=0.0d0)
! 内部面计算耗散
    DO f=1,nfaces-nbdryfaces
! eps2 = k2 * sj * rj
      eps2d(f) = k2_val*(rjsjf(f, 1)*rjsjfd(f, 2)+rjsjf(f, 2)*rjsjfd(f, &
&       1))
      eps2(f) = k2_val*rjsjf(f, 2)*rjsjf(f, 1)
      IF (0.0d0 .LT. k4_val*rjsjf(f, 1) - c4_val*eps2(f)) THEN
        eps4d(f) = k4_val*rjsjfd(f, 1) - c4_val*eps2d(f)
        eps4(f) = k4_val*rjsjf(f, 1) - c4_val*eps2(f)
      ELSE
        eps4d(f) = k4_val*rjsjfd(f, 1) - c4_val*eps2d(f)
        eps4(f) = 0.0d0
      END IF
    END DO
! 8. 输出结果：合并eps2和eps4为二维数组
    ALLOCATE(epsd(nfaces, 2), source=0.0d0)
    epsd = 0.0_8
    ALLOCATE(eps(nfaces, 2), source=0.0d0)
! 第1列=eps2
    epsd(:, 1) = eps2d
    eps(:, 1) = eps2
! 第2列=eps4
    epsd(:, 2) = eps4d
    eps(:, 2) = eps4
! 9. 释放临时内存
    IF (ALLOCATED(pd)) THEN
      DEALLOCATE(pd)
    END IF
    DEALLOCATE(p)
    IF (ALLOCATED(p_matrixd)) THEN
      DEALLOCATE(p_matrixd)
    END IF
    DEALLOCATE(p_matrix)
    IF (ALLOCATED(temp_gradd)) THEN
      DEALLOCATE(temp_gradd)
    END IF
    DEALLOCATE(temp_grad)
    IF (ALLOCATED(gradpd)) THEN
      DEALLOCATE(gradpd)
    END IF
    DEALLOCATE(gradp)
    IF (ALLOCATED(sjd)) THEN
      DEALLOCATE(sjd)
    END IF
    DEALLOCATE(sj)
    DEALLOCATE(sjcount)
    IF (ALLOCATED(rjd)) THEN
      DEALLOCATE(rjd)
    END IF
    DEALLOCATE(rj)
    IF (ALLOCATED(rjsjfd)) THEN
      DEALLOCATE(rjsjfd)
    END IF
    DEALLOCATE(rjsjf)
    IF (ALLOCATED(eps2d)) THEN
      DEALLOCATE(eps2d)
    END IF
    DEALLOCATE(eps2)
    IF (ALLOCATED(eps4d)) THEN
      DEALLOCATE(eps4d)
    END IF
    DEALLOCATE(eps4)
  END SUBROUTINE UNSTRUCTURED_JSTEPS_D

! 5.JST.jl!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! 4-55(函数unstructured_JSTEps)计算 JST 方法中的二阶（eps2）和四阶（eps4）人工扩散系数
! 56-108(函数unstructured_JSTFlux)执行 JST 方法计算通量残差
  SUBROUTINE UNSTRUCTURED_JSTEPS(mesh, sln, fluid, eps)
    IMPLICIT NONE
! 输入参数
    TYPE(MESHH), INTENT(IN) :: mesh
    TYPE(SOLUTIONSTATE), INTENT(IN) :: sln
    TYPE(FLUIDD), INTENT(IN) :: fluid
! 输出结果：二维数组，第1列=eps2，第2列=eps4
    REAL(kind=8), ALLOCATABLE, INTENT(OUT) :: eps(:, :)
! 局部变量
    INTEGER(kind=8) :: ncells, nfaces, nboundaries, nbdryfaces, meshinfo&
&   (4)
    REAL(kind=8), ALLOCATABLE :: p(:), gradp(:, :), p_matrix(:, :), &
&   temp_grad(:, :, :)
    REAL(kind=8), ALLOCATABLE :: sj(:), sjcount(:), rj(:), rjsjf(:, :)
    REAL(kind=8), ALLOCATABLE :: eps2(:), eps4(:)
    INTEGER(kind=8) :: f, ownercell, neighbourcell, c, nvars
    REAL(kind=8) :: d(3), op, np, farownerp, farneighbourp, epsilonn, &
&   dot_ownercell, dot_neighbourcell
! JST系数默认值
    REAL(kind=8) :: k2_val, k4_val, c4_val, vec_mag
    INTRINSIC SIZE
    INTRINSIC ABS
    INTRINSIC MAX
    INTRINSIC SQRT
    INTRINSIC REAL
    REAL(kind=8) :: x1
    REAL(kind=8) :: x2
    REAL(kind=8) :: abs0
    REAL(kind=8) :: abs1
    DOUBLE PRECISION :: max1
    REAL(kind=8) :: max2
    REAL(kind=8) :: max3
    REAL(kind=8) :: abs2
    REAL(kind=8) :: abs3
    REAL(kind=8) :: abs4
    REAL(kind=8) :: abs5
    DOUBLE PRECISION :: result1
! 1. 设置JST系数默认值（可选参数未输入时使用）
! 默认k2
    k2_val = 0.5d0
! 默认k4
    k4_val = 1.0d0/32.0d0
! 默认c4
    c4_val = 1.0d0
! 2. 获取网格信息（单元数、面数等）
    CALL UNSTRUCTUREDMESHINFO(mesh, meshinfo)
    ncells = meshinfo(1)
    nfaces = meshinfo(2)
    nboundaries = meshinfo(3)
    nbdryfaces = meshinfo(4)
! 3. 提取压力并计算压力梯度（用于激波检测）
    ALLOCATE(p(ncells), source=0.0d0)
! 压力（原始变量第1列）
    p = sln%cellprimitives(:, 1)
! 转换为二维矩阵（适配greenGaussGrad函数输入要求）
    ALLOCATE(p_matrix(ncells, 1), source=0.0d0)
    p_matrix(:, 1) = p
    ALLOCATE(temp_grad(ncells, 1, 3), source=0.0d0)
! 临时存储梯度（单元数×1变量×3方向×）
    nvars = SIZE(p_matrix, 2)
! 计算压力梯度
    CALL GREENGAUSSGRAD(mesh, p_matrix, .false., temp_grad)
    ALLOCATE(gradp(ncells, 3), source=0.0d0)
! 明确提取x方向梯度（第2维第1个元素）
    gradp(:, 1) = temp_grad(:, 1, 1)
! 明确提取y方向梯度（第2维第2个元素）
    gradp(:, 2) = temp_grad(:, 1, 2)
! 明确提取z方向梯度（第2维第3个元素）  ! 提取压力梯度（第1个变量的梯度）
    gradp(:, 3) = temp_grad(:, 1, 3)
! 4. 计算激波传感器（shock sensor）sj
    ALLOCATE(sj(ncells))
    ALLOCATE(sjcount(ncells))
! 激波传感器值
    sj = 0.0d0
! 计数：每个单元被多少面访问
    sjcount = 0.0d0
! 防止除零的小量
    epsilonn = 1.0d-10
! 只处理内部面（排除边界面）
    DO f=1,nfaces-nbdryfaces
      ownercell = mesh%faces(f, 1)
      neighbourcell = mesh%faces(f, 2)
! 单元质心向量差（neighbour - owner）
      d = mesh%ccenters(neighbourcell, :) - mesh%ccenters(ownercell, :)
! 提取压力值
      op = p(ownercell)
      np = p(neighbourcell)
      CALL DOT_PRODUCT_REAL(d, gradp(ownercell, :), dot_ownercell, 3)
      CALL DOT_PRODUCT_REAL(d, gradp(neighbourcell, :), &
&                     dot_neighbourcell, 3)
! 构造远端虚拟单元压力（基于梯度外推）
      farownerp = np - 2.0d0*dot_ownercell
      farneighbourp = op + 2.0d0*dot_neighbourcell
      IF (np - 2.0d0*op + farownerp .GE. 0.) THEN
        abs0 = np - 2.0d0*op + farownerp
      ELSE
        abs0 = -(np-2.0d0*op+farownerp)
      END IF
      IF (np - op .GE. 0.) THEN
        abs2 = np - op
      ELSE
        abs2 = -(np-op)
      END IF
      IF (op - farownerp .GE. 0.) THEN
        abs4 = op - farownerp
      ELSE
        abs4 = -(op-farownerp)
      END IF
      x1 = abs2 + abs4
      IF (x1 .LT. epsilonn) THEN
        max2 = epsilonn
      ELSE
        max2 = x1
      END IF
! 计算激波传感器值（累加）
      sj(ownercell) = sj(ownercell) + (abs0/max2)**2
      sjcount(ownercell) = sjcount(ownercell) + 1
      IF (op - 2.0d0*np + farneighbourp .GE. 0.) THEN
        abs1 = op - 2.0d0*np + farneighbourp
      ELSE
        abs1 = -(op-2.0d0*np+farneighbourp)
      END IF
      IF (farneighbourp - np .GE. 0.) THEN
        abs3 = farneighbourp - np
      ELSE
        abs3 = -(farneighbourp-np)
      END IF
      IF (np - op .GE. 0.) THEN
        abs5 = np - op
      ELSE
        abs5 = -(np-op)
      END IF
      x2 = abs3 + abs5
      IF (x2 .LT. epsilonn) THEN
        max3 = epsilonn
      ELSE
        max3 = x2
      END IF
      sj(neighbourcell) = sj(neighbourcell) + (abs1/max3)**2
      sjcount(neighbourcell) = sjcount(neighbourcell) + 1
    END DO
! 5. 计算谱半径（rj）和平均激波传感器（sj）
    ALLOCATE(rj(ncells), source=0.0d0)
! 谱半径 = 流速 + 声速
    DO c=1,ncells
! 谱半径：|速度| + 声速
! 原错误行拆分为两步：1. 调用mag获取模长；2. 计算rj(c)
! 第一步：调用mag，结果存到vec_mag
      CALL MAG(sln%cellprimitives(c, 3:5), vec_mag)
      IF (1.0d-10 .LT. fluid%gammaa*fluid%r*sln%cellprimitives(c, 2)) &
&     THEN
        max1 = fluid%gammaa*fluid%r*sln%cellprimitives(c, 2)
      ELSE
        max1 = 1.0d-10
      END IF
      result1 = SQRT(max1)
      rj(c) = vec_mag + REAL(result1, kind=8)
! 平均sj（按面数平均）
      IF (sjcount(c) .GT. 0) sj(c) = sj(c)/sjcount(c)
    END DO
! 6. 插值到面（取两侧单元最大值）
    ALLOCATE(rjsjf(nfaces, 2), source=0.0d0)
! 第1列=rj，第2列=sj
! 调用插值函数
    CALL MAXINTERP(mesh, sj, rj, rjsjf)
! 7. 计算JST格式的耗散系数eps2和eps4
    ALLOCATE(eps2(nfaces), source=0.0d0)
    ALLOCATE(eps4(nfaces), source=0.0d0)
! 内部面计算耗散
    DO f=1,nfaces-nbdryfaces
! eps2 = k2 * sj * rj
      eps2(f) = k2_val*rjsjf(f, 2)*rjsjf(f, 1)
      IF (0.0d0 .LT. k4_val*rjsjf(f, 1) - c4_val*eps2(f)) THEN
        eps4(f) = k4_val*rjsjf(f, 1) - c4_val*eps2(f)
      ELSE
        eps4(f) = 0.0d0
      END IF
    END DO
! 8. 输出结果：合并eps2和eps4为二维数组
    ALLOCATE(eps(nfaces, 2), source=0.0d0)
! 第1列=eps2
    eps(:, 1) = eps2
! 第2列=eps4
    eps(:, 2) = eps4
! 9. 释放临时内存
    DEALLOCATE(p)
    DEALLOCATE(p_matrix)
    DEALLOCATE(temp_grad)
    DEALLOCATE(gradp)
    DEALLOCATE(sj)
    DEALLOCATE(sjcount)
    DEALLOCATE(rj)
    DEALLOCATE(rjsjf)
    DEALLOCATE(eps2)
    DEALLOCATE(eps4)
  END SUBROUTINE UNSTRUCTURED_JSTEPS

!  Differentiation of unstructured_jstflux in forward (tangent) mode (with options i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8
! r4):
!   variations   of useful results: [alloc*unit_vec in normalize]
!                [alloc*fluxresiduals in integratefluxes_unstructured3d]
!                [alloc*(sln.fluxresiduals) in integratefluxes_unstructured3d]
!                [alloc*deltas in facedeltas] [alloc*facevals in maxinterp]
!                [alloc*grad in greengaussgrad] [alloc*facevals in greengaussgrad]
!                [alloc*fd in unstructured_jstflux] [alloc*diffusionflux in unstructured_jstflux]
!                [alloc*eps2 in unstructured_jstflux] [alloc*eps in unstructured_jsteps]
!                [alloc*eps4 in unstructured_jsteps] [alloc*eps2 in unstructured_jsteps]
!                [alloc*rj in unstructured_jsteps] [alloc*sj in unstructured_jsteps]
!                [alloc*gradp in unstructured_jsteps] [alloc*p_matrix in unstructured_jsteps]
!                [alloc*p in unstructured_jsteps] [alloc*(*sln.facefluxes) in solve]
!                [alloc*(*sln.fluxresiduals) in solve] *([alloc*sln in solve].fluxresiduals)
!                *([alloc*sln in solve].facefluxes)
!   with respect to varying inputs: [alloc*unit_vec in normalize]
!                [alloc*fluxresiduals in integratefluxes_unstructured3d]
!                [alloc*(sln.fluxresiduals) in integratefluxes_unstructured3d]
!                [alloc*(sln.cellfluxes) in decodesolution_3d]
!                [alloc*(sln.cellprimitives) in decodesolution_3d]
!                [alloc*deltas in facedeltas] [alloc*facevals in maxinterp]
!                [alloc*grad in greengaussgrad] [alloc*facevals in greengaussgrad]
!                [alloc*(mesh.ccenters) in openfoammesh] [alloc*(mesh.cvols) in openfoammesh]
!                [alloc*(mesh.fcenters) in openfoammesh] [alloc*(mesh.favecs) in openfoammesh]
!                [alloc*fd in unstructured_jstflux] [alloc*diffusionflux in unstructured_jstflux]
!                [alloc*eps2 in unstructured_jstflux] [alloc*eps in unstructured_jsteps]
!                [alloc*eps4 in unstructured_jsteps] [alloc*eps2 in unstructured_jsteps]
!                [alloc*rj in unstructured_jsteps] [alloc*sj in unstructured_jsteps]
!                [alloc*gradp in unstructured_jsteps] [alloc*p_matrix in unstructured_jsteps]
!                [alloc*p in unstructured_jsteps] [alloc*(*sln.facefluxes) in solve]
!                [alloc*(*sln.fluxresiduals) in solve] [alloc*(*sln.cellfluxes) in solve]
!                [alloc*(*sln.cellstate) in solve] [alloc*(*sln.cellprimitives) in solve]
!                *([alloc*sln in solve].cellstate) *([alloc*sln in solve].cellfluxes)
!                *([alloc*sln in solve].cellprimitives) *([alloc*sln in solve].fluxresiduals)
!                *([alloc*sln in solve].facefluxes)
!   Plus diff mem management of: unstructured_jstfluxx:out mesh.cvols:in
!                mesh.ccenters:in mesh.favecs:in mesh.fcenters:in
!                sln.cellstate:in sln.cellfluxes:in sln.cellprimitives:in
!                sln.fluxresiduals:in-out sln.facefluxes:in
! = 
!     输入：sln.cellState, sln.cellPrimitives, sln.cellFluxes 应该是最新的
!     输出：更新 sln.faceFluxes 和 sln.cellResiduals
!     返回：更新后的 sln.cellResiduals
! 
!     实现 JST 方法：中央差分 + 人工粘性（JST扩散），每个面作为一维问题处理
!     参考：https://aero-comlab.stanford.edu/Papers/jst_2015_updated_07_03_2015.pdf （特别是第5-6页）
! =#
! sln的初始值在第206行(主求解函数function solve)定义的
! JST扩散系数计算的包装函数
  SUBROUTINE UNSTRUCTURED_JSTFLUX_D(mesh, meshd, sln, slnd, &
&   boundaryconditions, fluid, unstructured_jstfluxx, &
&   unstructured_jstfluxxd)
    IMPLICIT NONE
    TYPE(MESHH), INTENT(IN) :: mesh
    TYPE(MESHH_DIFF), INTENT(IN) :: meshd
    TYPE(SOLUTIONSTATE), INTENT(INOUT) :: sln
    TYPE(SOLUTIONSTATE), INTENT(INOUT) :: slnd
    TYPE(BOUNDARYCONDITION), INTENT(IN) :: boundaryconditions(:)
    TYPE(FLUIDD), INTENT(IN) :: fluid
    REAL(kind=8) :: d(3), grad_v(3), dot_grad_v
    REAL(kind=8), ALLOCATABLE, INTENT(OUT) :: unstructured_jstfluxx(:, :&
&   )
    REAL(kind=8), ALLOCATABLE, INTENT(OUT) :: unstructured_jstfluxxd(:, &
&   :)
    REAL(kind=8), ALLOCATABLE :: eps2(:), eps4(:), diffusionflux(:), &
&   unitfa(:), fd(:), farownerfd(:), farneighbourfd(:), eps(:, :)
    REAL(kind=8), ALLOCATABLE :: eps2d(:), diffusionfluxd(:), unitfad(:)&
&   , fdd(:), epsd(:, :)
    REAL(kind=8), ALLOCATABLE :: fdeltas(:, :), fdgrads(:, :, :)
    REAL(kind=8), ALLOCATABLE :: fdeltasd(:, :), fdgradsd(:, :, :)
    INTEGER(kind=8) :: f, ownercell, neighbourcell, v, i1, i2, ncells, &
&   nfaces, nboundaries, nbdryfaces, nvars, meshinfo(4), i, max_col
! 控制输出面数量			
    INTEGER(kind=8) :: print_eps, print_face
    INTRINSIC SIZE
    INTRINSIC NEW_LINE
    INTRINSIC MIN
    INTRINSIC REAL
    CALL UNSTRUCTUREDMESHINFO(mesh, meshinfo)
    ncells = meshinfo(1)
    nfaces = meshinfo(2)
    nboundaries = meshinfo(3)
    nbdryfaces = meshinfo(4)
! 获取 sln.cellState 数组的 第二个维度的大小即有多少列
    nvars = SIZE(sln%cellstate, 2)
! #### 1. 应用边界条件 ####		
    CALL UPDATEBOUNDARYCONDITIONS_D(mesh, sln, slnd, boundaryconditions&
&                             , nboundaries, fluid)
! #### 2. 计算中央差分通量 ####
    CALL LININTERP_3D_D(mesh, meshd, sln%cellfluxes, slnd%cellfluxes, &
&                 sln%facefluxes, slnd%facefluxes)
! 输出前10个cellFluxes
    WRITE(*, *) 'cellFluxes:'
!		do i = 1, min(5, size(sln%cellFluxes,1))
!		    write(*,'(I5,*(E12.5))') i, sln%cellFluxes(i,:)
    WRITE(*, '(I5,*(E12.5))') 2210, sln%cellfluxes(2210, :)
    write(*,'(I5,*(E12.5))') 2305, sln%cellFluxes(2305,:)
!		end do
    WRITE(*, *) 'slnd%cellFluxes(微分):'
!		do i = 1, min(5, size(slnd%cellFluxes,1))
!		    write(*,'(I5,*(E12.5))') i, slnd%cellFluxes(i,:)
	write(*,'(I5,*(E12.5))') 2210, slnd%cellFluxes(2210,:)
	write(*,'(I5,*(E12.5))') 2305, slnd%cellFluxes(2305,:)
!		end do		
! 输出前10个faceFluxes - 修正这里使用size获取行数
    WRITE(*, *) '更新前faceFluxes:'
!		do f = 1, min(5, size(sln%faceFluxes,1))
!		    write(*,'(I5,*(E12.5))') f, sln%faceFluxes(f,:)
!		end do
	WRITE(*, '(I5,*(E12.5))') 4466, sln%facefluxes(4466, :)
    WRITE(*, *) '更新前slnd%faceFluxes(微分):'
!		do f = 1, min(5, size(slnd%faceFluxes,1))
!		    write(*,'(I5,*(E12.5))') f, slnd%faceFluxes(f,:)
	write(*,'(I5,*(E12.5))') 4466, slnd%faceFluxes(4466,:)
!		end do
! #### 3. 计算 JST 人工扩散通量 ####
    ALLOCATE(fdeltasd(nfaces, nvars), source=0.0d0)
    ALLOCATE(fdeltas(nfaces, nvars), source=0.0d0)
! 单元变量在面的差值
    CALL FACEDELTAS_D(mesh, sln, slnd, fdeltas, fdeltasd)
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! 新增：输出前5个面的 fdeltasd（微分面差值）
    PRINT*, NEW_LINE('a')//&
&   '=fdeltasd（微分面差值） ==='
    IF (5 .GT. nfaces) THEN
      print_face = nfaces
    ELSE
      print_face = 5
    END IF
!		DO f=1,print_face
!		  WRITE(*, '(A,I3,A,*(ES16.8,1X))') '  面 ', f, ': ', (fdeltasd(f, v), v=1, nvars)
	WRITE(*, '(A,I3,A,*(ES16.8,1X))') '  面 ', 4466, ': ', (fdeltasd(4466, v), v=1, nvars)
!		END DO
    PRINT*, NEW_LINE('a')//'=== 前5个面：fdeltas（面差值） ==='
!		DO f=1,print_face
!		  WRITE(*, '(A,I3,A,*(ES16.8,1X))') '  面 ', f, ': ', (fdeltas(f, v), v=1, nvars)
	WRITE(*, '(A,I3,A,*(ES16.8,1X))') '  面 ', 4466, ': ', (fdeltas(4466, v), v=1, nvars)
!		END DO
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    ALLOCATE(fdgradsd(ncells, nvars, 3), source=0.0d0)
    ALLOCATE(fdgrads(ncells, nvars, 3), source=0.0d0)
    PRINT*, 'AAA'
! 差值的梯度
    CALL GREENGAUSSGRADD_D(mesh, meshd, fdeltas, .false., fdgrads, &
&                    fdgradsd)
    PRINT*, 'BBB'
    ALLOCATE(eps2d(nfaces), source=0.0d0)
    eps2d = 0.0_8
    ALLOCATE(eps2(nfaces), source=0.0d0)
    ALLOCATE(eps4(nfaces), source=0.0d0)
    ALLOCATE(epsd(nfaces, 2), source=0.0d0)
    ALLOCATE(eps(nfaces, 2), source=0.0d0)
! 二阶和四阶人工扩散系数
    CALL UNSTRUCTURED_JSTEPS_D(mesh, meshd, sln, slnd, fluid, eps, epsd)
    PRINT*, 'CCC'
    IF (5 .GT. nfaces) THEN
      print_eps = nfaces
    ELSE
      print_eps = 5
    END IF
    PRINT*, NEW_LINE('a')//&
&   '=== 前5个面的eps值（二阶/四阶） ==='
    PRINT*, '格式：面索引 | eps2（二阶） | eps4（四阶）'
!		DO f = 1, print_eps
!			WRITE(*, '(I5, 2ES14.6)') f, eps(f, 1), eps(f, 2)  ! 用科学计数法适配可能的小数值
!		END DO
    WRITE(*, '(I5, 2ES14.6)') 4466, eps(4466, 1), eps(4466, 2)
    PRINT *, '格式：面索引 | eps2d（二阶） | eps4d（四阶）'
	WRITE(*, '(I5, 2ES14.6)') 4466, epsd(4466, 1), epsd(4466, 2)
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!	
! 二阶耗散系数
    eps2d = epsd(:, 1)
    eps2 = eps(:, 1)
! 四阶耗散系数
    eps4 = eps(:, 2)
    IF (ALLOCATED(epsd)) THEN
      DEALLOCATE(epsd)
    END IF
    DEALLOCATE(eps)
! 及时释放临时数组eps（关键修正）
    ALLOCATE(diffusionfluxd(nvars), source=0.0d0)
    diffusionfluxd = 0.0_8
    ALLOCATE(diffusionflux(nvars), source=0.0d0)
    ALLOCATE(unitfad(3), source=0.0d0)
    ALLOCATE(unitfa(3), source=0.0d0)
    ALLOCATE(fdd(nvars), source=0.0d0)
    fdd = 0.0_8
    ALLOCATE(fd(nvars), source=0.0d0)
    ALLOCATE(farownerfd(nvars), source=0.0d0)
    ALLOCATE(farneighbourfd(nvars), source=0.0d0)
    DO f=1,nfaces-nbdryfaces
      ownercell = mesh%faces(f, 1)
      neighbourcell = mesh%faces(f, 2)
! 这个中心点cCenters是根据面中心点和体中心点加权得到
      d = mesh%ccenters(neighbourcell, :) - mesh%ccenters(ownercell, :)
! 获取该面的状态差值
      fdd = fdeltasd(f, :)
      fd = fdeltas(f, :)
! 虚拟单元的状态差值（逐个变量计算梯度点积）
! 遍历每个变量
      DO v=1,nvars
! 提取第v个变量在ownerCell处的梯度向量（1维数组：x,y,z方向梯度）				
! 维度：(单元格, 变量v, 空间维度) → 1维
        grad_v = REAL(fdgrads(ownercell, v, :), kind=8)
        CALL DOT_PRODUCT_REAL(d, grad_v, dot_grad_v, 3)
! 计算点积（d和grad_v都是1维向量，符合dot_product要求）
        farownerfd(v) = fd(v) - dot_grad_v
        farneighbourfd(v) = fd(v) + dot_grad_v
      END DO
! 人工扩散项 = eps2 * 一阶差值 - eps4 * 二阶差值
!			diffusionFlux = eps2(f) * fD - eps4(f) * (farNeighbourfD - 2*fD + farOwnerfD)
      diffusionfluxd = fd*eps2d(f) + eps2(f)*fdd
      diffusionflux = eps2(f)*fd
! 将扩散通量添加到面通量上，方向用单位面积向量调整
! mesh.fAVecs是面法向量(通过面的子三角形的叉乘求法向量，然后相加作为面的法向量) ,normalize将法\E5
!\90\91量转化为单位向量
      CALL NORMALIZE_D(mesh%favecs(f, :), meshd%favecs(f, :), unitfa, &
&                unitfad)
! 新增：输出前5个面的 diffusionfluxd（微分扩散通量）和 unitfad（微分单位法向量）

!			IF (f .LE. 5) THEN
 	  IF (f == 4466) THEN
		WRITE(*, '(A,I3,A)') NEW_LINE('a')//'--- 面 ', f, '：微分扩散通量 & 单位法向量 ---'		
		WRITE(*, '(A,*(ES16.8,1X))') '  diffusionflux: ', (diffusionflux(v), v=1, nvars)
		WRITE(*, '(A,*(ES16.8,1X))') '  diffusionfluxd: ', (diffusionfluxd(v), v=1, nvars)
		WRITE(*, '(A,3(ES16.8,1X))') '  unitfa (x/y/z): ', unitfa(1), unitfa(2), unitfa(3)
		WRITE(*, '(A,3(ES16.8,1X))') '  unitfad (x/y/z): ', unitfad(1), unitfad(2), unitfad(3)
	  END IF
      DO v=1,nvars
        i1 = (v-1)*3 + 1
        i2 = i1 + 2
! !!!!!!!!!线性加权计算出来的面通量就代表这两包这件通过这个面传递的通量残差!!!!!!!!!
        slnd%facefluxes(f, i1:i2) = slnd%facefluxes(f, i1:i2) - unitfa*&
&         diffusionfluxd(v) - diffusionflux(v)*unitfad
        sln%facefluxes(f, i1:i2) = sln%facefluxes(f, i1:i2) - &
&         diffusionflux(v)*unitfa
      END DO
    END DO
! 输出前10个faceFluxes - 修正这里使用size获取行数
    WRITE(*, *) '更新后sln%facefluxes:'
!		do f = 1, min(10, size(sln%faceFluxes,1))
!		    write(*,'(I5,*(E12.5))') f, sln%faceFluxes(f,:)
    WRITE(*, '(I5,*(E12.5))') 4466, sln%facefluxes(4466, :)
!		end do
	WRITE(*, *) '更新后slnd%facefluxes:'
    WRITE(*, '(I5,*(E12.5))') 4466, slnd%facefluxes(4466, :)
! #### 4. 将面通量积分到单元内部，得到单元残差 ####
    ALLOCATE(unstructured_jstfluxxd(ncells, nvars), source=0.0d0)
    ALLOCATE(unstructured_jstfluxx(ncells, nvars), source=0.0d0)
    CALL INTEGRATEFLUXES_UNSTRUCTURED3D_D(mesh, meshd, sln, slnd, &
&                                   unstructured_jstfluxx, &
&                                   unstructured_jstfluxxd)
    IF (ALLOCATED(fdeltasd)) THEN
      DEALLOCATE(fdeltasd)
    END IF
    DEALLOCATE(fdeltas)
    IF (ALLOCATED(fdgradsd)) THEN
      DEALLOCATE(fdgradsd)
    END IF
    DEALLOCATE(fdgrads)
    IF (ALLOCATED(eps2d)) THEN
      DEALLOCATE(eps2d)
    END IF
    DEALLOCATE(eps2)
    DEALLOCATE(eps4)
    IF (ALLOCATED(diffusionfluxd)) THEN
      DEALLOCATE(diffusionfluxd)
    END IF
    DEALLOCATE(diffusionflux)
    IF (ALLOCATED(unitfad)) THEN
      DEALLOCATE(unitfad)
    END IF
    DEALLOCATE(unitfa)
    IF (ALLOCATED(fdd)) THEN
      DEALLOCATE(fdd)
    END IF
    DEALLOCATE(fd)
    DEALLOCATE(farownerfd)
    DEALLOCATE(farneighbourfd)
  END SUBROUTINE UNSTRUCTURED_JSTFLUX_D

! = 
!     输入：sln.cellState, sln.cellPrimitives, sln.cellFluxes 应该是最新的
!     输出：更新 sln.faceFluxes 和 sln.cellResiduals
!     返回：更新后的 sln.cellResiduals
! 
!     实现 JST 方法：中央差分 + 人工粘性（JST扩散），每个面作为一维问题处理
!     参考：https://aero-comlab.stanford.edu/Papers/jst_2015_updated_07_03_2015.pdf （特别是第5-6页）
! =#
! sln的初始值在第206行(主求解函数function solve)定义的
! JST扩散系数计算的包装函数
  SUBROUTINE UNSTRUCTURED_JSTFLUX(mesh, sln, boundaryconditions, fluid, &
&   unstructured_jstfluxx)
    IMPLICIT NONE
    TYPE(MESHH), INTENT(IN) :: mesh
    TYPE(SOLUTIONSTATE), INTENT(INOUT) :: sln
    TYPE(BOUNDARYCONDITION), INTENT(IN) :: boundaryconditions(:)
    TYPE(FLUIDD), INTENT(IN) :: fluid
    REAL(kind=8) :: d(3), grad_v(3), dot_grad_v
    REAL(kind=8), ALLOCATABLE, INTENT(OUT) :: unstructured_jstfluxx(:, :&
&   )
    REAL(kind=8), ALLOCATABLE :: eps2(:), eps4(:), diffusionflux(:), &
&   unitfa(:), fd(:), farownerfd(:), farneighbourfd(:), eps(:, :)
    REAL(kind=8), ALLOCATABLE :: fdeltas(:, :), fdgrads(:, :, :)
    INTEGER(kind=8) :: f, ownercell, neighbourcell, v, i1, i2, ncells, &
&   nfaces, nboundaries, nbdryfaces, nvars, meshinfo(4), i, max_col
! 控制输出面数量			
    INTEGER(kind=8) :: print_eps, print_face
    INTRINSIC SIZE
    INTRINSIC NEW_LINE
    INTRINSIC MIN
    INTRINSIC REAL
    CALL UNSTRUCTUREDMESHINFO(mesh, meshinfo)
    ncells = meshinfo(1)
    nfaces = meshinfo(2)
    nboundaries = meshinfo(3)
    nbdryfaces = meshinfo(4)
! 获取 sln.cellState 数组的 第二个维度的大小即有多少列
    nvars = SIZE(sln%cellstate, 2)
! #### 1. 应用边界条件 ####		
    CALL UPDATEBOUNDARYCONDITIONS(mesh, sln, boundaryconditions, &
&                           nboundaries, fluid)
! #### 2. 计算中央差分通量 ####
    CALL LININTERP_3D(mesh, sln%cellfluxes, sln%facefluxes)
! 输出前10个cellFluxes
    WRITE(*, *) 'First 10 cellFluxes:'
!		do i = 1, min(5, size(sln%cellFluxes,1))
!		    write(*,'(I5,*(E12.5))') i, sln%cellFluxes(i,:)
    WRITE(*, '(I5,*(E12.5))') 2210, sln%cellfluxes(2210, :)
!		end do
    WRITE(*, *) 'First 10 slnd%cellFluxes(微分):'
!		do i = 1, min(5, size(slnd%cellFluxes,1))
!		    write(*,'(I5,*(E12.5))') i, slnd%cellFluxes(i,:)
!		write(*,'(I5,*(E12.5))') 2210, slnd%cellFluxes(2210,:)
!		end do		
! 输出前10个faceFluxes - 修正这里使用size获取行数
    WRITE(*, *) 'First 10 faceFluxes:'
!		do f = 1, min(5, size(sln%faceFluxes,1))
!		    write(*,'(I5,*(E12.5))') f, sln%faceFluxes(f,:)
!		end do
!		IF (f == 4466) THEN
!		   WRITE(*, '(I5,*(E12.5))') f, sln%facefluxes(f, :)
!		end if
    WRITE(*, *) 'First 10 slnd%faceFluxes(微分):'
!		do f = 1, min(5, size(slnd%faceFluxes,1))
!		    write(*,'(I5,*(E12.5))') f, slnd%faceFluxes(f,:)
!		write(*,'(I5,*(E12.5))') 4466, slnd%faceFluxes(4466,:)
!		end do
! #### 3. 计算 JST 人工扩散通量 ####
    ALLOCATE(fdeltas(nfaces, nvars), source=0.0d0)
! 单元变量在面的差值
    CALL FACEDELTAS(mesh, sln, fdeltas)
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! 新增：输出前5个面的 fdeltasd（微分面差值）
    PRINT*, NEW_LINE('a')//&
&   '=== 前5个面：fdeltasd（微分面差值） ==='
    IF (5 .GT. nfaces) THEN
      print_face = nfaces
    ELSE
      print_face = 5
    END IF
!		DO f=1,print_face
!		  WRITE(*, '(A,I3,A,*(ES16.8,1X))') '  面 ', f, ': ', (fdeltasd(f, v), v=1, nvars)
!		WRITE(*, '(A,I3,A,*(ES16.8,1X))') '  面 ', 4466, ': ', (fdeltasd(4466, v), v=1, nvars)
!		END DO
    PRINT*, NEW_LINE('a')//'=== 前5个面：fdeltas（面差值） ==='
!		DO f=1,print_face
!		  WRITE(*, '(A,I3,A,*(ES16.8,1X))') '  面 ', f, ': ', (fdeltas(f, v), v=1, nvars)
!		WRITE(*, '(A,I3,A,*(ES16.8,1X))') '  面 ', 4466, ': ', (fdeltas(4466, v), v=1, nvars)
!		END DO
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    ALLOCATE(fdgrads(ncells, nvars, 3), source=0.0d0)
    PRINT*, 'AAA'
! 差值的梯度
    CALL GREENGAUSSGRADD(mesh, fdeltas, .false., fdgrads)
    PRINT*, 'BBB'
    ALLOCATE(eps2(nfaces), source=0.0d0)
    ALLOCATE(eps4(nfaces), source=0.0d0)
    ALLOCATE(eps(nfaces, 2), source=0.0d0)
! 二阶和四阶人工扩散系数
    CALL UNSTRUCTURED_JSTEPS(mesh, sln, fluid, eps)
    PRINT*, 'CCC'
    IF (5 .GT. nfaces) THEN
      print_eps = nfaces
    ELSE
      print_eps = 5
    END IF
    PRINT*, NEW_LINE('a')//&
&   '=== 前5个面的eps值（二阶/四阶） ==='
    PRINT*, '格式：面索引 | eps2（二阶） | eps4（四阶）'
!		DO f = 1, print_eps
!			WRITE(*, '(I5, 2ES14.6)') f, eps(f, 1), eps(f, 2)  ! 用科学计数法适配可能的小数值
!		END DO
    WRITE(*, '(I5, 2ES14.6)') 4466, eps(4466, 1), eps(4466, 2)
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!	
! 二阶耗散系数
    eps2 = eps(:, 1)
! 四阶耗散系数
    eps4 = eps(:, 2)
    DEALLOCATE(eps)
! 及时释放临时数组eps（关键修正）
    ALLOCATE(diffusionflux(nvars), source=0.0d0)
    ALLOCATE(unitfa(3), source=0.0d0)
    ALLOCATE(fd(nvars), source=0.0d0)
    ALLOCATE(farownerfd(nvars), source=0.0d0)
    ALLOCATE(farneighbourfd(nvars), source=0.0d0)
    DO f=1,nfaces-nbdryfaces
      ownercell = mesh%faces(f, 1)
      neighbourcell = mesh%faces(f, 2)
! 这个中心点cCenters是根据面中心点和体中心点加权得到
      d = mesh%ccenters(neighbourcell, :) - mesh%ccenters(ownercell, :)
! 获取该面的状态差值
      fd = fdeltas(f, :)
! 虚拟单元的状态差值（逐个变量计算梯度点积）
! 遍历每个变量
      DO v=1,nvars
! 提取第v个变量在ownerCell处的梯度向量（1维数组：x,y,z方向梯度）				
! 维度：(单元格, 变量v, 空间维度) → 1维
        grad_v = REAL(fdgrads(ownercell, v, :), kind=8)
        CALL DOT_PRODUCT_REAL(d, grad_v, dot_grad_v, 3)
! 计算点积（d和grad_v都是1维向量，符合dot_product要求）
        farownerfd(v) = fd(v) - dot_grad_v
        farneighbourfd(v) = fd(v) + dot_grad_v
      END DO
! 人工扩散项 = eps2 * 一阶差值 - eps4 * 二阶差值
!			diffusionFlux = eps2(f) * fD - eps4(f) * (farNeighbourfD - 2*fD + farOwnerfD)
      diffusionflux = eps2(f)*fd
! 将扩散通量添加到面通量上，方向用单位面积向量调整
! mesh.fAVecs是面法向量(通过面的子三角形的叉乘求法向量，然后相加作为面的法向量) ,normalize将法\E5
!\90\91量转化为单位向量
      CALL NORMALIZE(mesh%favecs(f, :), unitfa)
! 新增：输出前5个面的 diffusionfluxd（微分扩散通量）和 unitfad（微分单位法向量）
      PRINT*, '微分扩散通量,单位法向量'
!			IF (f .LE. 5) THEN
!			IF (f == 4466) THEN
!				WRITE(*, '(A,I3,A)') NEW_LINE('a')//'--- 面 ', f, '：微分扩散通量 & 单位法向量 ---'
!				WRITE(*, '(A,*(ES16.8,1X))') '  diffusionfluxd: ', (diffusionfluxd(v), v=1, nvars)
!				WRITE(*, '(A,3(ES16.8,1X))') '  unitfad (x/y/z): ', unitfad(1), unitfad(2), unitfad(3)
!			END IF
      DO v=1,nvars
        i1 = (v-1)*3 + 1
        i2 = i1 + 2
! !!!!!!!!!线性加权计算出来的面通量就代表这两包这件通过这个面传递的通量残差!!!!!!!!!
        sln%facefluxes(f, i1:i2) = sln%facefluxes(f, i1:i2) - &
&         diffusionflux(v)*unitfa
      END DO
    END DO
! 输出前10个faceFluxes - 修正这里使用size获取行数
    WRITE(*, *) 'First 10 faceFluxes:'
!		do f = 1, min(10, size(sln%faceFluxes,1))
!		    write(*,'(I5,*(E12.5))') f, sln%faceFluxes(f,:)
    WRITE(*, '(I5,*(E12.5))') 4466, sln%facefluxes(4466, :)
!		end do
    WRITE(*, '(I5,*(E12.5))') 4466, sln%facefluxes(4466, :)
! #### 4. 将面通量积分到单元内部，得到单元残差 ####
    ALLOCATE(unstructured_jstfluxx(ncells, nvars), source=0.0d0)
    CALL INTEGRATEFLUXES_UNSTRUCTURED3D(mesh, sln, unstructured_jstfluxx&
&                                )
    DEALLOCATE(fdeltas)
    DEALLOCATE(fdgrads)
    DEALLOCATE(eps2)
    DEALLOCATE(eps4)
    DEALLOCATE(diffusionflux)
    DEALLOCATE(unitfa)
    DEALLOCATE(fd)
    DEALLOCATE(farownerfd)
    DEALLOCATE(farneighbourfd)
  END SUBROUTINE UNSTRUCTURED_JSTFLUX

!  Differentiation of trianglecentroid in forward (tangent) mode (with options i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4)
!:
!   variations   of useful results: trianglecentroidd
!   with respect to varying inputs: points
! 6.mesh.jl!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! 引用自 Moukalled 等人的《FVM》书籍——适用于 OpenFOAM、Matlab 等平台的计算方法
! 1-98行(有限体积法准备工作): 计算单元/面的几何中心、面积向量、体积等关键几何属性
! 98-310: 读取和处理OpenFOAM网格数据，包括点 (points)、面 (faces)、所有权 (owner)、邻接关系 (neighbour) \E4
!\BB\A5及边界信息 (boundary)
! 310-500: 将 OpenFOAM 网格文件夹中的面和点信息转换为单元（cell）结构，并确保其点的顺序满足 .vtk
! 文件格式的要求
! 500-612: 主函数!!!!!!!，读取OpenFOAM 网格文件，并输出为FvCFD.jl可后续使用的Mesh 类型
! ######################### 网格/单元几何相关函数 ###########################
! 计算三角形（或多边体）的几何中心!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  SUBROUTINE TRIANGLECENTROID_D(points, pointsd, trianglecentroidd, &
&   trianglecentroiddd)
    IMPLICIT NONE
    REAL(kind=8), INTENT(IN) :: points(:, :)
    REAL(kind=8), INTENT(IN) :: pointsd(:, :)
    REAL(kind=8), INTENT(INOUT) :: trianglecentroidd(3)
    REAL(kind=8), INTENT(INOUT) :: trianglecentroiddd(3)
    INTEGER(kind=8) :: npts, pt
    INTRINSIC SIZE
    trianglecentroidd = (/0.0d0, 0.0d0, 0.0d0/)
    npts = SIZE(points, 1)
    trianglecentroiddd = 0.0_8
    DO pt=1,npts
! 累加每个点坐标
      trianglecentroiddd = trianglecentroiddd + pointsd(pt, :)
      trianglecentroidd = trianglecentroidd + points(pt, :)
    END DO
! 求平均，即几何中心
    trianglecentroiddd = trianglecentroiddd/npts
    trianglecentroidd = trianglecentroidd/npts
  END SUBROUTINE TRIANGLECENTROID_D

! 6.mesh.jl!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! 引用自 Moukalled 等人的《FVM》书籍——适用于 OpenFOAM、Matlab 等平台的计算方法
! 1-98行(有限体积法准备工作): 计算单元/面的几何中心、面积向量、体积等关键几何属性
! 98-310: 读取和处理OpenFOAM网格数据，包括点 (points)、面 (faces)、所有权 (owner)、邻接关系 (neighbour) \E4
!\BB\A5及边界信息 (boundary)
! 310-500: 将 OpenFOAM 网格文件夹中的面和点信息转换为单元（cell）结构，并确保其点的顺序满足 .vtk
! 文件格式的要求
! 500-612: 主函数!!!!!!!，读取OpenFOAM 网格文件，并输出为FvCFD.jl可后续使用的Mesh 类型
! ######################### 网格/单元几何相关函数 ###########################
! 计算三角形（或多边体）的几何中心!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  SUBROUTINE TRIANGLECENTROID(points, trianglecentroidd)
    IMPLICIT NONE
    REAL(kind=8), INTENT(IN) :: points(:, :)
    REAL(kind=8), INTENT(INOUT) :: trianglecentroidd(3)
    INTEGER(kind=8) :: npts, pt
    INTRINSIC SIZE
    trianglecentroidd = (/0.0d0, 0.0d0, 0.0d0/)
    npts = SIZE(points, 1)
    DO pt=1,npts
! 累加每个点坐标
      trianglecentroidd = trianglecentroidd + points(pt, :)
    END DO
! 求平均，即几何中心
    trianglecentroidd = trianglecentroidd/npts
  END SUBROUTINE TRIANGLECENTROID

!  Differentiation of geometriccenter in forward (tangent) mode (with options i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4):
!   variations   of useful results: geometriccenterr
!   with respect to varying inputs: points
! 为几何中心函数设置一个别名
  SUBROUTINE GEOMETRICCENTER_D(points, pointsd, geometriccenterr, &
&   geometriccenterrd)
    IMPLICIT NONE
    REAL(kind=8), INTENT(IN) :: points(:, :)
    REAL(kind=8), INTENT(IN) :: pointsd(:, :)
    REAL(kind=8), INTENT(INOUT) :: geometriccenterr(3)
    REAL(kind=8), INTENT(INOUT) :: geometriccenterrd(3)
    CALL TRIANGLECENTROID_D(points, pointsd, geometriccenterr, &
&                     geometriccenterrd)
  END SUBROUTINE GEOMETRICCENTER_D

! 为几何中心函数设置一个别名
  SUBROUTINE GEOMETRICCENTER(points, geometriccenterr)
    IMPLICIT NONE
    REAL(kind=8), INTENT(IN) :: points(:, :)
    REAL(kind=8), INTENT(INOUT) :: geometriccenterr(3)
    CALL TRIANGLECENTROID(points, geometriccenterr)
  END SUBROUTINE GEOMETRICCENTER

!  Differentiation of trianglearea in forward (tangent) mode (with options i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4):
!   variations   of useful results: triangleareaa
!   with respect to varying inputs: points triangleareaa
! 计算三角形面积向量!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  SUBROUTINE TRIANGLEAREA_D(points, pointsd, triangleareaa, &
&   triangleareaad)
    IMPLICIT NONE
    REAL(kind=8), INTENT(IN) :: points(:, :)
    REAL(kind=8), INTENT(IN) :: pointsd(:, :)
    REAL(kind=8), INTENT(INOUT) :: triangleareaa(3)
    REAL(kind=8), INTENT(INOUT) :: triangleareaad(3)
    REAL(kind=8) :: side1(3), side2(3)
    REAL(kind=8) :: side1d(3), side2d(3)
    side1d = pointsd(2, :) - pointsd(1, :)
    side1 = points(2, :) - points(1, :)
    side2d = pointsd(3, :) - pointsd(1, :)
    side2 = points(3, :) - points(1, :)
    CALL CROSS_D(side1, side1d, side2, side2d, triangleareaa, &
&          triangleareaad)
! 使用向量叉乘除以2
    triangleareaad = triangleareaad/2.0d0
    triangleareaa = triangleareaa/2.0d0
  END SUBROUTINE TRIANGLEAREA_D

! 计算三角形面积向量!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  SUBROUTINE TRIANGLEAREA(points, triangleareaa)
    IMPLICIT NONE
    REAL(kind=8), INTENT(IN) :: points(:, :)
    REAL(kind=8), INTENT(INOUT) :: triangleareaa(3)
    REAL(kind=8) :: side1(3), side2(3)
    side1 = points(2, :) - points(1, :)
    side2 = points(3, :) - points(1, :)
    CALL CROSS(side1, side2, triangleareaa)
! 使用向量叉乘除以2
    triangleareaa = triangleareaa/2.0d0
  END SUBROUTINE TRIANGLEAREA

!  Differentiation of faceareacentroid in forward (tangent) mode (with options i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4)
!:
!   variations   of useful results: centroid favec
!   with respect to varying inputs: points
! 计算多边形面元的面积向量与几何中心!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  SUBROUTINE FACEAREACENTROID_D(points, pointsd, first5_refs, favec, &
&   favecd, centroid, centroidd)
    IMPLICIT NONE
    REAL(kind=8), INTENT(IN) :: points(:, :)
    REAL(kind=8), INTENT(IN) :: pointsd(:, :)
    REAL(kind=8), INTENT(OUT) :: favec(3), centroid(3)
    REAL(kind=8), INTENT(OUT) :: favecd(3), centroidd(3)
    REAL(kind=8) :: gc(3), subtripts(3, 3), tricentroid(3), subfavec(3)
    REAL(kind=8) :: gcd(3), subtriptsd(3, 3), tricentroidd(3), subfavecd&
&   (3)
! 新增：两个临时变量
    REAL(kind=8) :: mag_subfavec, mag_favec
    REAL(kind=8) :: mag_subfavecd, mag_favecd
    INTEGER(kind=8) :: npts, i
! 标记是否需要输出
    LOGICAL :: print_output
! 前5个面的参考顶点坐标!!!!!!!!!!!!!!
    REAL(kind=8), INTENT(IN) :: first5_refs(5, 3)
! 当前面的索引（1-5）!!!!!!!!!!!!!!!!!!!
    INTEGER(kind=8) :: current_face_id, f
!!!!!!!!!
    LOGICAL :: is_in_first5
    INTRINSIC ABS
    INTRINSIC SIZE
    REAL(kind=8) :: abs0
    REAL(kind=8) :: abs1
    REAL(kind=8) :: abs2
! 判断是否为前5个面（通过第一个顶点坐标匹配）!!!!!!!!
    is_in_first5 = .false.
    current_face_id = 0
    DO f=1,5
      IF (points(1, 1) - first5_refs(f, 1) .GE. 0.) THEN
        abs0 = points(1, 1) - first5_refs(f, 1)
      ELSE
        abs0 = -(points(1, 1)-first5_refs(f, 1))
      END IF
      IF (points(1, 2) - first5_refs(f, 2) .GE. 0.) THEN
        abs1 = points(1, 2) - first5_refs(f, 2)
      ELSE
        abs1 = -(points(1, 2)-first5_refs(f, 2))
      END IF
      IF (points(1, 3) - first5_refs(f, 3) .GE. 0.) THEN
        abs2 = points(1, 3) - first5_refs(f, 3)
      ELSE
        abs2 = -(points(1, 3)-first5_refs(f, 3))
      END IF
! 允许微小数值误差（1e-6）
      IF (abs0 .LT. 1d-6 .AND. abs1 .LT. 1d-6 .AND. abs2 .LT. 1d-6) GOTO&
&        100
    END DO
    GOTO 110
 100 is_in_first5 = .true.
    current_face_id = f
! 得到整个面的几何中心
 110 gcd = 0.0_8
    CALL GEOMETRICCENTER_D(points, pointsd, gc, gcd)
    npts = SIZE(points, 1)
! 初始化面面积向量
    favec = (/0.0d0, 0.0d0, 0.0d0/)
! 初始化面中心        
    centroid = (/0.0d0, 0.0d0, 0.0d0/)
! 仅当处理第1个面时才输出
!!!!!!!!!!!!!!!
    print_output = f .EQ. 1
    centroidd = 0.0_8
    favecd = 0.0_8
    subtriptsd = 0.0_8
    subfavecd = 0.0_8
! 将多边形面分割成多个由几何中心和两个相邻顶点组成的三角形!!!!!!!!!!!!!!!!!!!!
    DO i=1,npts
      IF (i .LT. npts) THEN
        subtriptsd(1, :) = gcd
        subtripts(1, :) = gc
        subtriptsd(2, :) = pointsd(i, :)
        subtripts(2, :) = points(i, :)
        subtriptsd(3, :) = pointsd(i+1, :)
        subtripts(3, :) = points(i+1, :)
      ELSE
        subtriptsd(1, :) = gcd
        subtripts(1, :) = gc
        subtriptsd(2, :) = pointsd(i, :)
        subtripts(2, :) = points(i, :)
! 闭合面
        subtriptsd(3, :) = pointsd(1, :)
        subtripts(3, :) = points(1, :)
      END IF
!subTriPts没问题
! 子三角形中心
      tricentroidd = 0.0_8
      CALL TRIANGLECENTROID_D(subtripts, subtriptsd, tricentroid, &
&                       tricentroidd)
! 子三角形面积向量
      CALL TRIANGLEAREA_D(subtripts, subtriptsd, subfavec, subfavecd)
! 前5个面输出subFAVec
      IF (is_in_first5) THEN
        PRINT*, '=== 第', current_face_id, '个面的子三角形 ', i&
&       , ' ==='
        PRINT*, '  subFAVec (x,y,z): (', subfavec(1), ',', subfavec(2), &
&       ',', subfavec(3), ')'
! 面积大小（标量）
        PRINT*, '  面积大小: ', mag_subfavec
      END IF
      favecd = favecd + subfavecd
      favec = favec + subfavec
! 计算 subFAVec 模长	
      CALL MAG_D(subfavec, subfavecd, mag_subfavec, mag_subfavecd)
      centroidd = centroidd + mag_subfavec*tricentroidd + tricentroid*&
&       mag_subfavecd
      centroid = centroid + tricentroid*mag_subfavec
    END DO
! 计算 fAVec 模长
    CALL MAG_D(favec, favecd, mag_favec, mag_favecd)
! 用临时变   ! 总质心为加权平均
    centroidd = (centroidd-centroid*mag_favecd/mag_favec)/mag_favec
    centroid = centroid/mag_favec
    IF (is_in_first5) PRINT*, 'centroid=', centroid
  END SUBROUTINE FACEAREACENTROID_D

! 计算多边形面元的面积向量与几何中心!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  SUBROUTINE FACEAREACENTROID(points, first5_refs, favec, centroid)
    IMPLICIT NONE
    REAL(kind=8), INTENT(IN) :: points(:, :)
    REAL(kind=8), INTENT(OUT) :: favec(3), centroid(3)
    REAL(kind=8) :: gc(3), subtripts(3, 3), tricentroid(3), subfavec(3)
! 新增：两个临时变量
    REAL(kind=8) :: mag_subfavec, mag_favec
    INTEGER(kind=8) :: npts, i
! 标记是否需要输出
    LOGICAL :: print_output
! 前5个面的参考顶点坐标!!!!!!!!!!!!!!
    REAL(kind=8), INTENT(IN) :: first5_refs(5, 3)
! 当前面的索引（1-5）!!!!!!!!!!!!!!!!!!!
    INTEGER(kind=8) :: current_face_id, f
!!!!!!!!!
    LOGICAL :: is_in_first5
    INTRINSIC ABS
    INTRINSIC SIZE
    REAL(kind=8) :: abs0
    REAL(kind=8) :: abs1
    REAL(kind=8) :: abs2
! 判断是否为前5个面（通过第一个顶点坐标匹配）!!!!!!!!
    is_in_first5 = .false.
    current_face_id = 0
    DO f=1,5
      IF (points(1, 1) - first5_refs(f, 1) .GE. 0.) THEN
        abs0 = points(1, 1) - first5_refs(f, 1)
      ELSE
        abs0 = -(points(1, 1)-first5_refs(f, 1))
      END IF
      IF (points(1, 2) - first5_refs(f, 2) .GE. 0.) THEN
        abs1 = points(1, 2) - first5_refs(f, 2)
      ELSE
        abs1 = -(points(1, 2)-first5_refs(f, 2))
      END IF
      IF (points(1, 3) - first5_refs(f, 3) .GE. 0.) THEN
        abs2 = points(1, 3) - first5_refs(f, 3)
      ELSE
        abs2 = -(points(1, 3)-first5_refs(f, 3))
      END IF
! 允许微小数值误差（1e-6）
      IF (abs0 .LT. 1d-6 .AND. abs1 .LT. 1d-6 .AND. abs2 .LT. 1d-6) THEN
        is_in_first5 = .true.
        current_face_id = f
        GOTO 100
      END IF
    END DO
! 得到整个面的几何中心
 100 CALL GEOMETRICCENTER(points, gc)
    npts = SIZE(points, 1)
! 初始化面面积向量
    favec = (/0.0d0, 0.0d0, 0.0d0/)
! 初始化面中心        
    centroid = (/0.0d0, 0.0d0, 0.0d0/)
! 仅当处理第1个面时才输出
!!!!!!!!!!!!!!!
    print_output = f .EQ. 1
! 将多边形面分割成多个由几何中心和两个相邻顶点组成的三角形!!!!!!!!!!!!!!!!!!!!
    DO i=1,npts
      IF (i .LT. npts) THEN
        subtripts(1, :) = gc
        subtripts(2, :) = points(i, :)
        subtripts(3, :) = points(i+1, :)
      ELSE
        subtripts(1, :) = gc
        subtripts(2, :) = points(i, :)
! 闭合面
        subtripts(3, :) = points(1, :)
      END IF
!subTriPts没问题
! 子三角形中心
      CALL TRIANGLECENTROID(subtripts, tricentroid)
! 子三角形面积向量
      CALL TRIANGLEAREA(subtripts, subfavec)
! 前5个面输出subFAVec
      IF (is_in_first5) THEN
        PRINT*, '=== 第', current_face_id, '个面的子三角形 ', i&
&       , ' ==='
        PRINT*, '  subFAVec (x,y,z): (', subfavec(1), ',', subfavec(2), &
&       ',', subfavec(3), ')'
! 面积大小（标量）
        PRINT*, '  面积大小: ', mag_subfavec
      END IF
      favec = favec + subfavec
! 计算 subFAVec 模长	
      CALL MAG(subfavec, mag_subfavec)
      centroid = centroid + tricentroid*mag_subfavec
    END DO
! 计算 fAVec 模长
    CALL MAG(favec, mag_favec)
! 用临时变   ! 总质心为加权平均
    centroid = centroid/mag_favec
    IF (is_in_first5) PRINT*, 'centroid=', centroid
  END SUBROUTINE FACEAREACENTROID

!  Differentiation of cellvolcentroid in forward (tangent) mode (with options i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4):
!   variations   of useful results: centroid vol
!   with respect to varying inputs: facecentroids favecs
! 原调用处:cVols[c], cCenters[c] = cellVolCentroid(pts, cell_fAVecs, fCs),fCs为一个单元中各个面的几何中心,cell_
!fAVecs为这个包对应面的法向量
! 计算单元体积和中心位置!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  SUBROUTINE CELLVOLCENTROID_D(points, favecs, favecsd, facecentroids, &
&   facecentroidsd, vol, vold, centroid, centroidd)
    IMPLICIT NONE
! 假设输入数组维度：
! points: (nPoints, 3)  单元所有顶点坐标
! fAVecs: (nFaces, 3)   每个面的面积向量（每行一个面）
! faceCentroids: (nFaces, 3) 每个面的中心（每行一个面）
    REAL(kind=8), INTENT(IN) :: points(:, :), favecs(:, :), &
&   facecentroids(:, :)
    REAL(kind=8), INTENT(IN) :: favecsd(:, :), facecentroidsd(:, :)
    REAL(kind=8), INTENT(OUT) :: vol, centroid(3)
    REAL(kind=8), INTENT(OUT) :: vold, centroidd(3)
    REAL(kind=8) :: gc(3), cellcentervec(3), subpyrvol, subpyrcentroid(3&
&   ), dott
    REAL(kind=8) :: cellcentervecd(3), subpyrvold, subpyrcentroidd(3), &
&   dottd
    INTEGER(kind=8) :: nfaces, f
    INTRINSIC SIZE
    INTRINSIC ABS
    REAL(kind=8) :: abs0
    REAL(kind=8) :: abs0d
! 计算单元几何中心（确保与Julia的geometricCenter逻辑一致）
    CALL GEOMETRICCENTER(points, gc)
! 关键修正：正确获取面数（若fAVecs是(nFaces,3)，则用size(fAVecs,1)）
! 若fAVecs是(3,nFaces)，则改为 nFaces = size(fAVecs, 2)
    nfaces = SIZE(favecs, 1)
    vol = 0.0d0
    centroid = (/0.0d0, 0.0d0, 0.0d0/)
    centroidd = 0.0_8
    vold = 0.0_8
    DO f=1,nfaces
! 计算面中心到单元几何中心的向量（修正数组访问）
! 若faceCentroids是(3,nFaces)，则用faceCentroids(:,f)
      cellcentervecd = facecentroidsd(f, :)
      cellcentervec = facecentroids(f, :) - gc
      CALL DOT_PRODUCT_REAL_D(favecs(f, :), favecsd(f, :), cellcentervec&
&                       , cellcentervecd, dott, dottd, 3)
      IF (dott .GE. 0.) THEN
        abs0d = dottd
        abs0 = dott
      ELSE
        abs0d = -dottd
        abs0 = -dott
      END IF
! 计算子金字塔体积（点积+绝对值）
      subpyrvold = abs0d/3.0d0
      subpyrvol = abs0/3.0d0
! 改用dot_product确保点积计算正确（与Julia的sum(.+)一致）
! 计算子金字塔中心
      subpyrcentroidd = 0.75d0*facecentroidsd(f, :)
      subpyrcentroid = 0.75d0*facecentroids(f, :) + 0.25d0*gc
! 累加体积和中心
      vold = vold + subpyrvold
      vol = vol + subpyrvol
      centroidd = centroidd + subpyrvol*subpyrcentroidd + subpyrcentroid&
&       *subpyrvold
      centroid = centroid + subpyrcentroid*subpyrvol
    END DO
    centroidd = centroidd/vol-centroid*vold/(vol*vol)
    centroid = centroid/vol
  END SUBROUTINE CELLVOLCENTROID_D

! 原调用处:cVols[c], cCenters[c] = cellVolCentroid(pts, cell_fAVecs, fCs),fCs为一个单元中各个面的几何中心,cell_
!fAVecs为这个包对应面的法向量
! 计算单元体积和中心位置!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  SUBROUTINE CELLVOLCENTROID(points, favecs, facecentroids, vol, &
&   centroid)
    IMPLICIT NONE
! 假设输入数组维度：
! points: (nPoints, 3)  单元所有顶点坐标
! fAVecs: (nFaces, 3)   每个面的面积向量（每行一个面）
! faceCentroids: (nFaces, 3) 每个面的中心（每行一个面）
    REAL(kind=8), INTENT(IN) :: points(:, :), favecs(:, :), &
&   facecentroids(:, :)
    REAL(kind=8), INTENT(OUT) :: vol, centroid(3)
    REAL(kind=8) :: gc(3), cellcentervec(3), subpyrvol, subpyrcentroid(3&
&   ), dott
    INTEGER(kind=8) :: nfaces, f
    INTRINSIC SIZE
    INTRINSIC ABS
    REAL(kind=8) :: abs0
! 计算单元几何中心（确保与Julia的geometricCenter逻辑一致）
    CALL GEOMETRICCENTER(points, gc)
! 关键修正：正确获取面数（若fAVecs是(nFaces,3)，则用size(fAVecs,1)）
! 若fAVecs是(3,nFaces)，则改为 nFaces = size(fAVecs, 2)
    nfaces = SIZE(favecs, 1)
    vol = 0.0d0
    centroid = (/0.0d0, 0.0d0, 0.0d0/)
    DO f=1,nfaces
! 计算面中心到单元几何中心的向量（修正数组访问）
! 若faceCentroids是(3,nFaces)，则用faceCentroids(:,f)
      cellcentervec = facecentroids(f, :) - gc
      CALL DOT_PRODUCT_REAL(favecs(f, :), cellcentervec, dott, 3)
      IF (dott .GE. 0.) THEN
        abs0 = dott
      ELSE
        abs0 = -dott
      END IF
! 计算子金字塔体积（点积+绝对值）
      subpyrvol = abs0/3.0d0
! 改用dot_product确保点积计算正确（与Julia的sum(.+)一致）
! 计算子金字塔中心
      subpyrcentroid = 0.75d0*facecentroids(f, :) + 0.25d0*gc
! 累加体积和中心
      vol = vol + subpyrvol
      centroid = centroid + subpyrcentroid*subpyrvol
    END DO
    centroid = centroid/vol
  END SUBROUTINE CELLVOLCENTROID

! 计算每个面从其所属单元中心指向面中心的向量!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  SUBROUTINE CELLCENTROIDTOFACEVEC(facecentroids, cellcentroids, &
&   cellcentroidtofacevecc)
    IMPLICIT NONE
    REAL(kind=8), INTENT(IN) :: facecentroids(:, :), cellcentroids(3)
    REAL(kind=8), INTENT(OUT) :: cellcentroidtofacevecc(SIZE(&
&   facecentroids, 1), 3)
    INTEGER(kind=8) :: nfaces, f
    INTRINSIC SIZE
    nfaces = SIZE(facecentroids, 1)
    DO f=1,nfaces
! 注意：cellCentroids 应是单个中心点？
      cellcentroidtofacevecc(f, :) = facecentroids(f, :) - cellcentroids
    END DO
  END SUBROUTINE CELLCENTROIDTOFACEVEC

! ######################### 工具函数 ###########################
! 返回网格的基本信息，包括单元数、面数、边界数量、边界面数!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  SUBROUTINE UNSTRUCTUREDMESHINFO(mesh, info)
    IMPLICIT NONE
! 输入网格对象（与Julia的Mesh对应）
    TYPE(MESHH), INTENT(IN) :: mesh
! 返回数组：[nCells, nFaces, nBoundaries, nBdryFaces]
    INTEGER(kind=8), INTENT(OUT) :: info(4)
    INTEGER(kind=8) :: ncells, nfaces, nboundaries, nbdryfaces
! 循环变量（边界索引）
    INTEGER(kind=8) :: bdry, countt, i
    INTRINSIC SIZE
! 计算单元总数（网格单元的行数）
    ncells = SIZE(mesh%cells, 1)
! 计算面总数（网格面的行数）
    nfaces = SIZE(mesh%faces, 1)
! 计算边界总数（边界面的行数）
    nboundaries = SIZE(mesh%boundaryfaces, 1)
! 统计边界面总数（累加每个边界的面数量）
! 正确计算边界面数（忽略填充的0）
    nbdryfaces = 0
    DO bdry=1,nboundaries
! 统计当前边界的非零元素个数
      i = 0
      DO WHILE (i .LT. SIZE(mesh%boundaryfaces, 2) .AND. mesh%&
&               boundaryfaces(bdry, i+1) .NE. 0)
        i = i + 1
      END DO
      nbdryfaces = nbdryfaces + i
    END DO
! 赋值返回结果（保持与Julia相同的顺序）
    info = (/ncells, nfaces, nboundaries, nbdryfaces/)
  END SUBROUTINE UNSTRUCTUREDMESHINFO

!  Differentiation of openfoammesh in forward (tangent) mode (with options i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4):
!   variations   of useful results: [alloc*(mesh.ccenters) in openfoammesh]
!                [alloc*(mesh.cvols) in openfoammesh] [alloc*(mesh.fcenters) in openfoammesh]
!                [alloc*(mesh.favecs) in openfoammesh]
!   with respect to varying inputs: [alloc*point_update in airfoil_deformation_hh]
!   Plus diff mem management of: point_update:in mesh.cvols:out
!                mesh.ccenters:out mesh.favecs:out mesh.fcenters:out
! 核心函数：读取并处理OpenFOAM网格
  SUBROUTINE OPENFOAMMESH_D(polymeshpath, point_update, point_updated, &
&   mesh, meshd)
    IMPLICIT NONE
    CHARACTER(len=*), INTENT(IN) :: polymeshpath
! 输入：变形网格点
    REAL*8, ALLOCATABLE, INTENT(IN) :: point_update(:, :)
    REAL*8, ALLOCATABLE, INTENT(IN) :: point_updated(:, :)
    TYPE(MESHH), INTENT(OUT) :: mesh
    TYPE(MESHH_DIFF), INTENT(OUT) :: meshd
    TYPE(MESHDATA) :: tempmesh
    TYPE(MESHDATA_DIFF) :: tempmeshd
    INTEGER(kind=8) :: ncells, nfaces, nboundaries, npoints
    INTEGER(kind=8) :: f, c, b, i, j, k, startf, endf, facecount, &
&   max_faces_per_cell, j_max
    INTEGER(kind=8), ALLOCATABLE :: cellfacecount(:)
    REAL(kind=8), ALLOCATABLE :: facepts(:, :)
    REAL(kind=8), ALLOCATABLE :: faceptsd(:, :)
    REAL(kind=8) :: maxcoords(3), mincoords(3)
    REAL(kind=8), ALLOCATABLE :: cellpts(:, :), fcs(:, :), cell_favecs(:&
&   , :)
    REAL(kind=8), ALLOCATABLE :: fcsd(:, :), cell_favecsd(:, :)
! 形状(5,3)!!!!!!!!!!!!
    REAL(kind=8), ALLOCATABLE :: first5_refs(:, :)
!!!!!!!!!!!!!!!!!!!!!!!!!!
    INTEGER(kind=8), ALLOCATABLE :: f_list(:)
    INTEGER(kind=8) :: new_size
    REAL(kind=8), ALLOCATABLE :: temp_cellpts(:, :)
    REAL(kind=8), ALLOCATABLE :: temp_cellptsd(:, :)
    INTEGER(kind=8) :: pt_id
    LOGICAL :: isinarrayy
    INTRINSIC SIZE
    INTRINSIC MAXVAL
    INTRINSIC ALLOCATED
    INTRINSIC INT
    INTRINSIC MOVE_ALLOC
    INTRINSIC MIN
    INTRINSIC HUGE
    INTRINSIC MAX
    INTEGER :: y1
    INTEGER :: y2
    INTEGER :: y3
    INTEGER(kind=8) :: min1
    INTEGER(kind=8) :: min2
    INTEGER(kind=8) :: min3
    INTEGER(kind=8) :: min4
    INTEGER(kind=8) :: min5
    INTEGER :: min6
    INTEGER :: min7
    INTEGER :: min8
    ALLOCATE(first5_refs(5, 3), source=0.0d0)
!!!!!!!!!!
    first5_refs = 0.0d0
    PRINT*, 'Reading mesh: ', polymeshpath
    CALL READOPENFOAMMESH_D(polymeshpath, point_update, point_updated, &
&                     tempmesh, tempmeshd)
    PRINT*, 'b3'
    npoints = SIZE(tempmesh%points, 1)
    nfaces = SIZE(tempmesh%owner)
    ncells = MAXVAL(tempmesh%owner)
    nboundaries = SIZE(tempmesh%boundarynames)
    ALLOCATE(mesh%faces(nfaces, 2), source=0_8)
    ALLOCATE(meshd%favecs(nfaces, 3), source=0.0d0)
    ALLOCATE(mesh%favecs(nfaces, 3), source=0.0d0)
    ALLOCATE(meshd%fcenters(nfaces, 3), source=0.0d0)
    ALLOCATE(mesh%fcenters(nfaces, 3), source=0.0d0)
    ALLOCATE(cellfacecount(ncells), source=0_8)
    cellfacecount = 0
    DO f=1,nfaces
      cellfacecount(tempmesh%owner(f)) = cellfacecount(tempmesh%owner(f)&
&       ) + 1
      IF (ALLOCATED(tempmesh%neighbour) .AND. f .LE. SIZE(tempmesh%&
&         neighbour)) cellfacecount(tempmesh%neighbour(f)) = &
&         cellfacecount(tempmesh%neighbour(f)) + 1
    END DO
    max_faces_per_cell = MAXVAL(cellfacecount)
    ALLOCATE(mesh%cells(ncells, max_faces_per_cell))
    mesh%cells = 0
    ALLOCATE(meshd%cvols(ncells))
    ALLOCATE(mesh%cvols(ncells))
    ALLOCATE(meshd%ccenters(ncells, 3))
    ALLOCATE(mesh%ccenters(ncells, 3))
    ALLOCATE(mesh%cellsizes(ncells, 3))
! 计算每个面的面积向量和几何中心
    DO f=1,nfaces
      ALLOCATE(faceptsd(SIZE(tempmesh%faces%faces(f)%points), 3), source=0.0d0)
      faceptsd = 0.0_8
      ALLOCATE(facepts(SIZE(tempmesh%faces%faces(f)%points), 3), source=0.0d0)
      DO i=1,SIZE(tempmesh%faces%faces(f)%points)
        pt_id = INT(tempmesh%faces%faces(f)%points(i))
        faceptsd(i, :) = tempmeshd%points(pt_id, :)
        facepts(i, :) = tempmesh%points(pt_id, :)
      END DO
!!!!!!!!!!!!!!!!
! 保存前5个面的第一个顶点坐标作为参考!!!!!!
      IF (f .LE. 5) first5_refs(f, :) = facepts(1, :)
! 调用面计算子程序，传递前5个面的参考特征
!!!!!!!
      CALL FACEAREACENTROID_D(facepts, faceptsd, first5_refs, mesh%&
&                       favecs(f, :), meshd%favecs(f, :), mesh%fcenters(&
&                       f, :), meshd%fcenters(f, :))
!call faceAreaCentroid(facePts, mesh%fAVecs(f,:), mesh%fCenters(f,:))
      IF (ALLOCATED(faceptsd)) THEN
        DEALLOCATE(faceptsd)
      END IF
      DEALLOCATE(facepts)
    END DO
    DEALLOCATE(first5_refs)
!!!!!!!!!!!!!
    cellfacecount = 0
    DO f=1,nfaces
      c = tempmesh%owner(f)
      cellfacecount(c) = cellfacecount(c) + 1
      mesh%cells(c, cellfacecount(c)) = f
      mesh%faces(f, 1) = c
      mesh%faces(f, 2) = -1
      IF (ALLOCATED(tempmesh%neighbour) .AND. f .LE. SIZE(tempmesh%&
&         neighbour)) THEN
        c = tempmesh%neighbour(f)
        cellfacecount(c) = cellfacecount(c) + 1
        mesh%cells(c, cellfacecount(c)) = f
        mesh%faces(f, 2) = c
      END IF
    END DO
    DEALLOCATE(cellfacecount)
! 对每个单元，利用其所有面的信息计算体积和中心
    DO c=1,ncells
      facecount = 0
      DO i=1,SIZE(mesh%cells, 2)
        IF (mesh%cells(c, i) .EQ. 0) THEN
          EXIT
        ELSE
          facecount = facecount + 1
        END IF
      END DO
      ALLOCATE(fcsd(facecount, 3), source=0.0d0)
      fcsd = 0.0_8
      ALLOCATE(fcs(facecount, 3), source=0.0d0)
      ALLOCATE(cell_favecsd(facecount, 3), source=0.0d0)
      cell_favecsd = 0.0_8
      ALLOCATE(cell_favecs(facecount, 3), source=0.0d0)
      ALLOCATE(cellpts(0, 3), source=0.0d0)
      DO i=1,facecount
        f = mesh%cells(c, i)
        fcsd(i, :) = meshd%fcenters(f, :)
        fcs(i, :) = mesh%fcenters(f, :)
        cell_favecsd(i, :) = meshd%favecs(f, :)
        cell_favecs(i, :) = mesh%favecs(f, :)
        DO j=1,SIZE(tempmesh%faces%faces(f)%points)
          pt_id = INT(tempmesh%faces%faces(f)%points(j))
          CALL ISINARRAY(cellpts, tempmesh%points(pt_id, :), isinarrayy)
          IF (.NOT.isinarrayy) THEN
! 调用子routine生成扩展后的数组
            CALL EXTEND_ARRAY_D(cellpts, tempmesh%points(pt_id, :), &
&                         temp_cellpts, temp_cellptsd)
! 转移内存（显式触发Tapenade对微分变量的同步处理）
            CALL MOVE_ALLOC(temp_cellpts, cellpts)
          END IF
        END DO
      END DO
! 仅输出前两个单元的信息
      IF (c .LE. 2) THEN
        ALLOCATE(f_list(facecount), source=0_8)
        DO i=1,facecount
          f_list(i) = mesh%cells(c, i)
        END DO
! 输出单元包含的面索引（前2个）
        PRINT*, '包含的面索引（前2个）: ['
        IF (6 .GT. facecount) THEN
          min1 = facecount
        ELSE
          min1 = 6
        END IF
        DO i=1,min1
          IF (i .GT. 1) THEN
! 元素间加逗号
            PRINT '(A)', ', '
          END IF
! 逐个输出整数
          PRINT '(I0)', f_list(i)
        END DO
! 闭合括号
        PRINT*, ']'
        IF (2 .GT. facecount) THEN
          min2 = facecount
        ELSE
          min2 = 2
        END IF
! 对每个面，输出其包含的顶点ID（前3个）
        DO i=1,min2
! 面索引
          f = f_list(i)
          j_max = SIZE(tempmesh%faces%faces(f)%points)
! 先输出前缀
          PRINT '(A, I0, A)', '  面', f, '的顶点ID（前3个）: ['
          IF (4 .GT. j_max) THEN
            min3 = j_max
          ELSE
            min3 = 4
          END IF
! 逐个输出顶点ID（前3个）
          DO j=1,min3
            IF (j .GT. 1) THEN
! 元素间加逗号（不换行）
              WRITE(*, '(A)', advance='no') ', '
            END IF
! 输出单个顶点ID（不换行）
            WRITE(*, '(I0)', advance='no') tempmesh%faces%faces(f)%&
&           points(j)
          END DO
! 闭合括号（换行）
          PRINT*, ']'
        END DO
        DEALLOCATE(f_list)
        PRINT*, ' '
        PRINT*, '=== 单元 ', c, ' 输入检验 ==='
! 前4个顶点坐标
        PRINT*, '全部顶点坐标：'
! 循环所有顶点（取消min限制）
        DO k=1,SIZE(cellpts, 1)
          PRINT '(A, I0, A, F0.6, A, F0.6, A, F0.6, A)', '  顶点', k, &
&         ': (', cellpts(k, 1), ', ', cellpts(k, 2), ', ', cellpts(k, 3)&
&         , ')'
        END DO
! 前4个面中心
        PRINT*, '前4个面中心：'
        IF (6 .GT. facecount) THEN
          min4 = facecount
        ELSE
          min4 = 6
        END IF
        DO k=1,min4
          PRINT '(A, I0, A, F0.6, A, F0.6, A, F0.6, A)', '  面', k, &
&         ': (', fcs(k, 1), ', ', fcs(k, 2), ', ', fcs(k, 3), ')'
        END DO
! 前4个面面积向量
        PRINT*, '前4个面面积向量：'
        IF (6 .GT. facecount) THEN
          min5 = facecount
        ELSE
          min5 = 6
        END IF
        DO k=1,min5
          PRINT '(A, I0, A, F0.6, A, F0.6, A, F0.6, A)', '  面', k, &
&         '面积向量: (', cell_favecs(k, 1), ', ', cell_favecs(k, 2)&
&         , ', ', cell_favecs(k, 3), ')'
        END DO
      END IF
! 新增：结束前5个单元的判
! 仅对前5个单元输出输入变量的前5行
      IF (c .LE. 5) THEN
! 新增：限制仅前5个单元执行以下输出
! 1. 输出输入变量cellPts（当前单元的前5行顶点坐标）
        PRINT*, '调用cellVolCentroid前 - 单元', c, &
&       '的输入cellPts（前5行）：'
        y1 = SIZE(cellpts, 1)
        IF (5 .GT. y1) THEN
          min6 = y1
        ELSE
          min6 = 5
        END IF
! 每个单元内最多输出5行
        DO k=1,min6
          PRINT '(A, I0, A, F0.6, A, F0.6, A, F0.6)', '  第', k, &
&         '行: (', cellpts(k, 1), ', ', cellpts(k, 2), ', ', cellpts(k&
&         , 3)
        END DO
! 2. 输出输入变量cell_fAVecs（当前单元的前5行面面积向量）
        PRINT*, '调用cellVolCentroid前 - 单元', c, &
&       '的输入cell_fAVecs（前5行）：'
        y2 = SIZE(cell_favecs, 1)
        IF (5 .GT. y2) THEN
          min7 = y2
        ELSE
          min7 = 5
        END IF
        DO k=1,min7
          PRINT '(A, I0, A, F0.6, A, F0.6, A, F0.6)', '  第', k, &
&         '行: (', cell_favecs(k, 1), ', ', cell_favecs(k, 2), ', ', &
&         cell_favecs(k, 3)
        END DO
! 3. 输出输入变量fCs（当前单元的前5行面中心坐标）
        PRINT*, '调用cellVolCentroid前 - 单元', c, &
&       '的输入fCs（前5行）：'
        y3 = SIZE(fcs, 1)
        IF (5 .GT. y3) THEN
          min8 = y3
        ELSE
          min8 = 5
        END IF
        DO k=1,min8
          PRINT '(A, I0, A, F0.6, A, F0.6, A, F0.6)', '  第', k, &
&         '行: (', fcs(k, 1), ', ', fcs(k, 2), ', ', fcs(k, 3)
        END DO
! 可选：分隔不同单元的输入信息
        PRINT*, '----------------------------------------'
      END IF
      CALL CELLVOLCENTROID_D(cellpts, cell_favecs, cell_favecsd, fcs, &
&                      fcsd, mesh%cvols(c), meshd%cvols(c), mesh%&
&                      ccenters(c, :), meshd%ccenters(c, :))

      DEALLOCATE(cellpts)
      IF (ALLOCATED(fcsd)) THEN
        DEALLOCATE(fcsd)
      END IF
      DEALLOCATE(fcs)
      IF (ALLOCATED(cell_favecsd)) THEN
        DEALLOCATE(cell_favecsd)
      END IF
      DEALLOCATE(cell_favecs)
    END DO
! 生成 boundaryFaces 数组
! 恢复原始分配方式
! 生成 boundaryFaces 数组时，先全部初始化为0
    ALLOCATE(mesh%boundaryfaces(nboundaries, MAXVAL(tempmesh%&
&   boundarynumfaces)), source=0_8)
! 关键：将所有元素初始化为0
    mesh%boundaryfaces = 0
    DO b=1,nboundaries
      startf = tempmesh%boundarystartfaces(b)
      endf = startf + tempmesh%boundarynumfaces(b) - 1
      DO f=startf,endf
! 填充有效面索引（无效位置保持0）
        mesh%boundaryfaces(b, f-startf+1) = f
      END DO
    END DO
! 计算每个单元在 x、y、z 方向上的尺寸（用边界包围盒法）
    DO c=1,ncells
      maxcoords = -HUGE(1.0_real64)
      mincoords = HUGE(1.0_real64)
      DO i=1,SIZE(mesh%cells, 2)
        f = mesh%cells(c, i)
        IF (f .EQ. 0) THEN
          EXIT
        ELSE
          DO j=1,SIZE(tempmesh%faces%faces(f)%points)
            pt_id = tempmesh%faces%faces(f)%points(j)
            DO k=1,3
              IF (maxcoords(k) .LT. tempmesh%points(pt_id, k)) THEN
                maxcoords(k) = tempmesh%points(pt_id, k)
              ELSE
                maxcoords(k) = maxcoords(k)
              END IF
              IF (mincoords(k) .GT. tempmesh%points(pt_id, k)) THEN
                mincoords(k) = tempmesh%points(pt_id, k)
              ELSE
                mincoords(k) = mincoords(k)
              END IF
            END DO
          END DO
        END IF
      END DO
      mesh%cellsizes(c, :) = maxcoords - mincoords
    END DO
    CALL DEALLOCATEMESHDATA_D(tempmesh, tempmeshd)
  END SUBROUTINE OPENFOAMMESH_D

! 核心函数：读取并处理OpenFOAM网格
  SUBROUTINE OPENFOAMMESH(polymeshpath, point_update, mesh)
    IMPLICIT NONE
    CHARACTER(len=*), INTENT(IN) :: polymeshpath
! 输入：变形网格点
    REAL*8, ALLOCATABLE, INTENT(IN) :: point_update(:, :)
    TYPE(MESHH), INTENT(OUT) :: mesh
    TYPE(MESHDATA) :: tempmesh
    INTEGER(kind=8) :: ncells, nfaces, nboundaries, npoints
    INTEGER(kind=8) :: f, c, b, i, j, k, startf, endf, facecount, &
&   max_faces_per_cell, j_max
    INTEGER(kind=8), ALLOCATABLE :: cellfacecount(:)
    REAL(kind=8), ALLOCATABLE :: facepts(:, :)
    REAL(kind=8) :: maxcoords(3), mincoords(3)
    REAL(kind=8), ALLOCATABLE :: cellpts(:, :), fcs(:, :), cell_favecs(:&
&   , :)
! 形状(5,3)!!!!!!!!!!!!
    REAL(kind=8), ALLOCATABLE :: first5_refs(:, :)
!!!!!!!!!!!!!!!!!!!!!!!!!!
    INTEGER(kind=8), ALLOCATABLE :: f_list(:)
    INTEGER(kind=8) :: new_size
    REAL(kind=8), ALLOCATABLE :: temp_cellpts(:, :)
    INTEGER(kind=8) :: pt_id
    LOGICAL :: isinarrayy
    INTRINSIC SIZE
    INTRINSIC MAXVAL
    INTRINSIC ALLOCATED
    INTRINSIC INT
    INTRINSIC MOVE_ALLOC
    INTRINSIC MIN
    INTRINSIC HUGE
    INTRINSIC MAX
    INTEGER :: y1
    INTEGER :: y2
    INTEGER :: y3
    INTEGER(kind=8) :: min1
    INTEGER(kind=8) :: min2
    INTEGER(kind=8) :: min3
    INTEGER(kind=8) :: min4
    INTEGER(kind=8) :: min5
    INTEGER :: min6
    INTEGER :: min7
    INTEGER :: min8
    ALLOCATE(first5_refs(5, 3), source=0.0d0)
!!!!!!!!!!
    first5_refs = 0.0d0
    PRINT*, 'Reading mesh: ', polymeshpath
    CALL READOPENFOAMMESH(polymeshpath, point_update, tempmesh)
    PRINT*, 'b3'
    npoints = SIZE(tempmesh%points, 1)
    nfaces = SIZE(tempmesh%owner)
    ncells = MAXVAL(tempmesh%owner)
    nboundaries = SIZE(tempmesh%boundarynames)
    ALLOCATE(mesh%faces(nfaces, 2), source=0_8)
    ALLOCATE(mesh%favecs(nfaces, 3), source=0.0d0)
    ALLOCATE(mesh%fcenters(nfaces, 3), source=0.0d0)
    ALLOCATE(cellfacecount(ncells), source=0_8)
    cellfacecount = 0
    DO f=1,nfaces
      cellfacecount(tempmesh%owner(f)) = cellfacecount(tempmesh%owner(f)&
&       ) + 1
      IF (ALLOCATED(tempmesh%neighbour) .AND. f .LE. SIZE(tempmesh%&
&         neighbour)) cellfacecount(tempmesh%neighbour(f)) = &
&         cellfacecount(tempmesh%neighbour(f)) + 1
    END DO
    max_faces_per_cell = MAXVAL(cellfacecount)
    ALLOCATE(mesh%cells(ncells, max_faces_per_cell), source=0_8)
    mesh%cells = 0
    ALLOCATE(mesh%cvols(ncells), source=0.0d0)
    ALLOCATE(mesh%ccenters(ncells, 3), source=0.0d0)
    ALLOCATE(mesh%cellsizes(ncells, 3), source=0.0d0)
! 计算每个面的面积向量和几何中心
    DO f=1,nfaces
      ALLOCATE(facepts(SIZE(tempmesh%faces%faces(f)%points), 3), source=0.0d0)
      DO i=1,SIZE(tempmesh%faces%faces(f)%points)
        pt_id = INT(tempmesh%faces%faces(f)%points(i))
        facepts(i, :) = tempmesh%points(pt_id, :)
      END DO
!!!!!!!!!!!!!!!!
! 保存前5个面的第一个顶点坐标作为参考!!!!!!
      IF (f .LE. 5) first5_refs(f, :) = facepts(1, :)
! 调用面计算子程序，传递前5个面的参考特征
!!!!!!!
      CALL FACEAREACENTROID(facepts, first5_refs, mesh%favecs(f, :), &
&                     mesh%fcenters(f, :))
!call faceAreaCentroid(facePts, mesh%fAVecs(f,:), mesh%fCenters(f,:))
      DEALLOCATE(facepts)
    END DO
    DEALLOCATE(first5_refs)
!!!!!!!!!!!!!
    cellfacecount = 0
    DO f=1,nfaces
      c = tempmesh%owner(f)
      cellfacecount(c) = cellfacecount(c) + 1
      mesh%cells(c, cellfacecount(c)) = f
      mesh%faces(f, 1) = c
      mesh%faces(f, 2) = -1
      IF (ALLOCATED(tempmesh%neighbour) .AND. f .LE. SIZE(tempmesh%&
&         neighbour)) THEN
        c = tempmesh%neighbour(f)
        cellfacecount(c) = cellfacecount(c) + 1
        mesh%cells(c, cellfacecount(c)) = f
        mesh%faces(f, 2) = c
      END IF
    END DO
    DEALLOCATE(cellfacecount)
! 对每个单元，利用其所有面的信息计算体积和中心
    DO c=1,ncells
      facecount = 0
      DO i=1,SIZE(mesh%cells, 2)
        IF (mesh%cells(c, i) .EQ. 0) THEN
          GOTO 100
        ELSE
          facecount = facecount + 1
        END IF
      END DO
 100  ALLOCATE(fcs(facecount, 3), source=0.0d0)
      ALLOCATE(cell_favecs(facecount, 3), source=0.0d0)
      ALLOCATE(cellpts(0, 3), source=0.0d0)
      DO i=1,facecount
        f = mesh%cells(c, i)
        fcs(i, :) = mesh%fcenters(f, :)
        cell_favecs(i, :) = mesh%favecs(f, :)
        DO j=1,SIZE(tempmesh%faces%faces(f)%points)
          pt_id = INT(tempmesh%faces%faces(f)%points(j))
          CALL ISINARRAY(cellpts, tempmesh%points(pt_id, :), isinarrayy)
          IF (.NOT.isinarrayy) THEN
! 调用子routine生成扩展后的数组
            CALL EXTEND_ARRAY(cellpts, tempmesh%points(pt_id, :), &
&                       temp_cellpts)
! 转移内存（显式触发Tapenade对微分变量的同步处理）
            CALL MOVE_ALLOC(temp_cellpts, cellpts)
          END IF
        END DO
      END DO
! 仅输出前两个单元的信息
      IF (c .LE. 2) THEN
        ALLOCATE(f_list(facecount), source=0_8)
        DO i=1,facecount
          f_list(i) = mesh%cells(c, i)
        END DO
! 输出单元包含的面索引（前2个）
        PRINT*, '包含的面索引（前2个）: ['
        IF (6 .GT. facecount) THEN
          min1 = facecount
        ELSE
          min1 = 6
        END IF
        DO i=1,min1
          IF (i .GT. 1) THEN
! 元素间加逗号
            PRINT '(A)', ', '
          END IF
! 逐个输出整数
          PRINT '(I0)', f_list(i)
        END DO
! 闭合括号
        PRINT*, ']'
        IF (2 .GT. facecount) THEN
          min2 = facecount
        ELSE
          min2 = 2
        END IF
! 对每个面，输出其包含的顶点ID（前3个）
        DO i=1,min2
! 面索引
          f = f_list(i)
          j_max = SIZE(tempmesh%faces%faces(f)%points)
! 先输出前缀
          PRINT '(A, I0, A)', '  面', f, '的顶点ID（前3个）: ['
          IF (4 .GT. j_max) THEN
            min3 = j_max
          ELSE
            min3 = 4
          END IF
! 逐个输出顶点ID（前3个）
          DO j=1,min3
            IF (j .GT. 1) THEN
! 元素间加逗号（不换行）
              WRITE(*, '(A)', advance='no') ', '
            END IF
! 输出单个顶点ID（不换行）
            WRITE(*, '(I0)', advance='no') tempmesh%faces%faces(f)%&
&           points(j)
          END DO
! 闭合括号（换行）
          PRINT*, ']'
        END DO
        DEALLOCATE(f_list)
        PRINT*, ' '
        PRINT*, '=== 单元 ', c, ' 输入检验 ==='
! 前4个顶点坐标
        PRINT*, '全部顶点坐标：'
! 循环所有顶点（取消min限制）
        DO k=1,SIZE(cellpts, 1)
          PRINT '(A, I0, A, F0.6, A, F0.6, A, F0.6, A)', '  顶点', k, &
&         ': (', cellpts(k, 1), ', ', cellpts(k, 2), ', ', cellpts(k, 3)&
&         , ')'
        END DO
! 前4个面中心
        PRINT*, '前4个面中心：'
        IF (6 .GT. facecount) THEN
          min4 = facecount
        ELSE
          min4 = 6
        END IF
        DO k=1,min4
          PRINT '(A, I0, A, F0.6, A, F0.6, A, F0.6, A)', '  面', k, &
&         ': (', fcs(k, 1), ', ', fcs(k, 2), ', ', fcs(k, 3), ')'
        END DO
! 前4个面面积向量
        PRINT*, '前4个面面积向量：'
        IF (6 .GT. facecount) THEN
          min5 = facecount
        ELSE
          min5 = 6
        END IF
        DO k=1,min5
          PRINT '(A, I0, A, F0.6, A, F0.6, A, F0.6, A)', '  面', k, &
&         '面积向量: (', cell_favecs(k, 1), ', ', cell_favecs(k, 2)&
&         , ', ', cell_favecs(k, 3), ')'
        END DO
      END IF
! 新增：结束前5个单元的判
! 仅对前5个单元输出输入变量的前5行
      IF (c .LE. 5) THEN
! 新增：限制仅前5个单元执行以下输出
! 1. 输出输入变量cellPts（当前单元的前5行顶点坐标）
        PRINT*, '调用cellVolCentroid前 - 单元', c, &
&       '的输入cellPts（前5行）：'
        y1 = SIZE(cellpts, 1)
        IF (5 .GT. y1) THEN
          min6 = y1
        ELSE
          min6 = 5
        END IF
! 每个单元内最多输出5行
        DO k=1,min6
          PRINT '(A, I0, A, F0.6, A, F0.6, A, F0.6)', '  第', k, &
&         '行: (', cellpts(k, 1), ', ', cellpts(k, 2), ', ', cellpts(k&
&         , 3)
        END DO
! 2. 输出输入变量cell_fAVecs（当前单元的前5行面面积向量）
        PRINT*, '调用cellVolCentroid前 - 单元', c, &
&       '的输入cell_fAVecs（前5行）：'
        y2 = SIZE(cell_favecs, 1)
        IF (5 .GT. y2) THEN
          min7 = y2
        ELSE
          min7 = 5
        END IF
        DO k=1,min7
          PRINT '(A, I0, A, F0.6, A, F0.6, A, F0.6)', '  第', k, &
&         '行: (', cell_favecs(k, 1), ', ', cell_favecs(k, 2), ', ', &
&         cell_favecs(k, 3)
        END DO
! 3. 输出输入变量fCs（当前单元的前5行面中心坐标）
        PRINT*, '调用cellVolCentroid前 - 单元', c, &
&       '的输入fCs（前5行）：'
        y3 = SIZE(fcs, 1)
        IF (5 .GT. y3) THEN
          min8 = y3
        ELSE
          min8 = 5
        END IF
        DO k=1,min8
          PRINT '(A, I0, A, F0.6, A, F0.6, A, F0.6)', '  第', k, &
&         '行: (', fcs(k, 1), ', ', fcs(k, 2), ', ', fcs(k, 3)
        END DO
! 可选：分隔不同单元的输入信息
        PRINT*, '----------------------------------------'
      END IF
      CALL CELLVOLCENTROID(cellpts, cell_favecs, fcs, mesh%cvols(c), &
&                    mesh%ccenters(c, :))

      DEALLOCATE(cellpts)
      DEALLOCATE(fcs)
      DEALLOCATE(cell_favecs)
    END DO
! 生成 boundaryFaces 数组
! 恢复原始分配方式
! 生成 boundaryFaces 数组时，先全部初始化为0
    ALLOCATE(mesh%boundaryfaces(nboundaries, MAXVAL(tempmesh%&
&   boundarynumfaces)), source=0_8)
! 关键：将所有元素初始化为0
    mesh%boundaryfaces = 0
    DO b=1,nboundaries
      startf = tempmesh%boundarystartfaces(b)
      endf = startf + tempmesh%boundarynumfaces(b) - 1
      DO f=startf,endf
! 填充有效面索引（无效位置保持0）
        mesh%boundaryfaces(b, f-startf+1) = f
      END DO
    END DO
! 计算每个单元在 x、y、z 方向上的尺寸（用边界包围盒法）
    DO c=1,ncells
      maxcoords = -HUGE(1.0_real64)
      mincoords = HUGE(1.0_real64)
      DO i=1,SIZE(mesh%cells, 2)
        f = mesh%cells(c, i)
        IF (f .EQ. 0) THEN
          GOTO 110
        ELSE
          DO j=1,SIZE(tempmesh%faces%faces(f)%points)
            pt_id = tempmesh%faces%faces(f)%points(j)
            DO k=1,3
              IF (maxcoords(k) .LT. tempmesh%points(pt_id, k)) THEN
                maxcoords(k) = tempmesh%points(pt_id, k)
              ELSE
                maxcoords(k) = maxcoords(k)
              END IF
              IF (mincoords(k) .GT. tempmesh%points(pt_id, k)) THEN
                mincoords(k) = tempmesh%points(pt_id, k)
              ELSE
                mincoords(k) = mincoords(k)
              END IF
            END DO
          END DO
        END IF
      END DO
 110  mesh%cellsizes(c, :) = maxcoords - mincoords
    END DO
    CALL DEALLOCATEMESHDATA(tempmesh)
  END SUBROUTINE OPENFOAMMESH

!  Differentiation of extend_array in forward (tangent) mode (with options i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4):
!   Plus diff mem management of: new_arr:out
  SUBROUTINE EXTEND_ARRAY_D(old_arr, new_row, new_arr, new_arrd)
    IMPLICIT NONE
! 原数组
    REAL*8, ALLOCATABLE, INTENT(INOUT) :: old_arr(:, :)
! 新增行
    REAL*8, INTENT(IN) :: new_row(3)
! 扩展后数组
    REAL*8, ALLOCATABLE, INTENT(OUT) :: new_arr(:, :)
    REAL*8, ALLOCATABLE, INTENT(OUT) :: new_arrd(:, :)
    INTEGER(kind=8) :: new_size
    INTRINSIC ALLOCATED
    INTRINSIC SIZE
! 计算新尺寸
    IF (ALLOCATED(old_arr)) THEN
      new_size = SIZE(old_arr, 1) + 1
      ALLOCATE(new_arrd(new_size, 3), source=0.0d0)
      ALLOCATE(new_arr(new_size, 3), source=0.0d0)
! 复制旧数据
      new_arr(1:new_size-1, :) = old_arr
    ELSE
      new_size = 1
      ALLOCATE(new_arrd(new_size, 3), source=0.0d0)
      ALLOCATE(new_arr(new_size, 3), source=0.0d0)
    END IF
! 添加新行
    new_arr(new_size, :) = new_row
  END SUBROUTINE EXTEND_ARRAY_D

  SUBROUTINE EXTEND_ARRAY(old_arr, new_row, new_arr)
    IMPLICIT NONE
! 原数组
    REAL*8, ALLOCATABLE, INTENT(INOUT) :: old_arr(:, :)
! 新增行
    REAL*8, INTENT(IN) :: new_row(3)
! 扩展后数组
    REAL*8, ALLOCATABLE, INTENT(OUT) :: new_arr(:, :)
    INTEGER(kind=8) :: new_size
    INTRINSIC ALLOCATED
    INTRINSIC SIZE
! 计算新尺寸
    IF (ALLOCATED(old_arr)) THEN
      new_size = SIZE(old_arr, 1) + 1
      ALLOCATE(new_arr(new_size, 3), source=0.0d0)
! 复制旧数据
      new_arr(1:new_size-1, :) = old_arr
    ELSE
      new_size = 1
      ALLOCATE(new_arr(new_size, 3), source=0.0d0)
    END IF
! 添加新行
    new_arr(new_size, :) = new_row
  END SUBROUTINE EXTEND_ARRAY

!  Differentiation of readopenfoammesh in forward (tangent) mode (with options i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4)
!:
!   variations   of useful results: [alloc*(tempmesh.points) in readopenfoammesh]
!   with respect to varying inputs: [alloc*point_update in airfoil_deformation_hh]
!   Plus diff mem management of: point_update:in tempmesh.points:out
! 读取OpenFOAM网格主函数
  SUBROUTINE READOPENFOAMMESH_D(polymeshpath, point_update, &
&   point_updated, tempmesh, tempmeshd)
    IMPLICIT NONE
    CHARACTER(len=*), INTENT(IN) :: polymeshpath
! 输入：变形网格点
    REAL*8, ALLOCATABLE, INTENT(IN) :: point_update(:, :)
    REAL*8, ALLOCATABLE, INTENT(IN) :: point_updated(:, :)
    TYPE(MESHDATA), INTENT(OUT) :: tempmesh
    TYPE(MESHDATA_DIFF), INTENT(OUT) :: tempmeshd
    CHARACTER(len=256) :: pointsfilepath, facesfilepath, ownerfilepath, &
&   neighbourfilepath, boundaryfilepath
    INTRINSIC TRIM
    INTRINSIC SIZE
    pointsfilepath = TRIM(polymeshpath)//'/points'
    facesfilepath = TRIM(polymeshpath)//'/faces'
    ownerfilepath = TRIM(polymeshpath)//'/owner'
    neighbourfilepath = TRIM(polymeshpath)//'/neighbour'
    boundaryfilepath = TRIM(polymeshpath)//'/boundary'
    print *, "aaa"
    ALLOCATE(tempmeshd%points(SIZE(point_update, 1), SIZE(point_update, &
&   2)), source=0.0d0)
    ALLOCATE(tempmesh%points(SIZE(point_update, 1), SIZE(point_update, 2&
&   )), source=0.0d0)
    ALLOCATE(tempmesh%owner(74151), source=0_8)
    ALLOCATE(tempmesh%neighbour(36927), source=0_8)
    tempmeshd%points = 0.0_8
    tempmeshd%points = point_updated
    tempmesh%points = point_update
     print *, "aaa"
    CALL READOFFACESFILE(facesfilepath, tempmesh%faces)
     print *, "aaa"
    CALL READOFOWNERFILE(ownerfilepath, tempmesh%owner)
     print *, "aaa"
    CALL READOFNEIGHBOURFILE(neighbourfilepath, tempmesh%neighbour)
     print *, "aaa"
    CALL READOFBOUNDARYFILE(boundaryfilepath, tempmesh%boundarynames, &
&                     tempmesh%boundarynumfaces, tempmesh%&
&                     boundarystartfaces)
  END SUBROUTINE READOPENFOAMMESH_D

! 读取OpenFOAM网格主函数
  SUBROUTINE READOPENFOAMMESH(polymeshpath, point_update, tempmesh)
    IMPLICIT NONE
    CHARACTER(len=*), INTENT(IN) :: polymeshpath
! 输入：变形网格点
    REAL*8, ALLOCATABLE, INTENT(IN) :: point_update(:, :)
    TYPE(MESHDATA), INTENT(OUT) :: tempmesh
    CHARACTER(len=256) :: pointsfilepath, facesfilepath, ownerfilepath, &
&   neighbourfilepath, boundaryfilepath
    INTRINSIC TRIM
    INTRINSIC SIZE
    pointsfilepath = TRIM(polymeshpath)//'/points'
    facesfilepath = TRIM(polymeshpath)//'/faces'
    ownerfilepath = TRIM(polymeshpath)//'/owner'
    neighbourfilepath = TRIM(polymeshpath)//'/neighbour'
    boundaryfilepath = TRIM(polymeshpath)//'/boundary'
    ALLOCATE(tempmesh%points(SIZE(point_update, 1), SIZE(point_update, 2&
&   )), source=0.0d0)
    ALLOCATE(tempmesh%owner(74151), source=0_8)
    ALLOCATE(tempmesh%neighbour(36927), source=0_8)
    tempmesh%points = point_update
    CALL READOFFACESFILE(facesfilepath, tempmesh%faces)
    CALL READOFOWNERFILE(ownerfilepath, tempmesh%owner)
    CALL READOFNEIGHBOURFILE(neighbourfilepath, tempmesh%neighbour)
    CALL READOFBOUNDARYFILE(boundaryfilepath, tempmesh%boundarynames, &
&                     tempmesh%boundarynumfaces, tempmesh%&
&                     boundarystartfaces)
  END SUBROUTINE READOPENFOAMMESH

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! 主函数：从OpenFOAM网格路径读取并处理单元点索引
  SUBROUTINE OPENFOAMMESH_FINDCELLPTS(polymeshpath, pointlocations, &
&   cells, point_update)
    IMPLICIT NONE
    CHARACTER(len=*), INTENT(IN) :: polymeshpath
    REAL*8, ALLOCATABLE, INTENT(IN) :: point_update(:, :)
    REAL(kind=8), ALLOCATABLE, INTENT(OUT) :: pointlocations(:, :)
    TYPE(CELLLARRAY), INTENT(OUT) :: cells
!$AD NONDIFF  ! 明确该变量为非微分
! 主程序变量（包含pointIndicesByFace，避免全局变量）
! 网格数据
    TYPE(MESHDATA) :: meshdataa
    INTEGER(kind=8) :: ncells, nfaces, nboundaries
    INTEGER(kind=8) :: i, j, fi, nfacescell, quadfacecount
! 核心：点索引数据（对应Julia的pointIndicesByFace，在主程序内定义）
! (面索引, 点序号)
    INTEGER(kind=8), ALLOCATABLE :: pointindicesbyface(:, :)
    INTEGER(kind=8) :: ierr, len_common
! 1. 读取网格数据
    INTEGER(kind=8), ALLOCATABLE :: commonpoints(:)
    INTRINSIC SIZE
    INTRINSIC INT
    INTRINSIC MAXVAL
    INTRINSIC ALLOCATED
    CALL READOPENFOAMMESH(polymeshpath, point_update, meshdataa)
! 2. 提取pointIndicesByFace（关键：在主程序内定义，供内置函数使用）
! 假设从meshDataa中提取点索引（根据实际数据结构调整）
    nfaces = SIZE(meshdataa%faces%faces)
    ALLOCATE(pointindicesbyface(nfaces, 4), source=0_8)
! 假设最多4个点（四边形）
    DO i=1,nfaces
      IF (SIZE(meshdataa%faces%faces(i)%points) .NE. 4) THEN
        PRINT*, 'Error: 面', i, &
&       '顶点数不为4（六面体要求），实际为', SIZE(&
&       meshdataa%faces%faces(i)%points)
        STOP
      ELSE
        pointindicesbyface(i, 1:SIZE(meshdataa%faces%faces(i)%points))&
&        = INT(meshdataa%faces%faces(i)%points)
      END IF
    END DO
! 3. 初始化单元数组
    ncells = MAXVAL(meshdataa%owner)
    ALLOCATE(cells%cells(ncells))
    DO i=1,ncells
      ALLOCATE(cells%cells(i)%faceindices(0), source=0_8)
      ALLOCATE(cells%cells(i)%pointindices(0), source=0_8)
    END DO
! 4. 添加面索引（调用外部的addCellFaceIndices）
    CALL ADDCELLFACEINDICES(meshdataa%owner, cells, ncells)
    CALL ADDCELLFACEINDICES(meshdataa%neighbour, cells, ncells)
! 5. 处理单元点索引（调用内置函数）
    DO i=1,ncells
      nfacescell = SIZE(cells%cells(i)%faceindices)
      SELECT CASE (nfacescell)
      CASE (4)
        CALL POPULATEPOINTINDICES_TET(cells%cells(i))
      CASE (5)
        quadfacecount = 0
        DO j=1,nfacescell
          fi = cells%cells(i)%faceindices(j)
          IF (SIZE(pointindicesbyface(fi, :)) .EQ. 4) quadfacecount = &
&             quadfacecount + 1
        END DO
        IF (quadfacecount .EQ. 1) THEN
          CALL POPULATEPOINTINDICES_PYRAMID(cells%cells(i))
        ELSE IF (quadfacecount .EQ. 3) THEN
          CALL POPULATEPOINTINDICES_WEDGE(cells%cells(i))
        ELSE
          PRINT*, 'Error: 无法识别的单元类型（单元', i, &
&         '）'
          STOP
        END IF
      CASE (6)
! 在case(6)中，单元1处理前添加调试
        IF (i .EQ. 1) THEN
          PRINT*, '调试：单元1的6个面索引：', cells%cells(i)%&
&         faceindices
          DO j=1,6
            fi = cells%cells(i)%faceindices(j)
            PRINT*, '面', fi, '的顶点：', pointindicesbyface(fi, :)
          END DO
! 检查面1与其他面的公共点（基准面f1应与4个侧面相邻）
          PRINT*, '面1（f1）与其他面的公共点数量：'
          DO j=2,6
            fi = cells%cells(i)%faceindices(j)
            CALL GET_INTERSECTION(pointindicesbyface(1, :), &
&                           pointindicesbyface(fi, :), commonpoints, &
&                           len_common)
            PRINT*, '面1与面', fi, '：', len_common, '个公共点'
            DEALLOCATE(commonpoints)
          END DO
        END IF
! 新增：检查单元所有面是否为4个顶点（六面体必需）
        DO j=1,SIZE(cells%cells(i)%faceindices)
          fi = cells%cells(i)%faceindices(j)
          IF (SIZE(pointindicesbyface(fi, :)) .NE. 4) THEN
            PRINT*, 'Error: 六面体单元', i, '的面', fi, &
&           '顶点数不为4（实际为', SIZE(pointindicesbyface(fi, &
&           :)), '）'
            STOP
          END IF
        END DO
! 新增：检查面数是否确实为6（防止数据错误）
        IF (SIZE(cells%cells(i)%faceindices) .NE. 6) THEN
          PRINT*, 'Error: 单元', i, &
&         '声明为六面体但实际面数为', SIZE(cells%cells(i)%&
&         faceindices)
          STOP
        ELSE
          CALL POPULATEPOINTINDICES_HEX(cells%cells(i), ierr)
          IF (ierr .NE. 0) THEN
! 增强错误信息：输出单元1的面索引，方便排查
            PRINT*, 'Error: 六面体单元', i, &
&           '顶点排序失败，错误代码', ierr
            PRINT*, '单元', i, '的面索引列表：', cells%cells(i)&
&           %faceindices
            STOP
          END IF
        END IF
      CASE DEFAULT
        PRINT*, 'Error: 不支持的单元面数（单元', i, &
&       '，面数', nfacescell, '）'
        STOP
      END SELECT
    END DO
! 6. 输出点坐标
    IF (ALLOCATED(pointlocations)) THEN
      DEALLOCATE(pointlocations)
    END IF
    ALLOCATE(pointlocations(SIZE(meshdataa%points, 1), 3), source=0.0d0)
    pointlocations = meshdataa%points
! 内置所有点索引处理函数（通过contains关联，共享主程序变量）

  CONTAINS
! 四面体单元点索引组织
    SUBROUTINE POPULATEPOINTINDICES_TET(cell)
      IMPLICIT NONE
      TYPE(CELLL), INTENT(INOUT) :: cell
! 直接调用内置的addAllNewPoints（无需传递参数，共享pointIndicesByFace）
!call addAllNewPoints(cell, cell%faceIndices(1))
!call addAllNewPoints(cell, cell%faceIndices(2))
      PRINT*, 'Aa'
    END SUBROUTINE POPULATEPOINTINDICES_TET

! 金字塔单元点索引组织
    SUBROUTINE POPULATEPOINTINDICES_PYRAMID(cell)
      IMPLICIT NONE
      TYPE(CELLL), INTENT(INOUT) :: cell
      INTEGER(kind=8) :: i, quadfaceidx, otherfaceindex
      INTRINSIC SIZE
      quadfaceidx = -1
      DO i=1,SIZE(cell%faceindices)
! 使用主程序的pointIndicesByFace判断面类型
        IF (SIZE(pointindicesbyface(cell%faceindices(i), :)) .EQ. 4) &
&       THEN
          quadfaceidx = cell%faceindices(i)
          GOTO 100
        END IF
      END DO
 100  IF (quadfaceidx .NE. -1) THEN
!call addAllNewPoints(cell, quadFaceIdx)
! 选择另一个面（与Julia逻辑一致）
        IF (quadfaceidx .NE. cell%faceindices(1)) THEN
          otherfaceindex = cell%faceindices(1)
        ELSE
          otherfaceindex = cell%faceindices(2)
        END IF
      END IF
!call addAllNewPoints(cell, otherFaceIndex)
      PRINT*, 'Bb'
    END SUBROUTINE POPULATEPOINTINDICES_PYRAMID

! 棱柱（楔形）单元：两个三角形底面，其余三个是连接面		
    SUBROUTINE POPULATEPOINTINDICES_WEDGE(cell)
      IMPLICIT NONE
      TYPE(CELLL), INTENT(INOUT) :: cell
      INTEGER(kind=8) :: i, j, t1, t2, nunused, k
      INTEGER(kind=8), ALLOCATABLE :: unusedfaces(:)
      INTRINSIC SIZE
      INTRINSIC COUNT
      nunused = SIZE(cell%faceindices)
      ALLOCATE(unusedfaces(nunused), source=0_8)
      unusedfaces = cell%faceindices
      t1 = -1
      DO 100 j=1,2
        DO i=1,nunused
          IF (COUNT(pointindicesbyface(unusedfaces(i), :) .GT. 0) .EQ. 3&
&         ) THEN
            IF (t1 .EQ. -1) THEN
              t1 = unusedfaces(i)
! 修正：使用 k 作为循环变量
              DO k=i,nunused-1
                unusedfaces(k) = unusedfaces(k+1)
              END DO
              nunused = nunused - 1
            ELSE
              t2 = unusedfaces(i)
! 修正：使用 k 作为循环变量
              DO k=i,nunused-1
                unusedfaces(k) = unusedfaces(k+1)
              END DO
              nunused = nunused - 1
            END IF
            GOTO 100
          END IF
        END DO
 100  CONTINUE
!if (t1 /= -1) call addAllNewPoints(cell, t1)
!if (t2 /= -1) call addAllNewPoints(cell, t2)
      DO i=1,nunused
!call addAllNewPoints(cell, unusedFaces(i))

      END DO
      DEALLOCATE(unusedfaces)
    END SUBROUTINE POPULATEPOINTINDICES_WEDGE

! 六面体（立方体）单元：按照 VTK 的顺序组织 8 个顶点
! 原定义错误：嵌套contains且参数多余，修改为内部子程序（直接访问主程序变量）
    SUBROUTINE POPULATEPOINTINDICES_HEX(cell, ierr)
      IMPLICIT NONE
      TYPE(CELLL), INTENT(INOUT) :: cell
      INTEGER(kind=8), INTENT(OUT) :: ierr
      INTEGER(kind=8) :: f1, f3, lastface, noresult
      INTEGER(kind=8), ALLOCATABLE :: f1points(:), fipoints(:)
      INTEGER(kind=8), ALLOCATABLE :: unusedfaces(:)
      INTEGER(kind=8) :: i, fi, lastfaceidx
      LOGICAL :: found
      LOGICAL :: disjointt
      INTRINSIC SIZE
      INTRINSIC ALLOCATED
      ierr = 0
      found = .false.
! 1. 复制所有面索引到unusedFaces
      ALLOCATE(unusedfaces(SIZE(cell%faceindices)), source=0_8)
      unusedfaces = cell%faceindices
!!print *, "初始面索引: ", unusedFaces
! 2. 取第一个面作为f1（修复核心错误）
      f1 = unusedfaces(1)
! 移除第一个元素
      CALL REMOVE_ELEMENT(unusedfaces, 1_int64)
!!print *, "基准面f1 = 面", f1, "，剩余面: ", unusedFaces
! 3. 获取f1的顶点
      ALLOCATE(f1points(4), source=0_8)
      f1points = pointindicesbyface(f1, :)
!!print *, "f1的顶点: ", f1Points
! 4. 找对面（与f1无公共点的面，应为面2）
      DO i=1,SIZE(unusedfaces)
        fi = unusedfaces(i)
        ALLOCATE(fipoints(4), source=0_int64)
        fipoints = pointindicesbyface(fi, :)
        CALL DISJOINT(f1points, fipoints, disjointt)
        IF (disjointt) THEN
!!print *, "找到对面: 面", fi
          CALL REMOVE_ELEMENT(unusedfaces, i)
          found = .true.
          DEALLOCATE(fipoints)
          GOTO 100
        ELSE
          DEALLOCATE(fipoints)
        END IF
      END DO
 100  IF (.NOT.found) THEN
        ierr = 1
!!print *, "错误代码1: 未找到对面"
        RETURN
      ELSE IF (SIZE(unusedfaces) .NE. 4) THEN
! 检查剩余面是否为4个（关键验证）
        PRINT*, '错误：剩余面数应为4，实际为', SIZE(&
&       unusedfaces)
        ierr = 1
        RETURN
      ELSE
!!print *, "删除对面后剩余面（4个侧面）: ", unusedFaces
! 5. 初始化顶点数组
        IF (ALLOCATED(cell%pointindices)) THEN
          DEALLOCATE(cell%pointindices)
        END IF
        ALLOCATE(cell%pointindices(8), source=0_8)
        cell%pointindices(1:4) = f1points(1:4)
        cell%pointindices(5:8) = (/0, 0, 0, 0/)
!!print *, "初始顶点索引: ", cell%pointIndices
! 6. 取第一个剩余面作为f3
        f3 = unusedfaces(1)
        CALL REMOVE_ELEMENT(unusedfaces, 1_int64)
!!print *, "处理面f3 = 面", f3, "，剩余面: ", unusedFaces
! 7. 第一次调用addEdges
        CALL ADDEDGES(cell%pointindices, pointindicesbyface(f3, :), &
&               f1points, unusedfaces, lastface)
!!print *, "第一次addEdges后顶点: ", cell%pointIndices
!!print *, "addEdges返回的lastFace: ", lastFace
! 8. 检查lastFace有效性
        IF (lastface .LT. 1 .OR. lastface .GT. SIZE(unusedfaces)) THEN
          ierr = 3
          PRINT*, '错误代码3: lastFace无效'
          RETURN
        ELSE
! 9. 处理最后一个面
          lastfaceidx = unusedfaces(lastface)
          CALL REMOVE_ELEMENT(unusedfaces, lastface)
!!print *, "处理最后一个面: 面", lastFaceIdx
! 10. 第二次调用addEdges
          CALL ADDEDGES(cell%pointindices, pointindicesbyface(&
&                 lastfaceidx, :), f1points, unusedfaces, noresult)
!!print *, "第二次addEdges后顶点: ", cell%pointIndices
! 11. 最终检查
          IF (noresult .NE. -1) THEN
            ierr = 4
            RETURN
          ELSE
            DEALLOCATE(f1points)
            DEALLOCATE(unusedfaces)
          END IF
        END IF
      END IF
    END SUBROUTINE POPULATEPOINTINDICES_HEX

    SUBROUTINE ADDEDGES(cellpoints, facepoints, endfacepoints, &
&     unusedfaces, oppositefaceindexx)
      IMPLICIT NONE
      INTEGER(kind=8), INTENT(INOUT) :: cellpoints(:)
      INTEGER(kind=8), INTENT(IN) :: facepoints(:), endfacepoints(:)
      INTEGER(kind=8), ALLOCATABLE, INTENT(IN) :: unusedfaces(:)
      INTEGER(kind=8), INTENT(INOUT) :: oppositefaceindexx
      INTEGER(kind=8) :: i, fi, p1, p2, pos, len_common
      INTEGER(kind=8), ALLOCATABLE :: fipoints(:), commonpoints(:)
      LOGICAL :: p1_in_end
      INTEGER(kind=8) :: processedcount, expectedcount
! 新增：标记是否存在对面
      LOGICAL :: has_opposite
      INTRINSIC SIZE
      INTRINSIC ALLOCATED
      INTRINSIC ANY
      INTRINSIC FINDLOC
      oppositefaceindexx = -1
      processedcount = 0
! 初始化为无对面
      has_opposite = .false.
      DO i=1,SIZE(unusedfaces)
        fi = unusedfaces(i)
        IF (ALLOCATED(fipoints)) THEN
          DEALLOCATE(fipoints)
        END IF
        ALLOCATE(fipoints(SIZE(pointindicesbyface(fi, :))), source=0_8)
        fipoints = pointindicesbyface(fi, :)
        CALL GET_INTERSECTION(facepoints, fipoints, commonpoints, &
&                       len_common)
!print *, "addEdges: 面", fi, "与当前面公共点数量：", len_common
        IF (len_common .EQ. 2) THEN
          processedcount = processedcount + 1
! 顶点填充逻辑（不变）
          p1_in_end = ANY(endfacepoints .EQ. commonpoints(1))
          IF (p1_in_end) THEN
            p1 = commonpoints(1)
            p2 = commonpoints(2)
          ELSE
            p1 = commonpoints(2)
            p2 = commonpoints(1)
          END IF
          pos = FINDLOC(endfacepoints, p1, dim=1)
          IF (pos .GT. 0) cellpoints(pos+4) = p2
        ELSE IF (len_common .EQ. 0) THEN
          oppositefaceindexx = i
! 标记存在对面
          has_opposite = .true.
        END IF
        DEALLOCATE(commonpoints)
      END DO
      IF (ALLOCATED(fipoints)) THEN
        DEALLOCATE(fipoints)
      END IF
! 关键修改：根据是否有对面计算预期值
      IF (has_opposite) THEN
! 有对面：总面数-1
        expectedcount = SIZE(unusedfaces) - 1
      ELSE
! 无对面：总面数
        expectedcount = SIZE(unusedfaces)
      END IF
! 检查是否匹配
      IF (processedcount .NE. expectedcount) THEN
!print *, "Error: addEdges处理面数异常，预期", expectedCount, "实际", processedCount
        oppositefaceindexx = -3
      END IF
    END SUBROUTINE ADDEDGES

! 辅助函数：计算两个数组的交集
    SUBROUTINE GET_INTERSECTION(a, b, intersection, len)
      IMPLICIT NONE
      INTEGER(kind=8), INTENT(IN) :: a(:), b(:)
      INTEGER(kind=8), ALLOCATABLE, INTENT(OUT) :: intersection(:)
      INTEGER(kind=8), INTENT(OUT) :: len
      INTEGER(kind=8) :: i, j, count
! 临时数组
      INTEGER(kind=8), ALLOCATABLE :: temp(:)
      INTRINSIC SIZE
      INTRINSIC MIN
      INTRINSIC MOVE_ALLOC
      INTEGER :: x1
      INTEGER :: y1
      INTEGER :: min1
      count = 0
      x1 = SIZE(a)
      y1 = SIZE(b)
      IF (x1 .GT. y1) THEN
        min1 = y1
      ELSE
        min1 = x1
      END IF
      ALLOCATE(intersection(min1), source=0_8)
      DO 100 i=1,SIZE(a)
        DO j=1,SIZE(b)
          IF (a(i) .EQ. b(j)) THEN
            count = count + 1
            intersection(count) = a(i)
            GOTO 100
          END IF
        END DO
 100  CONTINUE
      len = count
      IF (count .LT. SIZE(intersection)) THEN
! 修复：先复制到临时可分配数组，再移动
        ALLOCATE(temp(count), source=0_8)
        temp = intersection(1:count)
! 现在第一个参数是可分配数组
        CALL MOVE_ALLOC(temp, intersection)
!				!$AD call move_alloc_int(temp, intersection)  ! Tapenade 使用（intersection 是整数一维数组）
      END IF
    END SUBROUTINE GET_INTERSECTION

! 辅助函数：检查两个点集是否不相交（同级）
    SUBROUTINE DISJOINT(a, b, disjointt)
      IMPLICIT NONE
      INTEGER(kind=8), INTENT(IN) :: a(:), b(:)
      INTEGER(kind=8) :: i, j
      LOGICAL, INTENT(INOUT) :: disjointt
      INTRINSIC SIZE
      disjointt = .true.
      DO i=1,SIZE(a)
        DO j=1,SIZE(b)
          IF (a(i) .EQ. b(j)) THEN
            disjointt = .false.
            RETURN
          END IF
        END DO
      END DO
    END SUBROUTINE DISJOINT

! 辅助子程序：从数组中移除指定索引的元素（同级）
    SUBROUTINE REMOVE_ELEMENT(arr, idx)
      IMPLICIT NONE
      INTEGER(kind=8), ALLOCATABLE, INTENT(INOUT) :: arr(:)
      INTEGER(kind=8), INTENT(IN) :: idx
      INTEGER(kind=8), ALLOCATABLE :: temp(:)
      INTEGER(kind=8) :: i, n
      INTRINSIC SIZE
      INTRINSIC MOVE_ALLOC
      n = SIZE(arr)
      IF (idx .LT. 1 .OR. idx .GT. n) THEN
        RETURN
      ELSE
        ALLOCATE(temp(n-1), source=0_8)
        DO i=1,idx-1
          temp(i) = arr(i)
        END DO
        DO i=idx+1,n
          temp(i-1) = arr(i)
        END DO
!TAPENADE NOCHECKPOINT  
        CALL MOVE_ALLOC(temp, arr)
!		    !$AD call move_alloc_int(temp, arr)  ! Tapenade 使用（arr 是整数一维数组）
      END IF
    END SUBROUTINE REMOVE_ELEMENT

    SUBROUTINE SWAP(a, b)
      IMPLICIT NONE
      INTEGER(kind=8), INTENT(INOUT) :: a, b
      INTEGER(kind=8) :: temp
!$AD NONDIFF  ! 替换原!$AD noalias a, b
      temp = a
      a = b
      b = temp
    END SUBROUTINE SWAP

    SUBROUTINE ADDCELLFACEINDICES(adjacentcells, cells, ncells)
      IMPLICIT NONE
! 面所属单元索引
      INTEGER(kind=8), INTENT(IN) :: adjacentcells(:)
! 总单元数
      INTEGER(kind=8), INTENT(IN) :: ncells
! 单元数组
      TYPE(CELLLARRAY), INTENT(INOUT) :: cells
!$AD NONDIFF  ! 明确该变量为非微分
! 局部变量：统计用
      INTEGER(kind=8) :: f, cellidx, len, i, num_faces, j
! 6个面的单元数量
      INTEGER(kind=8) :: count_6_faces, tmp
! 其他面数统计
      INTEGER(kind=8), ALLOCATABLE :: other_counts(:), face_nums(:)
      INTEGER(kind=8), ALLOCATABLE :: temp(:)
      LOGICAL :: is_duplicate, found
      INTRINSIC SIZE
      INTRINSIC MOVE_ALLOC
! 初始化统计变量
      count_6_faces = 0
      ALLOCATE(other_counts(0), source=0_8)
      ALLOCATE(face_nums(0), source=0_8)
! 1. 为单元添加面索引（严格对应Julia逻辑）
      DO f=1,SIZE(adjacentcells)
        cellidx = adjacentcells(f)
! 检查单元索引有效性（防止越界）
        IF (.NOT.(cellidx .LT. 1 .OR. cellidx .GT. ncells)) THEN
! 直接添加面索引（不检查重复，与Julia一致）
          len = SIZE(cells%cells(cellidx)%faceindices)
          ALLOCATE(temp(len+1), source=0_8)
          IF (len .GT. 0) temp(1:len) = cells%cells(cellidx)%faceindices
          temp(len+1) = f
! 在move_alloc前添加指令，跳过checkpointing
!TAPENADE NOCHECKPOINT  
          CALL MOVE_ALLOC(temp, cells%cells(cellidx)%faceindices)
!				!$AD call move_alloc_int(temp, cells%cells(cellIdx)%faceIndices)  ! Tapenade 使用（整数一维数组）
        END IF
      END DO
! 2. 统计面数（与Julia逻辑完全一致）
      DO cellidx=1,ncells
        num_faces = SIZE(cells%cells(cellidx)%faceindices)
! 统计6个面的单元
        IF (num_faces .EQ. 6) THEN
          count_6_faces = count_6_faces + 1
        ELSE
! 统计其他面数（动态数组模拟字典）
          found = .false.
          DO i=1,SIZE(face_nums)
            IF (face_nums(i) .EQ. num_faces) THEN
              other_counts(i) = other_counts(i) + 1
              found = .true.
              GOTO 100
            END IF
          END DO
! 新增面数类型
 100      IF (.NOT.found) THEN
            ALLOCATE(temp(SIZE(face_nums)+1), source=0_8)
            IF (SIZE(face_nums) .GT. 0) temp(1:SIZE(face_nums)) = &
&               face_nums
            temp(SIZE(face_nums)+1) = num_faces
!TAPENADE NOCHECKPOINT
            CALL MOVE_ALLOC(temp, face_nums)
!				        !$AD call move_alloc_int(temp, face_nums)  ! Tapenade 使用（整数一维数组）
            ALLOCATE(temp(SIZE(other_counts)+1), source=0_8)
            IF (SIZE(other_counts) .GT. 0) temp(1:SIZE(other_counts)) = &
&               other_counts
            temp(SIZE(other_counts)+1) = 1
!TAPENADE NOCHECKPOINT
            CALL MOVE_ALLOC(temp, other_counts)
!				        !$AD call move_alloc_int(temp, face_nums)  ! Tapenade 使用（整数一维数组）
          END IF
        END IF
      END DO
! 3. 输出统计结果（与Julia格式完全一致）
      PRINT*, '包含6个面的单元数量: ', count_6_faces
      IF (SIZE(face_nums) .GT. 0) THEN
        PRINT*, '其他面数的单元统计:'
! 排序（按面数升序）
        DO i=1,SIZE(face_nums)-1
          DO j=i+1,SIZE(face_nums)
            IF (face_nums(j) .LT. face_nums(i)) THEN
              tmp = face_nums(i)
              face_nums(i) = face_nums(j)
              face_nums(j) = tmp
! 交换 other_counts
              tmp = other_counts(i)
              other_counts(i) = other_counts(j)
              other_counts(j) = tmp
            END IF
          END DO
        END DO
! 打印排序后的结果
        DO i=1,SIZE(face_nums)
          WRITE(*, '(A, I0, A, I0, A)') '  ', face_nums(i), &
&         ' 个面的单元: ', other_counts(i), ' 个'
        END DO
      ELSE
        PRINT*, '所有单元都包含6个面'
      END IF
! 释放临时数组
      DEALLOCATE(other_counts)
      DEALLOCATE(face_nums)
    END SUBROUTINE ADDCELLFACEINDICES

  END SUBROUTINE OPENFOAMMESH_FINDCELLPTS

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! 读取点文件
  SUBROUTINE READOFPOINTSFILE(filepath, points)
    IMPLICIT NONE
    CHARACTER(len=*), INTENT(IN) :: filepath
    REAL(kind=8), ALLOCATABLE, INTENT(INOUT) :: points(:, :)
    CHARACTER(len=256), ALLOCATABLE :: lines(:)
    INTEGER(kind=8) :: startline, pcount, i, nlines, iostat, file_unit
    CHARACTER(len=256) :: line, bracketsremoved
    REAL(kind=8) :: coords(3)
    INTRINSIC TRIM
    INTRINSIC LEN_TRIM
    CALL GET_FREE_UNIT(file_unit)
    OPEN(unit=file_unit, file=filepath, status='old', action='read', &
&  iostat=iostat) 
    IF (iostat .NE. 0) THEN
      PRINT*, 'Error: Can''t open points file: ', TRIM(filepath)
      ALLOCATE(points(0, 3), source=0.0d0)
      RETURN
    ELSE
      nlines = 0
      DO 
        READ(file_unit, '(a)', iostat=iostat) 
        IF (iostat .NE. 0) THEN
          REWIND(file_unit) 
          ALLOCATE(lines(nlines))
          DO i=1,nlines
            READ(file_unit, '(a)') lines(i)
          END DO
          CLOSE(file_unit) 
          CALL OFFILE_FINDNITEMS(lines, startline, pcount)
          IF (pcount .LE. 0) THEN
            PRINT*, 'Error: Invalid point count in ', TRIM(filepath)
            DEALLOCATE(lines)
            ALLOCATE(points(0, 3), source=0.0d0)
            RETURN
          ELSE
            ALLOCATE(points(pcount, 3), source=0.0d0)
            DO i=1,pcount
              line = TRIM(lines(startline+i-1))
              bracketsremoved = line(2:LEN_TRIM(line)-1)
              READ(bracketsremoved, *) coords
              points(i, :) = coords
            END DO
            DEALLOCATE(lines)
          END IF
          GOTO 100
        ELSE
          nlines = nlines + 1
        END IF
      END DO
    END IF
 100 CONTINUE
  END SUBROUTINE READOFPOINTSFILE

! 读取面文件
  SUBROUTINE READOFFACESFILE(filepath, faces)
    IMPLICIT NONE
! 显式定义int64为8字节整数（等价于kind=8）        
    INTEGER(kind=8), PARAMETER :: int64=8
    CHARACTER(len=*), INTENT(IN) :: filepath
    TYPE(FACEARRAY), INTENT(INOUT) :: faces
    TYPE(FACETYPE), ALLOCATABLE :: tmp_faces(:)
    CHARACTER(len=1000), ALLOCATABLE :: lines(:)
    INTEGER(kind=8) :: startline, fcount, i, nlines, iostat, file_unit, &
&   bracketl, bracketr
    CHARACTER(len=1000) :: line
    INTEGER(kind=8), ALLOCATABLE :: pts(:)
    INTEGER(kind=8) :: pt_count
    INTRINSIC TRIM
    INTRINSIC INDEX
    CALL GET_FREE_UNIT(file_unit)
    OPEN(unit=file_unit, file=filepath, status='old', action='read', &
&  iostat=iostat) 
    IF (iostat .NE. 0) THEN
      PRINT*, 'Error: Can''t open faces file: ', TRIM(filepath)
      ALLOCATE(faces%faces(0))
      RETURN
    ELSE
      nlines = 0
      DO 
        READ(file_unit, '(a)', iostat=iostat) 
        IF (iostat .NE. 0) THEN
          REWIND(file_unit) 
          ALLOCATE(lines(nlines))
          DO i=1,nlines
            READ(file_unit, '(a)') lines(i)
          END DO
          CLOSE(file_unit) 
          CALL OFFILE_FINDNITEMS(lines, startline, fcount)
          IF (fcount .LE. 0) THEN
            PRINT*, 'Error: Invalid face count in ', TRIM(filepath)
            DEALLOCATE(lines)
            ALLOCATE(faces%faces(0))
            RETURN
          ELSE
            ALLOCATE(tmp_faces(fcount))
            ALLOCATE(pts(4), source=0_int64)
            DO i=1,fcount
              line = TRIM(lines(startline+i-1))
              bracketl = INDEX(line, '(')
              bracketr = INDEX(line, ')')
              READ(line(1:bracketl-1), *) pt_count
              pts = 0_int64
!            allocate(pts(4), source=0_int64)
              READ(line(bracketl+1:bracketr-1), *) pts
! 0基转1基
              pts = pts + 1
              ALLOCATE(tmp_faces(i)%points(pt_count), source=0_8)
              tmp_faces(i)%points = pts
!            deallocate(pts)
            END DO
            DEALLOCATE(pts)
            ALLOCATE(faces%faces(fcount))
            faces%faces = tmp_faces
            DEALLOCATE(lines)
            DEALLOCATE(tmp_faces)
          END IF
          GOTO 100
        ELSE
          nlines = nlines + 1
        END IF
      END DO
    END IF
 100 CONTINUE
  END SUBROUTINE READOFFACESFILE

! 读取owner文件
  SUBROUTINE READOFOWNERFILE(filepath, owner)
    IMPLICIT NONE
    CHARACTER(len=*), INTENT(IN) :: filepath
    INTEGER(kind=8), ALLOCATABLE, INTENT(INOUT) :: owner(:)
    CHARACTER(len=256), ALLOCATABLE :: lines(:)
    INTEGER(kind=8) :: startline, ocount, i, nlines, iostat, file_unit
    INTEGER(kind=8) :: val
    INTRINSIC TRIM
    INTRINSIC INT
    CALL GET_FREE_UNIT(file_unit)
    OPEN(unit=file_unit, file=filepath, status='old', action='read', &
&  iostat=iostat) 
    IF (iostat .NE. 0) THEN
      PRINT*, 'Error: Can''t open owner file: ', TRIM(filepath)
      ALLOCATE(owner(0), source=0_8)
      RETURN
    ELSE
      nlines = 0
      DO 
        READ(file_unit, '(a)', iostat=iostat) 
        IF (iostat .NE. 0) THEN
          REWIND(file_unit) 
          ALLOCATE(lines(nlines))
          DO i=1,nlines
            READ(file_unit, '(a)') lines(i)
          END DO
          CLOSE(file_unit) 
          CALL OFFILE_FINDNITEMS(lines, startline, ocount)
          IF (ocount .LE. 0) THEN
            PRINT*, 'Error: Invalid owner count in ', TRIM(filepath)
            DEALLOCATE(lines)
            ALLOCATE(owner(0), source=0_8)
            RETURN
          ELSE
!        allocate(owner(oCount))
            DO i=1,ocount
              READ(lines(startline+i-1), *) val
              owner(i) = INT(val) + 1
            END DO
            DEALLOCATE(lines)
          END IF
          GOTO 100
        ELSE
          nlines = nlines + 1
        END IF
      END DO
    END IF
 100 CONTINUE
  END SUBROUTINE READOFOWNERFILE

! 读取neighbour文件
  SUBROUTINE READOFNEIGHBOURFILE(filepath, neighbour)
    IMPLICIT NONE
! 输入文件路径
    CHARACTER(len=*), INTENT(IN) :: filepath
! 输出邻居单元索引数组
    INTEGER(kind=8), ALLOCATABLE, INTENT(INOUT) :: neighbour(:)
! 存储文件所有行
    CHARACTER(len=256), ALLOCATABLE :: lines(:)
! 数据起始行、数据总数
    INTEGER(kind=8) :: startline, ncount
! 循环变量、总行数、I/O状态、文件单元
    INTEGER(kind=8) :: i, nlines, iostat, file_unit
! 临时存储读取的大整数（兼容OpenFOAM格式）
    INTEGER(kind=8) :: val
    INTRINSIC ALLOCATED
    INTRINSIC TRIM
    INTRINSIC INT
! 1. 初始化：不预先分配数组（与owner处理一致）
    IF (ALLOCATED(neighbour)) THEN
      DEALLOCATE(neighbour)
    END IF
! 2. 打开文件（与owner逻辑完全一致）
    CALL GET_FREE_UNIT(file_unit)
    OPEN(unit=file_unit, file=filepath, status='old', action='read', &
&  iostat=iostat) 
    IF (iostat .NE. 0) THEN
! 错误信息与owner格式统一
      PRINT*, 'Error: Can''t open neighbour file: ', TRIM(filepath)
      ALLOCATE(neighbour(0), source=0_8)
! 错误时返回空数组
      RETURN
    ELSE
! 3. 读取文件总行数（与owner逻辑一致）
      nlines = 0
      DO 
! 逐行读取计数
        READ(file_unit, '(a)', iostat=iostat) 
        IF (iostat .NE. 0) THEN
          REWIND(file_unit) 
! 重置文件指针
! 4. 存储所有行内容（与owner逻辑一致）
          ALLOCATE(lines(nlines))
! 分配存储所有行的数组
          DO i=1,nlines
! 逐行读取内容
            READ(file_unit, '(a)') lines(i)
          END DO
          CLOSE(file_unit) 
! 关闭文件（后续使用lines处理）
! 5. 查找数据起始行和数量（核心：与owner调用同一函数）
          CALL OFFILE_FINDNITEMS(lines, startline, ncount)
! 6. 检查数据数量有效性（与owner逻辑一致）
          IF (ncount .LE. 0) THEN
! 错误信息格式统一
            PRINT*, 'Error: Invalid neighbour count in ', TRIM(filepath)
            DEALLOCATE(lines)
            ALLOCATE(neighbour(0), source=0_8)
! 无效数量时返回空数组
            RETURN
          ELSE
! 7. 分配邻居数组并读取数据（与owner完全一致）
            ALLOCATE(neighbour(ncount), source=0_8)
! 确认数量有效后再分配
            DO i=1,ncount
! 严格按照owner的读取方式：startLine + i - 1索引
! 读取原始值（OpenFOAM格式）
              READ(lines(startline+i-1), *) val
! 转换为Fortran索引（+1逻辑与owner一致）
              neighbour(i) = INT(val) + 1
            END DO
! 8. 释放临时资源（与owner一致）
            DEALLOCATE(lines)
          END IF
          GOTO 100
        ELSE
          nlines = nlines + 1
        END IF
      END DO
    END IF
 100 CONTINUE
  END SUBROUTINE READOFNEIGHBOURFILE

! 读取边界文件
  SUBROUTINE READOFBOUNDARYFILE(filepath, boundarynames, &
&   boundarynumfaces, boundarystartfaces)
    IMPLICIT NONE
    CHARACTER(len=*), INTENT(IN) :: filepath
    CHARACTER(len=100), ALLOCATABLE, INTENT(OUT) :: boundarynames(:)
    INTEGER(kind=8), ALLOCATABLE, INTENT(OUT) :: boundarynumfaces(:), &
&   boundarystartfaces(:)
    INTEGER(kind=8) :: i, nlines, iostat, startline, bcount, file_unit, &
&   startlinee
    INTEGER(kind=8) :: bnameline, bnfacesline, bstartfaceline, pos
    CHARACTER(len=256), ALLOCATABLE :: blines(:)
    CHARACTER(len=256) :: linestr, dummy
    INTRINSIC ADJUSTL
    INTRINSIC TRIM
    INTRINSIC INDEX
    CALL GET_FREE_UNIT(file_unit)
    OPEN(unit=file_unit, file=filepath, status='old', action='read', &
&  iostat=iostat) 
    IF (iostat .NE. 0) THEN
      ALLOCATE(boundarynames(0))
      ALLOCATE(boundarynumfaces(0), source=0_8)
      ALLOCATE(boundarystartfaces(0), source=0_8)
      RETURN
    ELSE
      nlines = 0
      DO 
        READ(file_unit, '(a)', iostat=iostat) 
        IF (iostat .NE. 0) THEN
          REWIND(file_unit) 
          ALLOCATE(blines(nlines))
          DO i=1,nlines
            READ(file_unit, '(a)') blines(i)
          END DO
          CLOSE(file_unit) 
          CALL OFFILE_FINDNITEMS(blines, startline, bcount)
          IF (bcount .LE. 0) THEN
            DEALLOCATE(blines)
            ALLOCATE(boundarynames(0))
            ALLOCATE(boundarynumfaces(0), source=0_8)
            ALLOCATE(boundarystartfaces(0), source=0_8)
            RETURN
          ELSE
            ALLOCATE(boundarynames(bcount))
            ALLOCATE(boundarynumfaces(bcount), source=0_8)
            ALLOCATE(boundarystartfaces(bcount), source=0_8)
            DO i=1,bcount
              CALL FINDINLINES('{', blines, startline, bnameline)
              bnameline = bnameline - 1
              boundarynames(i) = TRIM(ADJUSTL(blines(bnameline)))
              CALL FINDINLINES('nFaces', blines, startline, bnfacesline)
              pos = INDEX(blines(bnfacesline), 'nFaces') + 6
              READ(blines(bnfacesline)(pos:), *) boundarynumfaces(i)
              CALL FINDINLINES('startFace', blines, startline, &
&                        bstartfaceline)
              pos = INDEX(blines(bstartfaceline), 'startFace') + 9
              READ(blines(bstartfaceline), *) dummy, boundarystartfaces(&
&            i)
              boundarystartfaces(i) = boundarystartfaces(i) + 1
!boundaryEndFaces(i) = boundaryStartFaces(i) + boundaryNumFaces(i) - 1
              CALL FINDINLINES('}', blines, startline, startlinee)
              startline = startlinee
              startline = startline + 1
            END DO
            DEALLOCATE(blines)
          END IF
          GOTO 100
        ELSE
          nlines = nlines + 1
        END IF
      END DO
    END IF
 100 CONTINUE
  END SUBROUTINE READOFBOUNDARYFILE

! 辅助函数：查找数据数量和起始行
  SUBROUTINE OFFILE_FINDNITEMS(filelines, startline, itemcount)
    IMPLICIT NONE
    CHARACTER(len=*), INTENT(IN) :: filelines(:)
    INTEGER(kind=8), INTENT(OUT) :: startline, itemcount
    INTEGER(kind=8) :: i, pos, iostat
    CHARACTER(len=256) :: line
    LOGICAL :: isnumberr
    INTRINSIC SIZE
    INTRINSIC TRIM
    INTRINSIC INDEX
    itemcount = 0
    startline = 0
    DO i=1,SIZE(filelines)
      line = TRIM(filelines(i))
      pos = INDEX(line, 'nPoints') + INDEX(line, 'nFaces') + INDEX(line&
&       , 'size')
      IF (pos .NE. 0) THEN
        READ(line(pos:), *, iostat=iostat) itemcount
        IF (itemcount .GT. 0) THEN
          startline = i + 2
          RETURN
        END IF
      END IF
    END DO
    DO i=1,SIZE(filelines)
      CALL ISNUMBER(TRIM(filelines(i)), isnumberr)
      IF (isnumberr) THEN
        READ(filelines(i), *, iostat=iostat) itemcount
        IF (itemcount .GT. 0) THEN
          startline = i + 2
          RETURN
        END IF
      END IF
    END DO
    DO i=1,SIZE(filelines)
      IF (INDEX(filelines(i), '(') .GT. 0) THEN
        startline = i + 1
        GOTO 100
      END IF
    END DO
 100 itemcount = 0
    DO i=startline,SIZE(filelines)
      IF (INDEX(filelines(i), ')') .GT. 0) THEN
        GOTO 110
      ELSE
        itemcount = itemcount + 1
      END IF
    END DO
 110 CONTINUE
  END SUBROUTINE OFFILE_FINDNITEMS

! 辅助函数：判断是否为数字
  SUBROUTINE ISNUMBER(str, isnumberr)
    IMPLICIT NONE
    CHARACTER(len=*), INTENT(IN) :: str
    REAL(kind=8) :: num
    INTEGER(kind=8) :: iostat
    LOGICAL, INTENT(INOUT) :: isnumberr
    isnumberr = .false.
    READ(str, *, iostat=iostat) num
    IF (iostat .EQ. 0) isnumberr = .true.
  END SUBROUTINE ISNUMBER

! 辅助函数：查找包含子串的行
  SUBROUTINE FINDINLINES(substr, lines, startline, findinliness)
    IMPLICIT NONE
    CHARACTER(len=*), INTENT(IN) :: substr, lines(:)
    INTEGER(kind=8), INTENT(IN) :: startline
    INTEGER(kind=8) :: i
    INTEGER(kind=8), INTENT(INOUT) :: findinliness
    INTRINSIC SIZE
    INTRINSIC INDEX
    findinliness = 0
    DO i=startline,SIZE(lines)
      IF (INDEX(lines(i), substr) .GT. 0) THEN
        findinliness = i
        RETURN
      END IF
    END DO
  END SUBROUTINE FINDINLINES

! 辅助函数：获取空闲单元号
  SUBROUTINE GET_FREE_UNIT(get_free_unitt)
    IMPLICIT NONE
    INTEGER(kind=8) :: i, iostat
    LOGICAL :: opened
    INTEGER(kind=8), INTENT(INOUT) :: get_free_unitt
    DO i=10,999
      INQUIRE(unit=i, opened=opened, iostat=iostat) 
      IF (.NOT.opened .AND. iostat .EQ. 0) THEN
        get_free_unitt = i
        RETURN
      END IF
    END DO
  END SUBROUTINE GET_FREE_UNIT

! 其他必要函数（简化实现）
  SUBROUTINE ISINARRAY(pts, pt, isinarrayy)
    IMPLICIT NONE
    REAL(kind=8), INTENT(IN) :: pts(:, :), pt(3)
    INTEGER(kind=8) :: i
    LOGICAL, INTENT(INOUT) :: isinarrayy
    INTRINSIC SIZE
    INTRINSIC ABS
    INTRINSIC ALL
    REAL(kind=8), DIMENSION(3) :: abs0
    isinarrayy = .false.
    DO i=1,SIZE(pts, 1)
      WHERE (pts(i, :) - pt .GE. 0.0) 
        abs0 = pts(i, :) - pt
      ELSEWHERE
        abs0 = -(pts(i, :)-pt)
      END WHERE
      IF (ALL(abs0 .LT. 1d-12)) THEN
        isinarrayy = .true.
        RETURN
      END IF
    END DO
  END SUBROUTINE ISINARRAY

!  Differentiation of deallocatemeshdata in forward (tangent) mode (with options i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r
!4):
!   Plus diff mem management of: md.points:out
  SUBROUTINE DEALLOCATEMESHDATA_D(md, mdd)
    IMPLICIT NONE
    TYPE(MESHDATA), INTENT(INOUT) :: md
    TYPE(MESHDATA_DIFF), INTENT(INOUT) :: mdd
    INTEGER(kind=8) :: i
    INTRINSIC ALLOCATED
    INTRINSIC SIZE
    IF (ALLOCATED(md%points)) THEN
      IF (ALLOCATED(mdd%points)) THEN
        DEALLOCATE(mdd%points)
      END IF
      DEALLOCATE(md%points)
    END IF
    IF (ALLOCATED(md%owner)) THEN
      DEALLOCATE(md%owner)
    END IF
    IF (ALLOCATED(md%neighbour)) THEN
      DEALLOCATE(md%neighbour)
    END IF
    IF (ALLOCATED(md%boundarynames)) THEN
      DEALLOCATE(md%boundarynames)
    END IF
    IF (ALLOCATED(md%boundarynumfaces)) THEN
      DEALLOCATE(md%boundarynumfaces)
    END IF
    IF (ALLOCATED(md%boundarystartfaces)) THEN
      DEALLOCATE(md%boundarystartfaces)
    END IF
    IF (ALLOCATED(md%faces%faces)) THEN
      DO i=1,SIZE(md%faces%faces)
        IF (ALLOCATED(md%faces%faces(i)%points)) THEN
          DEALLOCATE(md%faces%faces(i)%points)
        END IF
      END DO
      DEALLOCATE(md%faces%faces)
    END IF
  END SUBROUTINE DEALLOCATEMESHDATA_D

  SUBROUTINE DEALLOCATEMESHDATA(md)
    IMPLICIT NONE
    TYPE(MESHDATA), INTENT(INOUT) :: md
    INTEGER(kind=8) :: i
    INTRINSIC ALLOCATED
    INTRINSIC SIZE
    IF (ALLOCATED(md%points)) THEN
      DEALLOCATE(md%points)
    END IF
    IF (ALLOCATED(md%owner)) THEN
      DEALLOCATE(md%owner)
    END IF
    IF (ALLOCATED(md%neighbour)) THEN
      DEALLOCATE(md%neighbour)
    END IF
    IF (ALLOCATED(md%boundarynames)) THEN
      DEALLOCATE(md%boundarynames)
    END IF
    IF (ALLOCATED(md%boundarynumfaces)) THEN
      DEALLOCATE(md%boundarynumfaces)
    END IF
    IF (ALLOCATED(md%boundarystartfaces)) THEN
      DEALLOCATE(md%boundarystartfaces)
    END IF
    IF (ALLOCATED(md%faces%faces)) THEN
      DO i=1,SIZE(md%faces%faces)
        IF (ALLOCATED(md%faces%faces(i)%points)) THEN
          DEALLOCATE(md%faces%faces(i)%points)
        END IF
      END DO
      DEALLOCATE(md%faces%faces)
    END IF
  END SUBROUTINE DEALLOCATEMESHDATA

!  Differentiation of greengaussgrad in forward (tangent) mode (with options i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4):
!   variations   of useful results: [alloc*grad in greengaussgrad]
!                [alloc*facevals in greengaussgrad]
!   with respect to varying inputs: [alloc*grad in greengaussgrad]
!                [alloc*facevals in greengaussgrad] [alloc*(mesh.ccenters) in openfoammesh]
!                [alloc*(mesh.cvols) in openfoammesh] [alloc*(mesh.fcenters) in openfoammesh]
!                [alloc*(mesh.favecs) in openfoammesh] matrix
!   Plus diff mem management of: grad:out mesh.cvols:in mesh.ccenters:in
!                mesh.favecs:in mesh.fcenters:in
!7.numerics.jl!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!######################### Gradient Computation #######################
!1.梯度计算：（1）leastSqGrad: 最小二乘法梯度计算（未完成）（2）greenGaussGrad: Green-Gauss梯度计算方
!法（基于面通量积分）    2.面值插值：（1）linInterp_3D: 线性插值到面中心（2）maxInterp: 取相邻单\E5\85
!\83最大值作为面值（3）faceDeltas: 计算面两侧变量变化量（用于激波捕捉）    3.时间步进相关：（1\EF\BC
!\89decodeSolution_3D: 从守恒变量计算原始变量和单元通量（2）integrateFluxes_unstructured3D: 通过面通量积分
!计算残差
  SUBROUTINE GREENGAUSSGRAD_D(mesh, meshd, matrix, matrixd, &
&   valuesatfaces, grad, gradd)
    IMPLICIT NONE
! 网格信息
    TYPE(MESHH), INTENT(IN) :: mesh
    TYPE(MESHH_DIFF), INTENT(IN) :: meshd
! 单元变量矩阵（行：单元，列：变量）
    REAL(kind=8), INTENT(IN) :: matrix(:, :)
    REAL(kind=8), INTENT(IN) :: matrixd(:, :)
! 是否直接提供面值
    LOGICAL, INTENT(IN), OPTIONAL :: valuesatfaces
! 梯度矩阵（单元, 变量, 空间维度）
    REAL(kind=8), ALLOCATABLE, INTENT(OUT) :: grad(:, :, :)
    REAL(kind=8), ALLOCATABLE, INTENT(OUT) :: gradd(:, :, :)
    INTEGER(kind=8) :: ncells, nfaces, nboundaries, nbdryfaces, meshinfo&
&   (4)
    INTEGER(kind=8) :: f, v, d, ownercell, neighbourcell, nvars
! 面插值结果
    REAL(kind=8), ALLOCATABLE :: facevals(:, :)
    REAL(kind=8), ALLOCATABLE :: facevalsd(:, :)
    INTRINSIC SIZE
    INTRINSIC PRESENT
    REAL(kind=8) :: temp
! 解包网格信息：单元格数、面数、边界数、边界面数
    CALL UNSTRUCTUREDMESHINFO(mesh, meshinfo)
    ncells = meshinfo(1)
    nfaces = meshinfo(2)
    nboundaries = meshinfo(3)
    nbdryfaces = meshinfo(4)
! 变量数（如速度、压力等）
    nvars = SIZE(matrix, 2)
    ALLOCATE(facevalsd(nfaces, nvars), source=0.0d0)
    facevalsd = 0.0_8
    ALLOCATE(facevals(nfaces, nvars), source=0.0d0)
! 维度：(面数, 变量数)
! 初始化避免垃圾值
    facevalsd = 0.0_8
    facevals = 0.0d0
! 若面值未直接提供，则通过线性插值计算面值
    IF (PRESENT(valuesatfaces)) THEN
      IF (valuesatfaces) THEN
! 直接使用输入矩阵作为面值
        facevalsd = matrixd
        facevals = matrix
      ELSE
! 调用线性插值函数计算面值
        CALL LININTERP_3D_D(mesh, meshd, matrix, matrixd, facevals, &
&                     facevalsd)
      END IF
    ELSE
! 默认插值计算面值
      CALL LININTERP_3D_D(mesh, meshd, matrix, matrixd, facevals, &
&                   facevalsd)
    END IF
! 初始化梯度矩阵：[单元格, 变量, 空间维度(x/y/z)]
    ALLOCATE(gradd(ncells, nvars, 3), source=0.0d0)
    gradd = 0.0_8
    ALLOCATE(grad(ncells, nvars, 3), source=0.0d0)
    gradd = 0.0_8
    grad = 0.0d0
! 遍历所有面，积分通量以计算梯度
    DO f=1,nfaces
! 面所属的主单元格（owner cell）
      ownercell = mesh%faces(f, 1)
! 面相邻的邻接单元格（neighbour cell，边界面为-1）
      neighbourcell = mesh%faces(f, 2)
      DO v=1,nvars
! 空间维度（x/y/z方向）
        DO d=1,3
! 主单元格：累加面通量（面面积矢量 × 面值）
          gradd(ownercell, v, d) = gradd(ownercell, v, d) + facevals(f, &
&           v)*meshd%favecs(f, d) + mesh%favecs(f, d)*facevalsd(f, v)
          grad(ownercell, v, d) = grad(ownercell, v, d) + mesh%favecs(f&
&           , d)*facevals(f, v)
! 邻接单元格（非边界面时）：减去面通量（通量方向相反）
          IF (neighbourcell .GT. -1) THEN
            gradd(neighbourcell, v, d) = gradd(neighbourcell, v, d) - &
&             facevals(f, v)*meshd%favecs(f, d) - mesh%favecs(f, d)*&
&             facevalsd(f, v)
            grad(neighbourcell, v, d) = grad(neighbourcell, v, d) - mesh&
&             %favecs(f, d)*facevals(f, v)
          END IF
        END DO
      END DO
    END DO
! 将积分结果除以单元格体积，得到梯度（单位体积的通量）
    DO d=1,3
      DO v=1,nvars
! f循环实际为单元索引c
        DO f=1,ncells
          temp = grad(f, v, d)/mesh%cvols(f)
          gradd(f, v, d) = gradd(f, v, d)/mesh%cvols(f)-grad(f, v, d)*meshd%cvols(f)/(mesh%cvols(f)*mesh%cvols(f))
          grad(f, v, d) = temp
        END DO
      END DO
    END DO
    IF (ALLOCATED(facevalsd)) THEN
      DEALLOCATE(facevalsd)
    END IF
    DEALLOCATE(facevals)
  END SUBROUTINE GREENGAUSSGRAD_D

!7.numerics.jl!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!######################### Gradient Computation #######################
!1.梯度计算：（1）leastSqGrad: 最小二乘法梯度计算（未完成）（2）greenGaussGrad: Green-Gauss梯度计算方
!法（基于面通量积分）    2.面值插值：（1）linInterp_3D: 线性插值到面中心（2）maxInterp: 取相邻单\E5\85
!\83最大值作为面值（3）faceDeltas: 计算面两侧变量变化量（用于激波捕捉）    3.时间步进相关：（1\EF\BC
!\89decodeSolution_3D: 从守恒变量计算原始变量和单元通量（2）integrateFluxes_unstructured3D: 通过面通量积分
!计算残差
  SUBROUTINE GREENGAUSSGRAD(mesh, matrix, valuesatfaces, grad)
    IMPLICIT NONE
! 网格信息
    TYPE(MESHH), INTENT(IN) :: mesh
! 单元变量矩阵（行：单元，列：变量）
    REAL(kind=8), INTENT(IN) :: matrix(:, :)
! 是否直接提供面值
    LOGICAL, INTENT(IN), OPTIONAL :: valuesatfaces
! 梯度矩阵（单元, 变量, 空间维度）
    REAL(kind=8), ALLOCATABLE, INTENT(OUT) :: grad(:, :, :)
    INTEGER(kind=8) :: ncells, nfaces, nboundaries, nbdryfaces, meshinfo&
&   (4)
    INTEGER(kind=8) :: f, v, d, ownercell, neighbourcell, nvars
! 面插值结果
    REAL(kind=8), ALLOCATABLE :: facevals(:, :)
    INTRINSIC SIZE
    INTRINSIC PRESENT
! 解包网格信息：单元格数、面数、边界数、边界面数
    CALL UNSTRUCTUREDMESHINFO(mesh, meshinfo)
    ncells = meshinfo(1)
    nfaces = meshinfo(2)
    nboundaries = meshinfo(3)
    nbdryfaces = meshinfo(4)
! 变量数（如速度、压力等）
    nvars = SIZE(matrix, 2)
    ALLOCATE(facevals(nfaces, nvars), source=0.0d0)
! 维度：(面数, 变量数)
! 初始化避免垃圾值
    facevals = 0.0d0
! 若面值未直接提供，则通过线性插值计算面值
    IF (PRESENT(valuesatfaces)) THEN
      IF (valuesatfaces) THEN
! 直接使用输入矩阵作为面值
        facevals = matrix
      ELSE
! 调用线性插值函数计算面值
        CALL LININTERP_3D(mesh, matrix, facevals)
      END IF
    ELSE
! 默认插值计算面值
      CALL LININTERP_3D(mesh, matrix, facevals)
    END IF
! 初始化梯度矩阵：[单元格, 变量, 空间维度(x/y/z)]
    ALLOCATE(grad(ncells, nvars, 3), source=0.0d0)
    grad = 0.0d0
! 遍历所有面，积分通量以计算梯度
    DO f=1,nfaces
! 面所属的主单元格（owner cell）
      ownercell = mesh%faces(f, 1)
! 面相邻的邻接单元格（neighbour cell，边界面为-1）
      neighbourcell = mesh%faces(f, 2)
      DO v=1,nvars
! 空间维度（x/y/z方向）
        DO d=1,3
! 主单元格：累加面通量（面面积矢量 × 面值）
          grad(ownercell, v, d) = grad(ownercell, v, d) + mesh%favecs(f&
&           , d)*facevals(f, v)
! 邻接单元格（非边界面时）：减去面通量（通量方向相反）
          IF (neighbourcell .GT. -1) grad(neighbourcell, v, d) = grad(&
&             neighbourcell, v, d) - mesh%favecs(f, d)*facevals(f, v)
        END DO
      END DO
    END DO
! 将积分结果除以单元格体积，得到梯度（单位体积的通量）
    DO d=1,3
      DO v=1,nvars
! f循环实际为单元索引c
        DO f=1,ncells
          grad(f, v, d) = grad(f, v, d)/mesh%cvols(f)
        END DO
      END DO
    END DO
    DEALLOCATE(facevals)
  END SUBROUTINE GREENGAUSSGRAD

!  Differentiation of greengaussgradd in forward (tangent) mode (with options i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4):
!   Plus diff mem management of: grad:out mesh.ccenters:in mesh.fcenters:in
  SUBROUTINE GREENGAUSSGRADD_D(mesh, meshd, matrix, valuesatfaces, grad&
&   , gradd)
    IMPLICIT NONE
! 网格信息
    TYPE(MESHH), INTENT(IN) :: mesh
    TYPE(MESHH_DIFF), INTENT(IN) :: meshd
! 单元变量矩阵（行：单元，列：变量）
    REAL(kind=8), INTENT(IN) :: matrix(:, :)
! 是否直接提供面值
    LOGICAL, INTENT(IN), OPTIONAL :: valuesatfaces
! 梯度矩阵（单元, 变量, 空间维度）
    REAL(kind=8), ALLOCATABLE, INTENT(OUT) :: grad(:, :, :)
    REAL(kind=8), ALLOCATABLE, INTENT(OUT) :: gradd(:, :, :)
    INTEGER(kind=8) :: ncells, nfaces, nboundaries, nbdryfaces, meshinfo&
&   (4)
    INTEGER(kind=8) :: f, v, d, ownercell, neighbourcell, nvars
! 面插值结果
    REAL(kind=8), ALLOCATABLE :: facevals(:, :)
    REAL(kind=8), ALLOCATABLE :: facevalsd(:, :)
    INTRINSIC SIZE
    INTRINSIC PRESENT
! 解包网格信息：单元格数、面数、边界数、边界面数
    CALL UNSTRUCTUREDMESHINFO(mesh, meshinfo)
    ncells = meshinfo(1)
    nfaces = meshinfo(2)
    nboundaries = meshinfo(3)
    nbdryfaces = meshinfo(4)
! 变量数（如速度、压力等）
    nvars = SIZE(matrix, 2)
    ALLOCATE(facevalsd(nfaces, 5), source=0.0d0)
    ALLOCATE(facevals(nfaces, 5), source=0.0d0)
! 维度：(面数, 变量数)
! 初始化避免垃圾值
    facevals = 0.0d0
! 若面值未直接提供，则通过线性插值计算面值
    IF (PRESENT(valuesatfaces)) THEN
      IF (valuesatfaces) THEN
! 直接使用输入矩阵作为面值
        facevals = matrix
      ELSE
! 调用线性插值函数计算面值
        CALL LININTERP_3D(mesh, matrix, facevals)
      END IF
    ELSE
! 默认插值计算面值
      CALL LININTERP_3D(mesh, matrix, facevals)
    END IF
! 初始化梯度矩阵：[单元格, 变量, 空间维度(x/y/z)]
    ALLOCATE(gradd(ncells, nvars, 3), source=0.0d0)
    ALLOCATE(grad(ncells, nvars, 3), source=0.0d0)
    grad = 0.0d0
! 遍历所有面，积分通量以计算梯度
    DO f=1,nfaces
! 面所属的主单元格（owner cell）
      ownercell = mesh%faces(f, 1)
! 面相邻的邻接单元格（neighbour cell，边界面为-1）
      neighbourcell = mesh%faces(f, 2)
      DO v=1,nvars
! 空间维度（x/y/z方向）
        DO d=1,3
! 主单元格：累加面通量（面面积矢量 × 面值）
          grad(ownercell, v, d) = grad(ownercell, v, d) + mesh%favecs(f&
&           , d)*facevals(f, v)
! 邻接单元格（非边界面时）：减去面通量（通量方向相反）
          IF (neighbourcell .GT. -1) grad(neighbourcell, v, d) = grad(&
&             neighbourcell, v, d) - mesh%favecs(f, d)*facevals(f, v)
        END DO
      END DO
    END DO
! 将积分结果除以单元格体积，得到梯度（单位体积的通量）
    DO d=1,3
      DO v=1,nvars
! f循环实际为单元索引c
        DO f=1,ncells
          grad(f, v, d) = grad(f, v, d)/mesh%cvols(f)
        END DO
      END DO
    END DO
    IF (ALLOCATED(facevalsd)) THEN
      DEALLOCATE(facevalsd)
    END IF
    DEALLOCATE(facevals)
  END SUBROUTINE GREENGAUSSGRADD_D

  SUBROUTINE GREENGAUSSGRADD(mesh, matrix, valuesatfaces, grad)
    IMPLICIT NONE
! 网格信息
    TYPE(MESHH), INTENT(IN) :: mesh
! 单元变量矩阵（行：单元，列：变量）
    REAL(kind=8), INTENT(IN) :: matrix(:, :)
! 是否直接提供面值
    LOGICAL, INTENT(IN), OPTIONAL :: valuesatfaces
! 梯度矩阵（单元, 变量, 空间维度）
    REAL(kind=8), ALLOCATABLE, INTENT(OUT) :: grad(:, :, :)
    INTEGER(kind=8) :: ncells, nfaces, nboundaries, nbdryfaces, meshinfo&
&   (4)
    INTEGER(kind=8) :: f, v, d, ownercell, neighbourcell, nvars
! 面插值结果
    REAL(kind=8), ALLOCATABLE :: facevals(:, :)
    INTRINSIC SIZE
    INTRINSIC PRESENT
! 解包网格信息：单元格数、面数、边界数、边界面数
    CALL UNSTRUCTUREDMESHINFO(mesh, meshinfo)
    ncells = meshinfo(1)
    nfaces = meshinfo(2)
    nboundaries = meshinfo(3)
    nbdryfaces = meshinfo(4)
! 变量数（如速度、压力等）
    nvars = SIZE(matrix, 2)
    ALLOCATE(facevals(nfaces, 5), source=0.0d0)
! 维度：(面数, 变量数)
! 初始化避免垃圾值
    facevals = 0.0d0
! 若面值未直接提供，则通过线性插值计算面值
    IF (PRESENT(valuesatfaces)) THEN
      IF (valuesatfaces) THEN
! 直接使用输入矩阵作为面值
        facevals = matrix
      ELSE
! 调用线性插值函数计算面值
        CALL LININTERP_3D(mesh, matrix, facevals)
      END IF
    ELSE
! 默认插值计算面值
      CALL LININTERP_3D(mesh, matrix, facevals)
    END IF
! 初始化梯度矩阵：[单元格, 变量, 空间维度(x/y/z)]
    ALLOCATE(grad(ncells, nvars, 3), source=0.0d0)
    grad = 0.0d0
! 遍历所有面，积分通量以计算梯度
    DO f=1,nfaces
! 面所属的主单元格（owner cell）
      ownercell = mesh%faces(f, 1)
! 面相邻的邻接单元格（neighbour cell，边界面为-1）
      neighbourcell = mesh%faces(f, 2)
      DO v=1,nvars
! 空间维度（x/y/z方向）
        DO d=1,3
! 主单元格：累加面通量（面面积矢量 × 面值）
          grad(ownercell, v, d) = grad(ownercell, v, d) + mesh%favecs(f&
&           , d)*facevals(f, v)
! 邻接单元格（非边界面时）：减去面通量（通量方向相反）
          IF (neighbourcell .GT. -1) grad(neighbourcell, v, d) = grad(&
&             neighbourcell, v, d) - mesh%favecs(f, d)*facevals(f, v)
        END DO
      END DO
    END DO
! 将积分结果除以单元格体积，得到梯度（单位体积的通量）
    DO d=1,3
      DO v=1,nvars
! f循环实际为单元索引c
        DO f=1,ncells
          grad(f, v, d) = grad(f, v, d)/mesh%cvols(f)
        END DO
      END DO
    END DO
    DEALLOCATE(facevals)
  END SUBROUTINE GREENGAUSSGRADD

!  Differentiation of lininterp_3d in forward (tangent) mode (with options i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4):
!   variations   of useful results: facevals
!   with respect to varying inputs: [alloc*(mesh.ccenters) in openfoammesh]
!                [alloc*(mesh.fcenters) in openfoammesh] facevals
!                matrix
!   Plus diff mem management of: mesh.ccenters:in mesh.fcenters:in
!####################### 面值插值 ######################
!#=
!   对所有内部面进行插值（边界面需单独处理）
!   输入矩阵格式：
!    行：单元格，列：物理变量（如u, v, w, p）
!   输出矩阵格式：
!   行：面，列：物理变量（插值后的面值）
!=#
  SUBROUTINE LININTERP_3D_D(mesh, meshd, matrix, matrixd, facevals, &
&   facevalsd)
    IMPLICIT NONE
! 网格信息
    TYPE(MESHH), INTENT(IN) :: mesh
    TYPE(MESHH_DIFF), INTENT(IN) :: meshd
! 单元变量矩阵（行：单元，列：变量）
    REAL(kind=8), INTENT(IN) :: matrix(:, :)
    REAL(kind=8), INTENT(IN) :: matrixd(:, :)
! 预分配的面值矩阵（输入输出）
    REAL(kind=8), INTENT(INOUT) :: facevals(:, :)
    REAL(kind=8), INTENT(INOUT) :: facevalsd(:, :)
    INTEGER(kind=8) :: ncells, nfaces, nboundaries, nbdryfaces, meshinfo&
&   (4)
    INTEGER(kind=8) :: nvars, f, v, i, c1, c2, row, nvars_matrix, &
&   nvars_face
    REAL(kind=8) :: c1dist, c2dist, totaldist
    REAL(kind=8) :: c1distd, c2distd, totaldistd
    INTRINSIC SIZE
    REAL(kind=8) :: temp
    REAL(kind=8) :: temp0
! 解包网格信息
    CALL UNSTRUCTUREDMESHINFO(mesh, meshinfo)
    ncells = meshinfo(1)
    nfaces = meshinfo(2)
    nboundaries = meshinfo(3)
    nbdryfaces = meshinfo(4)
! 变量数
    nvars = SIZE(matrix, 2)
! 实际列数
    nvars_matrix = SIZE(matrix, 2)
    nvars_face = SIZE(facevals, 2)
! LTSeuler给的输入cellprimitvits(matrix)没问题
! 验证faceVals维度是否正确（避免越界）
    IF (SIZE(facevals, 1) .LT. nfaces .OR. SIZE(facevals, 2) .LT. nvars&
&   ) THEN
      PRINT*, 'Error: faceVals dimensions mismatch!'
      RETURN
    ELSE
! 遍历内部面（排除边界面nBdryFaces）
      DO f=1,nfaces-nbdryfaces
! 主单元格
        c1 = mesh%faces(f, 1)
! 邻接单元格
        c2 = mesh%faces(f, 2)
! 计算单元格中心到面中心的距离平方（欧氏距离）
        c1dist = 0.0d0
        c2dist = 0.0d0
        c1distd = 0.0_8
        c2distd = 0.0_8
! x/y/z方向
        DO i=1,3
          temp = mesh%ccenters(c1, i) - mesh%fcenters(f, i)
          c1distd = c1distd + 2*temp*(meshd%ccenters(c1, i)-meshd%&
&           fcenters(f, i))
          c1dist = c1dist + temp*temp
          temp = mesh%ccenters(c2, i) - mesh%fcenters(f, i)
          c2distd = c2distd + 2*temp*(meshd%ccenters(c2, i)-meshd%&
&           fcenters(f, i))
          c2dist = c2dist + temp*temp
        END DO
! 总距离
        totaldistd = c1distd + c2distd
        totaldist = c1dist + c2dist
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!        
!		    IF (f <= 2) THEN
        IF (f .EQ. 4466) THEN
          PRINT*, '===== Face/Cell No.', f, ' ====='
		  PRINT*, 'c1distd   : ', c1distd
          PRINT*, 'c1dist    : ', c1dist
		  PRINT*, 'c2distd   : ', c2distd
          PRINT*, 'c2dist    : ', c2dist
		  PRINT*, 'totaldistd: ', totaldistd
          PRINT*, 'totaldist : ', totaldist
          PRINT*, '---------------------------------'
        END IF
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! 线性插值：根据距离权重计算面值
        DO v=1,nvars
          temp = c2dist/totaldist
          temp0 = c1dist/totaldist
          facevalsd(f, v) = temp*matrixd(c1, v) + matrix(c1, v)*(c2distd&
&           -temp*totaldistd)/totaldist + temp0*matrixd(c2, v) + matrix(&
&           c2, v)*(c1distd-temp0*totaldistd)/totaldist
          facevals(f, v) = matrix(c1, v)*temp + matrix(c2, v)*temp0
        END DO
      END DO
    END IF
  END SUBROUTINE LININTERP_3D_D

!####################### 面值插值 ######################
!#=
!   对所有内部面进行插值（边界面需单独处理）
!   输入矩阵格式：
!    行：单元格，列：物理变量（如u, v, w, p）
!   输出矩阵格式：
!   行：面，列：物理变量（插值后的面值）
!=#
  SUBROUTINE LININTERP_3D(mesh, matrix, facevals)
    IMPLICIT NONE
! 网格信息
    TYPE(MESHH), INTENT(IN) :: mesh
! 单元变量矩阵（行：单元，列：变量）
    REAL(kind=8), INTENT(IN) :: matrix(:, :)
! 预分配的面值矩阵（输入输出）
    REAL(kind=8), INTENT(INOUT) :: facevals(:, :)
    INTEGER(kind=8) :: ncells, nfaces, nboundaries, nbdryfaces, meshinfo&
&   (4)
    INTEGER(kind=8) :: nvars, f, v, i, c1, c2, row, nvars_matrix, &
&   nvars_face
    REAL(kind=8) :: c1dist, c2dist, totaldist
    INTRINSIC SIZE
! 解包网格信息
    CALL UNSTRUCTUREDMESHINFO(mesh, meshinfo)
    ncells = meshinfo(1)
    nfaces = meshinfo(2)
    nboundaries = meshinfo(3)
    nbdryfaces = meshinfo(4)
! 变量数
    nvars = SIZE(matrix, 2)
! 实际列数
    nvars_matrix = SIZE(matrix, 2)
    nvars_face = SIZE(facevals, 2)
! LTSeuler给的输入cellprimitvits(matrix)没问题
! 验证faceVals维度是否正确（避免越界）
    IF (SIZE(facevals, 1) .LT. nfaces .OR. SIZE(facevals, 2) .LT. nvars&
&   ) THEN
      PRINT*, 'Error: faceVals dimensions mismatch!'
      RETURN
    ELSE
! 遍历内部面（排除边界面nBdryFaces）
      DO f=1,nfaces-nbdryfaces
! 主单元格
        c1 = mesh%faces(f, 1)
! 邻接单元格
        c2 = mesh%faces(f, 2)
! 计算单元格中心到面中心的距离平方（欧氏距离）
        c1dist = 0.0d0
        c2dist = 0.0d0
! x/y/z方向
        DO i=1,3
          c1dist = c1dist + (mesh%ccenters(c1, i)-mesh%fcenters(f, i))**&
&           2
          c2dist = c2dist + (mesh%ccenters(c2, i)-mesh%fcenters(f, i))**&
&           2
        END DO
! 总距离
        totaldist = c1dist + c2dist
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!        
!		    IF (f <= 2) THEN
        IF (f .EQ. 4466) THEN
          PRINT*, '===== Face/Cell No.', f, ' ====='
!			  PRINT*, 'c1distd   : ', c1distd
          PRINT*, 'c1dist    : ', c1dist
!			  PRINT*, 'c2distd   : ', c2distd
          PRINT*, 'c2dist    : ', c2dist
!			  PRINT*, 'totaldistd: ', totaldistd
          PRINT*, 'totaldist : ', totaldist
          PRINT*, '---------------------------------'
        END IF
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! 线性插值：根据距离权重计算面值
        DO v=1,nvars
          facevals(f, v) = matrix(c1, v)*(c2dist/totaldist) + matrix(c2&
&           , v)*(c1dist/totaldist)
        END DO
      END DO
    END IF
  END SUBROUTINE LININTERP_3D

!  Differentiation of maxinterp in forward (tangent) mode (with options i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4):
!   variations   of useful results: [alloc*facevals in maxinterp]
!   with respect to varying inputs: [alloc*facevals in maxinterp]
!                rj sj
!   Plus diff mem management of: facevals:out
! 与linInterp_3D类似，但取相邻单元格的最大值作为面值
  SUBROUTINE MAXINTERP_D(mesh, sj, sjd, rj, rjd, facevals, facevalsd)
    IMPLICIT NONE
    TYPE(MESHH), INTENT(IN) :: mesh
    REAL(kind=8), INTENT(IN) :: sj(:), rj(:)
    REAL(kind=8), INTENT(IN) :: sjd(:), rjd(:)
    REAL(kind=8), ALLOCATABLE, INTENT(OUT) :: facevals(:, :)
    REAL(kind=8), ALLOCATABLE, INTENT(OUT) :: facevalsd(:, :)
    INTEGER(kind=8) :: ncells, nfaces, nboundaries, nbdryfaces, meshinfo&
&   (4)
    INTEGER(kind=8) :: f, c1, c2
! 固定为2个变量（sj和rj）
    INTEGER(kind=8), SAVE :: nvars=2
    INTRINSIC MAX
! 获取网格信息
    CALL UNSTRUCTUREDMESHINFO(mesh, meshinfo)
    ncells = meshinfo(1)
    nfaces = meshinfo(2)
    nboundaries = meshinfo(3)
    nbdryfaces = meshinfo(4)
! 分配内存给输出数组
    ALLOCATE(facevalsd(nfaces, nvars), source=0.0d0)
    facevalsd = 0.0_8
    ALLOCATE(facevals(nfaces, nvars), source=0.0d0)
! 初始化为0
    facevalsd = 0.0_8
    facevals = 0.0d0
! 遍历内部面
    DO f=1,nfaces-nbdryfaces
! 主单元格
      c1 = mesh%faces(f, 1)
! 邻居单元格
      c2 = mesh%faces(f, 2)
      IF (sj(c1) .LT. sj(c2)) THEN
        facevalsd(f, 1) = sjd(c2)
        facevals(f, 1) = sj(c2)
      ELSE
        facevalsd(f, 1) = sjd(c1)
        facevals(f, 1) = sj(c1)
      END IF
      IF (rj(c1) .LT. rj(c2)) THEN
        facevalsd(f, 2) = rjd(c2)
        facevals(f, 2) = rj(c2)
      ELSE
        facevalsd(f, 2) = rjd(c1)
        facevals(f, 2) = rj(c1)
      END IF
    END DO
  END SUBROUTINE MAXINTERP_D

! 与linInterp_3D类似，但取相邻单元格的最大值作为面值
  SUBROUTINE MAXINTERP(mesh, sj, rj, facevals)
    IMPLICIT NONE
    TYPE(MESHH), INTENT(IN) :: mesh
    REAL(kind=8), INTENT(IN) :: sj(:), rj(:)
    REAL(kind=8), ALLOCATABLE, INTENT(OUT) :: facevals(:, :)
    INTEGER(kind=8) :: ncells, nfaces, nboundaries, nbdryfaces, meshinfo&
&   (4)
    INTEGER(kind=8) :: f, c1, c2
! 固定为2个变量（sj和rj）
    INTEGER(kind=8), SAVE :: nvars=2
    INTRINSIC MAX
! 获取网格信息
    CALL UNSTRUCTUREDMESHINFO(mesh, meshinfo)
    ncells = meshinfo(1)
    nfaces = meshinfo(2)
    nboundaries = meshinfo(3)
    nbdryfaces = meshinfo(4)
! 分配内存给输出数组
    ALLOCATE(facevals(nfaces, nvars), source=0.0d0)
! 初始化为0
    facevals = 0.0d0
! 遍历内部面
    DO f=1,nfaces-nbdryfaces
! 主单元格
      c1 = mesh%faces(f, 1)
! 邻居单元格
      c2 = mesh%faces(f, 2)
      IF (sj(c1) .LT. sj(c2)) THEN
        facevals(f, 1) = sj(c2)
      ELSE
        facevals(f, 1) = sj(c1)
      END IF
      IF (rj(c1) .LT. rj(c2)) THEN
        facevals(f, 2) = rj(c2)
      ELSE
        facevals(f, 2) = rj(c1)
      END IF
    END DO
  END SUBROUTINE MAXINTERP

!  Differentiation of facedeltas in forward (tangent) mode (with options i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4):
!   variations   of useful results: [alloc*deltas in facedeltas]
!   with respect to varying inputs: [alloc*deltas in facedeltas]
!                [alloc*(*sln.cellstate) in solve] *([alloc*sln in solve].cellstate)
!   Plus diff mem management of: deltas:out sln.cellstate:in
! 计算面两侧单元格的变量差值（邻接值 - 主值）
  SUBROUTINE FACEDELTAS_D(mesh, sln, slnd, deltas, deltasd)
    IMPLICIT NONE
! 网格信息
    TYPE(MESHH), INTENT(IN) :: mesh
! 流场解状态
    TYPE(SOLUTIONSTATE), INTENT(IN) :: sln
    TYPE(SOLUTIONSTATE), INTENT(IN) :: slnd
! 面差值矩阵（行：面，列：变量）
    REAL(kind=8), ALLOCATABLE, INTENT(OUT) :: deltas(:, :)
    REAL(kind=8), ALLOCATABLE, INTENT(OUT) :: deltasd(:, :)
    INTEGER(kind=8) :: ncells, nfaces, nboundaries, nbdryfaces, meshinfo&
&   (4)
    INTEGER(kind=8) :: nvars, f, v, ownercell, neighbourcell
    INTRINSIC SIZE
! 解包网格信息
    CALL UNSTRUCTUREDMESHINFO(mesh, meshinfo)
    ncells = meshinfo(1)
    nfaces = meshinfo(2)
    nboundaries = meshinfo(3)
    nbdryfaces = meshinfo(4)
! 单元格状态变量数
    nvars = SIZE(sln%cellstate, 2)
! 初始化面差值矩阵
    ALLOCATE(deltasd(nfaces, nvars), source=0.0d0)
    deltasd = 0.0_8
    ALLOCATE(deltas(nfaces, nvars), source=0.0d0)
    deltasd = 0.0_8
    deltas = 0.0d0
! 遍历内部面（除去边界面）
    DO f=1,nfaces-nbdryfaces
! 主单元格
      ownercell = mesh%faces(f, 1)
! 邻接单元格
      neighbourcell = mesh%faces(f, 2)
      DO v=1,nvars
! 计算邻接单元格与主单元格的变量差值
        deltasd(f, v) = slnd%cellstate(neighbourcell, v) - slnd%&
&         cellstate(ownercell, v)
        deltas(f, v) = sln%cellstate(neighbourcell, v) - sln%cellstate(&
&         ownercell, v)
      END DO
      IF (f == 4466) THEN
		  PRINT*, 'Face 4466: Owner=', ownercell, ' Neighbour=', neighbourcell
		  PRINT*, 'Owner slnd: ', slnd%cellstate(ownercell, :)
		  PRINT*, 'Neighbour slnd: ', slnd%cellstate(neighbourcell, :)
		END IF
    END DO
  END SUBROUTINE FACEDELTAS_D

! 计算面两侧单元格的变量差值（邻接值 - 主值）
  SUBROUTINE FACEDELTAS(mesh, sln, deltas)
    IMPLICIT NONE
! 网格信息
    TYPE(MESHH), INTENT(IN) :: mesh
! 流场解状态
    TYPE(SOLUTIONSTATE), INTENT(IN) :: sln
! 面差值矩阵（行：面，列：变量）
    REAL(kind=8), ALLOCATABLE, INTENT(OUT) :: deltas(:, :)
    INTEGER(kind=8) :: ncells, nfaces, nboundaries, nbdryfaces, meshinfo&
&   (4)
    INTEGER(kind=8) :: nvars, f, v, ownercell, neighbourcell
    INTRINSIC SIZE
! 解包网格信息
    CALL UNSTRUCTUREDMESHINFO(mesh, meshinfo)
    ncells = meshinfo(1)
    nfaces = meshinfo(2)
    nboundaries = meshinfo(3)
    nbdryfaces = meshinfo(4)
! 单元格状态变量数
    nvars = SIZE(sln%cellstate, 2)
! 初始化面差值矩阵
    ALLOCATE(deltas(nfaces, nvars), source=0.0d0)
    deltas = 0.0d0
! 遍历内部面（除去边界面）
    DO f=1,nfaces-nbdryfaces
! 主单元格
      ownercell = mesh%faces(f, 1)
! 邻接单元格
      neighbourcell = mesh%faces(f, 2)
      DO v=1,nvars
! 计算邻接单元格与主单元格的变量差值
        deltas(f, v) = sln%cellstate(neighbourcell, v) - sln%cellstate(&
&         ownercell, v)
      END DO
    END DO
  END SUBROUTINE FACEDELTAS

!######################### TimeStepping #################################
!######################### 时间步进相关 #########################
!# 从单元格状态向量解码为原始变量和通量
  SUBROUTINE DEEP_COPY_SLN(src, dest)
    IMPLICIT NONE
    TYPE(SOLUTIONSTATE), INTENT(IN) :: src
    TYPE(SOLUTIONSTATE), INTENT(INOUT) :: dest
    INTRINSIC ALLOCATED
    INTRINSIC SIZE
    IF (ALLOCATED(dest%cellstate)) THEN
      DEALLOCATE(dest%cellstate)
    END IF
    ALLOCATE(dest%cellstate(SIZE(src%cellstate, 1), SIZE(src%cellstate, &
&   2)), source=0.0d0)
    dest%cellstate = src%cellstate
    IF (ALLOCATED(dest%cellprimitives)) THEN
      DEALLOCATE(dest%cellprimitives)
    END IF
    ALLOCATE(dest%cellprimitives(SIZE(src%cellprimitives, 1), SIZE(src%&
&   cellprimitives, 2)), source=0.0d0)
    dest%cellprimitives = src%cellprimitives
    IF (ALLOCATED(dest%cellfluxes)) THEN
      DEALLOCATE(dest%cellfluxes)
    END IF
    ALLOCATE(dest%cellfluxes(SIZE(src%cellfluxes, 1), SIZE(src%&
&   cellfluxes, 2)), source=0.0d0)
    dest%cellfluxes = src%cellfluxes
    IF (ALLOCATED(dest%fluxresiduals)) THEN
      DEALLOCATE(dest%fluxresiduals)
    END IF
    ALLOCATE(dest%fluxresiduals(SIZE(src%fluxresiduals, 1), SIZE(src%&
&   fluxresiduals, 2)))
    dest%fluxresiduals = src%fluxresiduals
    IF (ALLOCATED(dest%facefluxes)) THEN
      DEALLOCATE(dest%facefluxes)
    END IF
    ALLOCATE(dest%facefluxes(SIZE(src%facefluxes, 1), SIZE(src%&
&   facefluxes, 2)), source=0.0d0)
    dest%facefluxes = src%facefluxes
  END SUBROUTINE DEEP_COPY_SLN

!  Differentiation of decodesolution_3d in forward (tangent) mode (with options i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4
!):
!   variations   of useful results: [alloc*(sln.cellfluxes) in decodesolution_3d]
!                [alloc*(sln.cellprimitives) in decodesolution_3d]
!                [alloc*(*sln.cellfluxes) in solve] [alloc*(*sln.cellprimitives) in solve]
!                *([alloc*sln in solve].cellfluxes) *([alloc*sln in solve].cellprimitives)
!   with respect to varying inputs: [alloc*(sln.cellfluxes) in decodesolution_3d]
!                [alloc*(sln.cellprimitives) in decodesolution_3d]
!                [alloc*(*sln.cellfluxes) in solve] [alloc*(*sln.cellstate) in solve]
!                [alloc*(*sln.cellprimitives) in solve] *([alloc*sln in solve].cellstate)
!                *([alloc*sln in solve].cellfluxes) *([alloc*sln in solve].cellprimitives)
!   Plus diff mem management of: sln.cellstate:in sln.cellfluxes:in-out
!                sln.cellprimitives:in-out
  SUBROUTINE DECODESOLUTION_3D_D(sln, slnd, fluid)
    IMPLICIT NONE
    TYPE(SOLUTIONSTATE), INTENT(INOUT) :: sln
    TYPE(SOLUTIONSTATE), INTENT(INOUT) :: slnd
    TYPE(FLUIDD), INTENT(IN) :: fluid
    INTEGER(kind=8) :: ncells, i
    INTRINSIC SIZE
    INTRINSIC ALLOCATED
    INTRINSIC NEW_LINE
    ncells = SIZE(sln%cellstate, 1)
! 分配原始变量和通量数组（如果尚未分配）
    IF (.NOT.ALLOCATED(sln%cellprimitives)) THEN
      ALLOCATE(slnd%cellprimitives(ncells, 5), source=0.0d0)
      slnd%cellprimitives = 0.0_8
      ALLOCATE(sln%cellprimitives(ncells, 5), source=0.0d0)
    END IF
    IF (.NOT.ALLOCATED(sln%cellfluxes)) THEN
      ALLOCATE(slnd%cellfluxes(ncells, 15), source=0.0d0)
      slnd%cellfluxes = 0.0_8
      ALLOCATE(sln%cellfluxes(ncells, 15), source=0.0d0)
    END IF
! 解码原始变量并计算通量
    DO i=1,ncells
      CALL DECODEPRIMITIVES3D_D(sln%cellprimitives(i, :), slnd%&
&                         cellprimitives(i, :), sln%cellstate(i, :), &
&                         slnd%cellstate(i, :), fluid)
! 新增：输出前50行sln%cellState和sln%cellPrimitives（在calculateFluxes3D前）
! 输出前50行cellState和cellPrimitives（增大宽度避免溢出）
!        if (i <= 50) then
!            if (i == 1) then
!                print *, new_line('a')//"=== 前50行sln%cellState和sln%cellPrimitives ==="
!                print *, "格式：单元索引 | cellState(5列) | cellPrimitives(5列)"
!            end if
! 关键修改：将F12.6改为F18.6（宽度从12增至18）
!            write(*, '(I5, 10F18.6)') i, &
!                sln%cellState(i,:), &       ! cellState(5列)
!                sln%cellPrimitives(i,:)     ! cellPrimitives(5列)
!       end if
      CALL CALCULATEFLUXES3D_D(sln%cellfluxes(i, :), slnd%cellfluxes(i, &
&                        :), sln%cellprimitives(i, :), slnd%&
&                        cellprimitives(i, :), sln%cellstate(i, :), slnd&
&                        %cellstate(i, :))
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!        	
!        	IF (i <= 4) THEN
      IF (i .EQ. 2210) THEN
        IF (i .EQ. 1) THEN
          PRINT*, NEW_LINE('a')//&
& '=== 前4个单元：slnd 关键数组输出（通量计算后） ==='
          PRINT*, '格式说明：科学计数法(ES24.8)，宽度24位\EF&
&\BC\8C保留8位小数'
        END IF
      END IF
!				WRITE(*, '(A,I3,A)') '--- 单元 ', i, ' ---'
! 第一行：输出slnd%cellprimitives（5列，拆分显示避免拥挤）
!				WRITE(*, '(A,5ES24.8)') '  slnd%cellprimitives: ', slnd%cellprimitives(i, :)
! 第二行：输出slnd%cellfluxes（15列，科学计数法适配大范围数值）
!				WRITE(*, '(A,15ES24.8)') '  slnd%cellfluxes:    ', slnd%cellfluxes(i, :)
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!   			  

    END DO
  END SUBROUTINE DECODESOLUTION_3D_D

  SUBROUTINE DECODESOLUTION_3D(sln, fluid)
    IMPLICIT NONE
    TYPE(SOLUTIONSTATE), INTENT(INOUT) :: sln
    TYPE(FLUIDD), INTENT(IN) :: fluid
    INTEGER(kind=8) :: ncells, i
    INTRINSIC SIZE
    INTRINSIC ALLOCATED
    INTRINSIC NEW_LINE
    ncells = SIZE(sln%cellstate, 1)
! 分配原始变量和通量数组（如果尚未分配）
    IF (.NOT.ALLOCATED(sln%cellprimitives)) THEN
      ALLOCATE(sln%cellprimitives(ncells, 5), source=0.0d0)
    END IF
    IF (.NOT.ALLOCATED(sln%cellfluxes)) THEN
      ALLOCATE(sln%cellfluxes(ncells, 15), source=0.0d0)
    END IF
! 解码原始变量并计算通量
    DO i=1,ncells
      CALL DECODEPRIMITIVES3D(sln%cellprimitives(i, :), sln%cellstate(i&
&                       , :), fluid)
! 新增：输出前50行sln%cellState和sln%cellPrimitives（在calculateFluxes3D前）
! 输出前50行cellState和cellPrimitives（增大宽度避免溢出）
!        if (i <= 50) then
!            if (i == 1) then
!                print *, new_line('a')//"=== 前50行sln%cellState和sln%cellPrimitives ==="
!                print *, "格式：单元索引 | cellState(5列) | cellPrimitives(5列)"
!            end if
! 关键修改：将F12.6改为F18.6（宽度从12增至18）
!            write(*, '(I5, 10F18.6)') i, &
!                sln%cellState(i,:), &       ! cellState(5列)
!                sln%cellPrimitives(i,:)     ! cellPrimitives(5列)
!       end if
      CALL CALCULATEFLUXES3D(sln%cellfluxes(i, :), sln%cellprimitives(i&
&                      , :), sln%cellstate(i, :))
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!        	
!        	IF (i <= 4) THEN
      IF (i .EQ. 2210) THEN
        IF (i .EQ. 1) THEN
          PRINT*, NEW_LINE('a')//&
& '=== 前4个单元：slnd 关键数组输出（通量计算后） ==='
          PRINT*, '格式说明：科学计数法(ES24.8)，宽度24位\EF&
&\BC\8C保留8位小数'
        END IF
      END IF
!				WRITE(*, '(A,I3,A)') '--- 单元 ', i, ' ---'
! 第一行：输出slnd%cellprimitives（5列，拆分显示避免拥挤）
!				WRITE(*, '(A,5ES24.8)') '  slnd%cellprimitives: ', slnd%cellprimitives(i, :)
! 第二行：输出slnd%cellfluxes（15列，科学计数法适配大范围数值）
!				WRITE(*, '(A,15ES24.8)') '  slnd%cellfluxes:    ', slnd%cellfluxes(i, :)
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!   			  

    END DO
  END SUBROUTINE DECODESOLUTION_3D

!  Differentiation of integratefluxes_unstructured3d in forward (tangent) mode (with options i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8
! r4 i4 dr8 r4):
!   variations   of useful results: [alloc*fluxresiduals in integratefluxes_unstructured3d]
!                [alloc*(sln.fluxresiduals) in integratefluxes_unstructured3d]
!                [alloc*(*sln.fluxresiduals) in solve] *([alloc*sln in solve].fluxresiduals)
!   with respect to varying inputs: [alloc*fluxresiduals in integratefluxes_unstructured3d]
!                [alloc*(sln.fluxresiduals) in integratefluxes_unstructured3d]
!                [alloc*(mesh.cvols) in openfoammesh] [alloc*(mesh.favecs) in openfoammesh]
!                [alloc*(*sln.facefluxes) in solve] [alloc*(*sln.fluxresiduals) in solve]
!                *([alloc*sln in solve].fluxresiduals) *([alloc*sln in solve].facefluxes)
!   Plus diff mem management of: fluxresiduals:out mesh.cvols:in
!                mesh.favecs:in sln.fluxresiduals:in-out sln.facefluxes:in
!#=
!   通过面通量计算单元格的通量残差（用于时间步进）
!   残差 = -∇·F（F为通量矢量）
!=#
  SUBROUTINE INTEGRATEFLUXES_UNSTRUCTURED3D_D(mesh, meshd, sln, slnd, &
&   fluxresiduals, fluxresidualsd)
    IMPLICIT NONE
    TYPE(MESHH), INTENT(IN) :: mesh
    TYPE(MESHH_DIFF), INTENT(IN) :: meshd
    TYPE(SOLUTIONSTATE), INTENT(INOUT) :: sln
    TYPE(SOLUTIONSTATE), INTENT(INOUT) :: slnd
    REAL(kind=8), ALLOCATABLE, INTENT(OUT) :: fluxresiduals(:, :)
    REAL(kind=8), ALLOCATABLE, INTENT(OUT) :: fluxresidualsd(:, :)
    INTEGER(kind=8) :: ncells, nfaces, nboundaries, nbdryfaces, meshinfo&
&   (4)
    INTEGER(kind=8) :: nvars, f, v, ownercell, neighbourcell, i1, i2, i&
&   , maxoutput, j
    REAL(kind=8) :: flow
    REAL(kind=8) :: flowd
! 局部变量：meshd%favecs的行数、实际输出数量
    INTEGER :: y1d, min1d
! 局部变量：meshd%cvols的行数、实际输出数量
    INTEGER :: y2d, min2d
    INTRINSIC SIZE
    INTRINSIC MIN
    INTRINSIC ALLOCATED
    INTEGER :: y1
    INTEGER :: min1
    REAL(kind=8) :: temp
! 1. 正确获取网格和变量信息（不依赖未分配的数组）
    CALL UNSTRUCTUREDMESHINFO(mesh, meshinfo)
! 单元总数（有效，非0）
    ncells = meshinfo(1)
    nfaces = meshinfo(2)
    nboundaries = meshinfo(3)
    nbdryfaces = meshinfo(4)
! 从已分配的 cellState 获取变量数（关键修正）
    nvars = SIZE(sln%cellstate, 2)
! 输出前5个mesh.fAVecs和mesh.cVols

    y1 = SIZE(mesh%cvols, 1)
    IF (5 .GT. y1) THEN
      min1 = y1
    ELSE
      min1 = 5
    END IF
! ======================================================================
! 输出前5个 meshd%favecs		
   WRITE(*, *) NEW_LINE('a')//'mesh%fAVecs'
   WRITE(*, '(A,3(E12.6,1X))') 'Face 4466 : ', &
			mesh%favecs(4466, 1), mesh%favecs(4466, 2), mesh%favecs(4466, 3)
   WRITE(*, *) NEW_LINE('a')//'meshd%fAVecs (differential):'
   WRITE(*, '(A,3(E12.6,1X))') 'Diff Face 4466 : ', &
			meshd%favecs(4466, 1), meshd%favecs(4466, 2), meshd%favecs(4466, 3)
   WRITE(*, *) 'First 5 mesh%cVols'
   WRITE(*, '(A,3(E12.6,1X))') 'Cell 2210 :', mesh%cvols(2210)
   WRITE(*, *) 'First 5 meshd%cVols (differential):'
   WRITE(*, '(A,3(E12.6,1X))') 'Diff Cell 2210 :', meshd%cvols(2210)
!		y1d = SIZE(meshd%favecs, 1)  ! 获取meshd%favecs的总行数（面数）
!		min1d = MIN(5, y1d)          ! 最多输出5个面，避免越界
!		DO f=1,min1d
!		  WRITE(*, '(A,I3,A,3(E12.6,1X))') 'Diff Face ', f, ': ', &
!			meshd%favecs(f, 1), meshd%favecs(f, 2), meshd%favecs(f, 3)
!		END DO
! 输出前5个 meshd%cvols		
!		WRITE(*, *) 'First 5 meshd%cVols (differential):'
!		y2d = SIZE(meshd%cvols, 1)  ! 获取meshd%cvols的总行数（单元数）
!		min2d = MIN(5, y2d)          ! 最多输出5个单元，避免越界
!		DO f=1,min2d
!		  WRITE(*, '(A,I3,A,E12.6)') 'Diff Cell ', f, ': ', meshd%cvols(f)
!		END DO
! ======================================================================
! 2. 确保 sln%fluxResiduals 已分配（关键修正）
    IF (((.NOT.ALLOCATED(sln%fluxresiduals)) .OR. SIZE(sln%fluxresiduals&
&       , 1) .NE. ncells) .OR. SIZE(sln%fluxresiduals, 2) .NE. nvars) &
&   THEN
! 若未分配或维度不匹配，重新分配
      IF (ALLOCATED(sln%fluxresiduals)) THEN
        IF (ALLOCATED(slnd%fluxresiduals)) THEN
          DEALLOCATE(slnd%fluxresiduals)
        END IF
        DEALLOCATE(sln%fluxresiduals)
      END IF
      ALLOCATE(slnd%fluxresiduals(ncells, nvars), source=0.0d0)
      slnd%fluxresiduals = 0.0_8
      ALLOCATE(sln%fluxresiduals(ncells, nvars), source=0.0d0)
    END IF
! 3. 重置残差矩阵
    slnd%fluxresiduals = 0.0_8
    sln%fluxresiduals = 0.0d0
! 4. 通量积分（核心逻辑）
    DO f=1,nfaces
      ownercell = mesh%faces(f, 1)
      neighbourcell = mesh%faces(f, 2)
      DO v=1,nvars
        i1 = (v-1)*3 + 1
        i2 = i1 + 2
! 通量点积
        CALL DOT_PRODUCT_REAL_D(sln%facefluxes(f, i1:i2), slnd%&
&                         facefluxes(f, i1:i2), mesh%favecs(f, :), meshd&
&                         %favecs(f, :), flow, flowd, 3)
! 添加输出 - 只输出前10个面的flow值
        IF (f==4279 .OR. f==4466 .OR. f==4467 .OR. f==36975 .OR. f==37074 .OR. f==55587) THEN
		  WRITE(*, '(A,I6,A,I3,A,E15.6,A,E15.6)') 'Face ', f, &
	&            ' Var ', v, ' Flow = ', flow, ' Flowd = ', flowd
		END IF
        slnd%fluxresiduals(ownercell, v) = slnd%fluxresiduals(ownercell&
&         , v) - flowd
        sln%fluxresiduals(ownercell, v) = sln%fluxresiduals(ownercell, v&
&         ) - flow
! 邻接单元格残差（非边界）
        IF (neighbourcell .GT. 0 .AND. neighbourcell .LE. ncells) THEN
! 避免边界的-1
          slnd%fluxresiduals(neighbourcell, v) = slnd%fluxresiduals(&
&           neighbourcell, v) + flowd
          sln%fluxresiduals(neighbourcell, v) = sln%fluxresiduals(&
&           neighbourcell, v) + flow
        END IF
      END DO
    END DO
    IF (15 .GT. ncells) THEN
      maxoutput = ncells
    ELSE
      maxoutput = 15
    END IF
    WRITE(*, *) '除以体积前sln%fluxresiduals:'
!		do i = 1, maxOutput
!		write(*, '(A,I3,A,*(E12.6,1X))') "Cell ", i, ": ", (sln%fluxResiduals(i,j), j=1,nVars)
    WRITE(*, '(A,*(E12.6,1X))') 'Cell 210: ', (sln%fluxresiduals(2210, j), j=1,nvars)
	WRITE(*, *) '除以体积前slnd%fluxresiduals'
    WRITE(*, '(A,*(E12.6,1X))') 'Cell 2210: ', (slnd%fluxresiduals(2210, j), j=1,nvars)
	WRITE(*, *) '第2210个单元mesh%cVols:'
    print "(A, F0.6)", "  单元体积: ", mesh%cVols(2210)
    WRITE(*, *) '第2210个单元meshd%cVols:'
    print "(A, F0.6)", "  单元体积: ", meshd%cVols(2210)
!		end do
! 5. 除以单元格体积（单位体积残差）
    DO v=1,nvars
! f 实际是单元索引（建议重命名为 c 更清晰）
      DO f=1,ncells
		temp = sln%fluxresiduals(f, v)/mesh%cvols(f)
		slnd%fluxresiduals(f, v) = slnd%fluxresiduals(f, v)/mesh%cvols(f)&
		&-sln%fluxresiduals(f, v)*meshd%cvols(f)/(mesh%cvols(f)*mesh%cvols(f))
        sln%fluxresiduals(f, v) = temp
      END DO
    END DO
! 6. 分配并返回 fluxResiduals
    ALLOCATE(fluxresidualsd(ncells, nvars), source=0.0d0)
    fluxresidualsd = 0.0_8
    ALLOCATE(fluxresiduals(ncells, nvars), source=0.0d0)
    fluxresidualsd = slnd%fluxresiduals
    fluxresiduals = sln%fluxresiduals
  END SUBROUTINE INTEGRATEFLUXES_UNSTRUCTURED3D_D

!#=
!   通过面通量计算单元格的通量残差（用于时间步进）
!   残差 = -∇·F（F为通量矢量）
!=#
  SUBROUTINE INTEGRATEFLUXES_UNSTRUCTURED3D(mesh, sln, fluxresiduals)
    IMPLICIT NONE
    TYPE(MESHH), INTENT(IN) :: mesh
    TYPE(SOLUTIONSTATE), INTENT(INOUT) :: sln
    REAL(kind=8), ALLOCATABLE, INTENT(OUT) :: fluxresiduals(:, :)
    INTEGER(kind=8) :: ncells, nfaces, nboundaries, nbdryfaces, meshinfo&
&   (4)
    INTEGER(kind=8) :: nvars, f, v, ownercell, neighbourcell, i1, i2, i&
&   , maxoutput, j
    REAL(kind=8) :: flow
! 局部变量：meshd%favecs的行数、实际输出数量
    INTEGER :: y1d, min1d
! 局部变量：meshd%cvols的行数、实际输出数量
    INTEGER :: y2d, min2d
    INTRINSIC SIZE
    INTRINSIC MIN
    INTRINSIC ALLOCATED
    INTEGER :: y1
    INTEGER :: min1
! 1. 正确获取网格和变量信息（不依赖未分配的数组）
    CALL UNSTRUCTUREDMESHINFO(mesh, meshinfo)
! 单元总数（有效，非0）
    ncells = meshinfo(1)
    nfaces = meshinfo(2)
    nboundaries = meshinfo(3)
    nbdryfaces = meshinfo(4)
! 从已分配的 cellState 获取变量数（关键修正）
    nvars = SIZE(sln%cellstate, 2)
! 输出前5个mesh.fAVecs和mesh.cVols

    y1 = SIZE(mesh%cvols, 1)
    IF (5 .GT. y1) THEN
      min1 = y1
    ELSE
      min1 = 5
    END IF
! ======================================================================
! 输出前5个 meshd%favecs		
!		WRITE(*, *) NEW_LINE('a')//'First 5 meshd%fAVecs (differential):'
!		y1d = SIZE(meshd%favecs, 1)  ! 获取meshd%favecs的总行数（面数）
!		min1d = MIN(5, y1d)          ! 最多输出5个面，避免越界
!		DO f=1,min1d
!		  WRITE(*, '(A,I3,A,3(E12.6,1X))') 'Diff Face ', f, ': ', &
!			meshd%favecs(f, 1), meshd%favecs(f, 2), meshd%favecs(f, 3)
!		END DO
! 输出前5个 meshd%cvols		
!		WRITE(*, *) 'First 5 meshd%cVols (differential):'
!		y2d = SIZE(meshd%cvols, 1)  ! 获取meshd%cvols的总行数（单元数）
!		min2d = MIN(5, y2d)          ! 最多输出5个单元，避免越界
!		DO f=1,min2d
!		  WRITE(*, '(A,I3,A,E12.6)') 'Diff Cell ', f, ': ', meshd%cvols(f)
!		END DO
! ======================================================================
! 2. 确保 sln%fluxResiduals 已分配（关键修正）
    IF (((.NOT.ALLOCATED(sln%fluxresiduals)) .OR. SIZE(sln%fluxresiduals&
&       , 1) .NE. ncells) .OR. SIZE(sln%fluxresiduals, 2) .NE. nvars) &
&   THEN
! 若未分配或维度不匹配，重新分配
      IF (ALLOCATED(sln%fluxresiduals)) THEN
        DEALLOCATE(sln%fluxresiduals)
      END IF
      ALLOCATE(sln%fluxresiduals(ncells, nvars), source=0.0d0)
    END IF
! 3. 重置残差矩阵
    sln%fluxresiduals = 0.0d0
! 4. 通量积分（核心逻辑）
    DO f=1,nfaces
      ownercell = mesh%faces(f, 1)
      neighbourcell = mesh%faces(f, 2)
      DO v=1,nvars
        i1 = (v-1)*3 + 1
        i2 = i1 + 2
! 通量点积
        CALL DOT_PRODUCT_REAL(sln%facefluxes(f, i1:i2), mesh%favecs(f, :&
&                       ), flow, 3)
! 添加输出 - 只输出前10个面的flow值
        IF (f .LE. 10) WRITE(*, '(A,I3,A,I3,A,E12.5)') 'Face ', f, &
&                      ' Var ', v, ' Flow = ', flow
        sln%fluxresiduals(ownercell, v) = sln%fluxresiduals(ownercell, v&
&         ) - flow
! 邻接单元格残差（非边界）
        IF (neighbourcell .GT. 0 .AND. neighbourcell .LE. ncells) THEN
! 避免边界的-1
          sln%fluxresiduals(neighbourcell, v) = sln%fluxresiduals(&
&           neighbourcell, v) + flow
        END IF
      END DO
    END DO
    IF (15 .GT. ncells) THEN
      maxoutput = ncells
    ELSE
      maxoutput = 15
    END IF
    WRITE(*, *) '3D:Flux residuals for first 15 cells:'
!		do i = 1, maxOutput
!		write(*, '(A,I3,A,*(E12.6,1X))') "Cell ", i, ": ", (sln%fluxResiduals(i,j), j=1,nVars)
    WRITE(*, '(A,I3,A,*(E12.6,1X))') 'Cell ', 2210, ': ', (sln%&
&   fluxresiduals(2210, j), j=1,nvars)
!		end do
! 5. 除以单元格体积（单位体积残差）
    DO v=1,nvars
! f 实际是单元索引（建议重命名为 c 更清晰）
      DO f=1,ncells
        sln%fluxresiduals(f, v) = sln%fluxresiduals(f, v)/mesh%cvols(f)
      END DO
    END DO
! 6. 分配并返回 fluxResiduals
    ALLOCATE(fluxresiduals(ncells, nvars), source=0.0d0)
    fluxresiduals = sln%fluxresiduals
  END SUBROUTINE INTEGRATEFLUXES_UNSTRUCTURED3D

! 8.output.jl
! 将单元原始变量写入重启文件!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  SUBROUTINE WRITERESTARTFILE(cellprimitives, path)
    IMPLICIT NONE
    REAL(kind=8), INTENT(IN) :: cellprimitives(:, :)
    CHARACTER(len=*), INTENT(IN), OPTIONAL :: path
    CHARACTER(len=256) :: filepath
    INTRINSIC PRESENT
    IF (PRESENT(path)) THEN
      filepath = path
    ELSE
      filepath = 'FvCFDRestart.txt'
    END IF
    OPEN(unit=10, file=filepath, status='replace', action='write') 
    WRITE(10, *) cellprimitives
    CLOSE(10) 
  END SUBROUTINE WRITERESTARTFILE

! $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
! 2. 修正调用writeVTKFile时的参数传递（确保points为二维数组）
  SUBROUTINE OUTPUTVTK(meshpath, cellprimitives, filename, point_update)
    IMPLICIT NONE
! （参数声明不变）
    CHARACTER(len=*), INTENT(IN) :: meshpath
    REAL(kind=8), INTENT(IN) :: cellprimitives(:, :)
    CHARACTER(len=*), INTENT(IN), OPTIONAL :: filename
    REAL*8, ALLOCATABLE, INTENT(IN) :: point_update(:, :)
! （局部变量声明不变）
    REAL(kind=8), ALLOCATABLE :: pointlocations(:, :)
    TYPE(CELLLARRAY) :: cells
!$AD NONDIFF  ! 明确该变量为非微分
    CHARACTER(len=256) :: vtkfilename
    INTEGER(kind=8) :: ncells, npoints, i
    INTRINSIC SIZE
    INTRINSIC PRESENT
    INTRINSIC TRIM
! 获取点坐标和单元数据（确保pointLocations是二维数组）
    CALL OPENFOAMMESH_FINDCELLPTS(meshpath, pointlocations, cells, &
&                           point_update)
    ncells = SIZE(cells%cells)
! 原维度：nPoints×3
    npoints = SIZE(pointlocations, 1)
! 转置点坐标（转为3×nPoints，与Julia一致）
! 转置后pointLocations为3×nPoints
    CALL TRANSPOSEPOINTS(pointlocations)
! 修正调用方式：传递转置后的pointLocations（二维数组）
    IF (PRESENT(filename)) THEN
      vtkfilename = TRIM(filename)//'.vtk'
    ELSE
      vtkfilename = 'solution.vtk'
    END IF
! vtkCellTypes数组
    CALL WRITEVTKFILE(vtkfilename, pointlocations, cells, cellprimitives&
&               , npoints, ncells, (/1_int64, 3_int64, 5_int64, 10_int64&
&               , 14_int64, 13_int64, -1_int64, 12_int64/))
! （其余代码不变）
  END SUBROUTINE OUTPUTVTK

  SUBROUTINE WRITEOUTPUT(cellprimitives, restartfile, meshpath, &
&   createrestartfile, createvtkoutput, point_update)
    IMPLICIT NONE
! 输入参数（与Julia函数完全对应）
! 单元原始数据
    REAL(kind=8), INTENT(IN) :: cellprimitives(:, :)
! 重启文件名
    CHARACTER(len=*), INTENT(IN) :: restartfile
! 网格路径
    CHARACTER(len=*), INTENT(IN) :: meshpath
! 是否创建重启文件
    LOGICAL, INTENT(IN) :: createrestartfile
! 是否创建VTK输出
    LOGICAL, INTENT(IN) :: createvtkoutput
    REAL*8, ALLOCATABLE, INTENT(IN) :: point_update(:, :)
! 局部变量
    INTEGER(kind=8) :: unit, iostat
    CHARACTER(len=256) :: solnname
    LOGICAL :: exists
    INTRINSIC TRIM
! 1. 处理重启文件（对应Julia的if createRestartFile）
    IF (createrestartfile) THEN
      PRINT*, 'Writing Restart File: ', TRIM(restartfile)
! 调用重启文件写入子程序
      CALL WRITERESTARTFILE(cellprimitives, restartfile)
    END IF
! 2. 处理VTK输出（核心修改：删除系统命令、文件列表、序号查找，改用固定文件名）
    IF (createvtkoutput) THEN
! 固定文件名，无需序号查找
      solnname = 'solution_001.vtk'
      PRINT*, 'Writing VTK File: ', TRIM(solnname)
! 原调用逻辑不变
      CALL OUTPUTVTK(meshpath, cellprimitives, solnname, point_update)
    END IF
  END SUBROUTINE WRITEOUTPUT

  SUBROUTINE WRITEVTKFILE(filename, points, cells, primitives, npts, &
&   ncells, vtktypes)
    IMPLICIT NONE
    CHARACTER(len=*), INTENT(IN) :: filename
! 3×nPts（x,y,z）
    REAL(kind=8), INTENT(IN) :: points(:, :)
    TYPE(CELLLARRAY), INTENT(IN) :: cells
!$AD NONDIFF  ! 明确该变量为非微分
! 流场数据：[nCells×5] = [P, T, Ux, Uy, Uz]
    REAL(kind=8), INTENT(IN) :: primitives(:, :)
    INTEGER(kind=8), INTENT(IN) :: npts, ncells
    INTEGER(kind=8), INTENT(IN) :: vtktypes(8)
    INTEGER(kind=8) :: fileunit, i, j, n, celltype, ptidx, connoffset
    REAL(kind=8) :: p, t, ux, uy, uz
! Fortran 95兼容：手动定义无穷大阈值（替代isinf）
! 超过此值视为无穷大
    REAL(kind=8), PARAMETER :: inf_threshold=1.0d300
    INTRINSIC SIZE
    INTRINSIC MERGE
! 2. 预检查：流场数据维度匹配
    IF (SIZE(primitives, 1) .NE. ncells .OR. SIZE(primitives, 2) .LT. 5&
&   ) THEN
      PRINT*, 'Error: 流场数据维度不匹配（单元数=', ncells&
&     , ', 数据行数=', SIZE(primitives, 1), '）'
      RETURN
    ELSE
! 3. 写入VTK文件
! 显式初始化
      CALL GET_FREE_UNIT(fileunit)
      OPEN(unit=fileunit, file=filename, status='replace', action=&
&    'write', form='formatted') 
! 3.1 VTK文件头
      WRITE(fileunit, '(A)') '# vtk DataFile Version 3.0'
      WRITE(fileunit, '(A)') 'Generated by BuFlowModule'
      WRITE(fileunit, '(A)') 'ASCII'
      WRITE(fileunit, '(A)') 'DATASET UNSTRUCTURED_GRID'
! 3.2 点坐标
      WRITE(fileunit, '(A,I0,A)') 'POINTS ', npts, ' double'
      DO i=1,npts
        WRITE(fileunit, '(3F16.8)') points(1, i), points(2, i), points(3&
&       , i)
      END DO
! 3.3 单元连接性
      connoffset = 0
      DO i=1,ncells
        connoffset = connoffset + SIZE(cells%cells(i)%pointindices) + 1
      END DO
      WRITE(fileunit, '(A,I0,A,I0)') 'CELLS ', ncells, ' ', connoffset
      DO i=1,ncells
        n = SIZE(cells%cells(i)%pointindices)
        WRITE(fileunit, '(I4)', advance='no') n
        DO j=1,n
! 0-based索引
          ptidx = cells%cells(i)%pointindices(j) - 1
          WRITE(fileunit, '(I6)', advance='no') ptidx
        END DO
        WRITE(fileunit, *) 
      END DO
! 3.4 单元类型
      WRITE(fileunit, '(A,I0)') 'CELL_TYPES ', ncells
      DO i=1,ncells
        n = SIZE(cells%cells(i)%pointindices)
        celltype = MERGE(vtktypes(n), 1_int64, n .GE. 1 .AND. n .LE. 8)
        WRITE(fileunit, '(I4)') celltype
      END DO
! 3.5 流场数据（兼容Fortran 95，无isinf）
      WRITE(fileunit, '(A,I0)') 'CELL_DATA ', ncells
! 3.5.1 压力场P
      WRITE(fileunit, '(A)') 'SCALARS P double 1'
      WRITE(fileunit, '(A)') 'LOOKUP_TABLE default'
      DO i=1,ncells
        p = primitives(i, 1)
! Fortran 95兼容：处理nan和无穷大（nan的特征是不等于自身）
!		    if (P /= P .or. abs(P) > INF_THRESHOLD) P = 0.0d0  ! P /= P 表示nan
        WRITE(fileunit, '(F16.8)') p
      END DO
! 3.5.2 温度场T
      WRITE(fileunit, '(A)') 'SCALARS T double 1'
      WRITE(fileunit, '(A)') 'LOOKUP_TABLE default'
      DO i=1,ncells
        t = primitives(i, 2)
!		    if (T /= T .or. abs(T) > INF_THRESHOLD) T = 0.0d0
        WRITE(fileunit, '(F16.8)') t
      END DO
! 3.5.3 速度场U
      WRITE(fileunit, '(A)') 'VECTORS U double'
      DO i=1,ncells
        ux = primitives(i, 3)
        uy = primitives(i, 4)
        uz = primitives(i, 5)
! 处理无效值
!		    if (Ux /= Ux .or. abs(Ux) > INF_THRESHOLD) Ux = 0.0d0
!		    if (Uy /= Uy .or. abs(Uy) > INF_THRESHOLD) Uy = 0.0d0
!		    if (Uz /= Uz .or. abs(Uz) > INF_THRESHOLD) Uz = 0.0d0
        WRITE(fileunit, '(3F16.8)') ux, uy, uz
      END DO
      CLOSE(fileunit) 
    END IF
  END SUBROUTINE WRITEVTKFILE

  SUBROUTINE WRITEOUTPUT_D(cellprimitives, cellprimitivesd, restartfile&
&   , meshpath, createrestartfile, createvtkoutput, point_update)
    IMPLICIT NONE
! 输入参数（与Julia函数完全对应）
! 单元原始数据
    REAL(kind=8), INTENT(IN) :: cellprimitives(:, :), cellprimitivesd(:&
&   , :)
! 重启文件名
    CHARACTER(len=*), INTENT(IN) :: restartfile
! 网格路径
    CHARACTER(len=*), INTENT(IN) :: meshpath
! 是否创建重启文件
    LOGICAL, INTENT(IN) :: createrestartfile
! 是否创建VTK输出
    LOGICAL, INTENT(IN) :: createvtkoutput
    REAL*8, ALLOCATABLE, INTENT(IN) :: point_update(:, :)
! 局部变量
    INTEGER(kind=8) :: unit, iostat
    CHARACTER(len=256) :: solnname
    LOGICAL :: exists
    INTRINSIC TRIM
! 1. 处理重启文件（对应Julia的if createRestartFile）
    IF (createrestartfile) THEN
      PRINT*, 'Writing Restart File: ', TRIM(restartfile)
! 调用重启文件写入子程序
      CALL WRITERESTARTFILE(cellprimitives, restartfile)
    END IF
! 2. 处理VTK输出（核心修改：删除系统命令、文件列表、序号查找，改用固定文件名）
    IF (createvtkoutput) THEN
! 固定文件名，无需序号查找
      solnname = 'solution_001.vtk'
      PRINT*, 'Writing VTK File: ', TRIM(solnname)
! 原调用逻辑不变
      CALL OUTPUTVTK_D(meshpath, cellprimitives, cellprimitivesd, &
&                solnname, point_update)
    END IF
  END SUBROUTINE WRITEOUTPUT_D

! 2. 修正调用writeVTKFile时的参数传递（确保points为二维数组）
  SUBROUTINE OUTPUTVTK_D(meshpath, cellprimitives, cellprimitivesd, &
&   filename, point_update)
    IMPLICIT NONE
! （参数声明不变）
    CHARACTER(len=*), INTENT(IN) :: meshpath
    REAL(kind=8), INTENT(IN) :: cellprimitives(:, :), cellprimitivesd(:&
&   , :)
    CHARACTER(len=*), INTENT(IN), OPTIONAL :: filename
    REAL*8, ALLOCATABLE, INTENT(IN) :: point_update(:, :)
! （局部变量声明不变）
    REAL(kind=8), ALLOCATABLE :: pointlocations(:, :)
    TYPE(CELLLARRAY) :: cells
!$AD NONDIFF  ! 明确该变量为非微分
    CHARACTER(len=256) :: vtkfilename
    INTEGER(kind=8) :: ncells, npoints, i
    INTRINSIC SIZE
    INTRINSIC PRESENT
    INTRINSIC TRIM
! 获取点坐标和单元数据（确保pointLocations是二维数组）
    CALL OPENFOAMMESH_FINDCELLPTS(meshpath, pointlocations, cells, &
&                           point_update)
    ncells = SIZE(cells%cells)
! 原维度：nPoints×3
    npoints = SIZE(pointlocations, 1)
! 转置点坐标（转为3×nPoints，与Julia一致）
! 转置后pointLocations为3×nPoints
    CALL TRANSPOSEPOINTS(pointlocations)
! 修正调用方式：传递转置后的pointLocations（二维数组）
    IF (PRESENT(filename)) THEN
      vtkfilename = TRIM(filename)//'.vtk'
    ELSE
      vtkfilename = 'solution.vtk'
    END IF
! 新增cellPrimitivesd
! vtkCellTypes数组
    CALL WRITEVTKFILE_D(vtkfilename, pointlocations, cells, &
&                 cellprimitives, cellprimitivesd, npoints, ncells, (/&
&                 1_int64, 3_int64, 5_int64, 10_int64, 14_int64, &
&                 13_int64, -1_int64, 12_int64/))
! （其余代码不变）
  END SUBROUTINE OUTPUTVTK_D

  SUBROUTINE WRITEVTKFILE_D(filename, points, cells, primitives, &
&   cellprimitivesd, npts, ncells, vtktypes)
    IMPLICIT NONE
    CHARACTER(len=*), INTENT(IN) :: filename
! 3×nPts（x,y,z）
    REAL(kind=8), INTENT(IN) :: points(:, :)
    TYPE(CELLLARRAY), INTENT(IN) :: cells
!$AD NONDIFF  ! 明确该变量为非微分
! 流场数据：[nCells×5] = [P, T, Ux, Uy, Uz]
    REAL(kind=8), INTENT(IN) :: primitives(:, :), cellprimitivesd(:, :)
    INTEGER(kind=8), INTENT(IN) :: npts, ncells
    INTEGER(kind=8), INTENT(IN) :: vtktypes(8)
    INTEGER(kind=8) :: fileunit, i, j, n, celltype, ptidx, connoffset
    REAL(kind=8) :: p, t, ux, uy, uz, p_t, t_t, ux_t, uy_t, uz_t
! Fortran 95兼容：手动定义无穷大阈值（替代isinf）
! 超过此值视为无穷大
    REAL(kind=8), PARAMETER :: inf_threshold=1.0d300
    INTRINSIC SIZE
    INTRINSIC MERGE
    INTRINSIC ABS
    INTRINSIC SIGN
    REAL(kind=8) :: abs0
    REAL(kind=8) :: abs1
    REAL(kind=8) :: abs2
    REAL(kind=8) :: abs3
    REAL(kind=8) :: abs4
! 2. 预检查：流场数据维度匹配
    IF (SIZE(primitives, 1) .NE. ncells .OR. SIZE(primitives, 2) .LT. 5&
&   ) THEN
      PRINT*, 'Error: 流场数据维度不匹配（单元数=', ncells&
&     , ', 数据行数=', SIZE(primitives, 1), '）'
      RETURN
    ELSE
! 3. 写入VTK文件
! 显式初始化
      CALL GET_FREE_UNIT(fileunit)
      OPEN(unit=fileunit, file=filename, status='replace', action=&
&    'write', form='formatted') 
! 3.1 VTK文件头
      WRITE(fileunit, '(A)') '# vtk DataFile Version 3.0'
      WRITE(fileunit, '(A)') 'Generated by BuFlowModule'
      WRITE(fileunit, '(A)') 'ASCII'
      WRITE(fileunit, '(A)') 'DATASET UNSTRUCTURED_GRID'
! 3.2 点坐标
      WRITE(fileunit, '(A,I0,A)') 'POINTS ', npts, ' double'
      DO i=1,npts
        WRITE(fileunit, '(3F16.8)') points(1, i), points(2, i), points(3&
&       , i)
      END DO
! 3.3 单元连接性
      connoffset = 0
      DO i=1,ncells
        connoffset = connoffset + SIZE(cells%cells(i)%pointindices) + 1
      END DO
      WRITE(fileunit, '(A,I0,A,I0)') 'CELLS ', ncells, ' ', connoffset
      DO i=1,ncells
        n = SIZE(cells%cells(i)%pointindices)
        WRITE(fileunit, '(I4)', advance='no') n
        DO j=1,n
! 0-based索引
          ptidx = cells%cells(i)%pointindices(j) - 1
          WRITE(fileunit, '(I6)', advance='no') ptidx
        END DO
        WRITE(fileunit, *) 
      END DO
! 3.4 单元类型
      WRITE(fileunit, '(A,I0)') 'CELL_TYPES ', ncells
      DO i=1,ncells
        n = SIZE(cells%cells(i)%pointindices)
        celltype = MERGE(vtktypes(n), 1_int64, n .GE. 1 .AND. n .LE. 8)
        WRITE(fileunit, '(I4)') celltype
      END DO
! 3.5 流场数据（兼容Fortran 95，无isinf）
      WRITE(fileunit, '(A,I0)') 'CELL_DATA ', ncells
! 3.5.1 压力场P
      WRITE(fileunit, '(A)') 'SCALARS P double 1'
      WRITE(fileunit, '(A)') 'LOOKUP_TABLE default'
      DO i=1,ncells
        p = primitives(i, 1)
! Fortran 95兼容：处理nan和无穷大（nan的特征是不等于自身）
!		    if (P /= P .or. abs(P) > INF_THRESHOLD) P = 0.0d0  ! P /= P 表示nan
        WRITE(fileunit, '(F16.8)') p
      END DO
! 3.5.2 温度场T
      WRITE(fileunit, '(A)') 'SCALARS T double 1'
      WRITE(fileunit, '(A)') 'LOOKUP_TABLE default'
      DO i=1,ncells
        t = primitives(i, 2)
!		    if (T /= T .or. abs(T) > INF_THRESHOLD) T = 0.0d0
        WRITE(fileunit, '(F16.8)') t
      END DO
! 3.5.3 速度场U
      WRITE(fileunit, '(A)') 'VECTORS U double'
      DO i=1,ncells
        ux = primitives(i, 3)
        uy = primitives(i, 4)
        uz = primitives(i, 5)
! 处理无效值
!		    if (Ux /= Ux .or. abs(Ux) > INF_THRESHOLD) Ux = 0.0d0
!		    if (Uy /= Uy .or. abs(Uy) > INF_THRESHOLD) Uy = 0.0d0
!		    if (Uz /= Uz .or. abs(Uz) > INF_THRESHOLD) Uz = 0.0d0
        WRITE(fileunit, '(3F16.8)') ux, uy, uz
      END DO
! 4.1 P_tagent（修改格式为科学计数法）
      WRITE(fileunit, '(A)') 'SCALARS P_tagent double 1'
      WRITE(fileunit, '(A)') 'LOOKUP_TABLE default'
      DO i=1,ncells
        p_t = cellprimitivesd(i, 1)
        IF (p_t .GE. 0.) THEN
          abs0 = p_t
        ELSE
          abs0 = -p_t
        END IF
! 限制超大值（避免格式溢出）
! 超过1e20的用1e20替代
        IF (abs0 .GT. 1d20) p_t = SIGN(1d20, p_t)
! ES格式：科学计数法，适配大数值
        WRITE(fileunit, '(ES16.8)') p_t
      END DO
! 4.2 T_tagent（同上述修改）
      WRITE(fileunit, '(A)') 'SCALARS T_tagent double 1'
      WRITE(fileunit, '(A)') 'LOOKUP_TABLE default'
      DO i=1,ncells
        t_t = cellprimitivesd(i, 2)
        IF (t_t .GE. 0.) THEN
          abs1 = t_t
        ELSE
          abs1 = -t_t
        END IF
        IF (abs1 .GT. 1d20) t_t = SIGN(1d20, t_t)
        WRITE(fileunit, '(ES16.8)') t_t
      END DO
! 4.3 U_tagent 向量（同上述修改）
      WRITE(fileunit, '(A)') 'VECTORS U_tagent double'
      DO i=1,ncells
        ux_t = cellprimitivesd(i, 3)
        uy_t = cellprimitivesd(i, 4)
        uz_t = cellprimitivesd(i, 5)
        IF (ux_t .GE. 0.) THEN
          abs2 = ux_t
        ELSE
          abs2 = -ux_t
        END IF
        IF (abs2 .GT. 1d20) ux_t = SIGN(1d20, ux_t)
        IF (uy_t .GE. 0.) THEN
          abs3 = uy_t
        ELSE
          abs3 = -uy_t
        END IF
        IF (abs3 .GT. 1d20) uy_t = SIGN(1d20, uy_t)
        IF (uz_t .GE. 0.) THEN
          abs4 = uz_t
        ELSE
          abs4 = -uz_t
        END IF
        IF (abs4 .GT. 1d20) uz_t = SIGN(1d20, uz_t)
! 向量也用科学计数法
        WRITE(fileunit, '(3ES16.8)') ux_t, uy_t, uz_t
      END DO
      CLOSE(fileunit) 
    END IF
  END SUBROUTINE WRITEVTKFILE_D

! 3. 确认transposePoints子程序的正确性（保持不变）
  SUBROUTINE TRANSPOSEPOINTS(points)
    IMPLICIT NONE
    REAL(kind=8), ALLOCATABLE, INTENT(INOUT) :: points(:, :)
    REAL(kind=8), ALLOCATABLE :: temp(:, :)
    INTEGER(kind=8) :: i, j, npoints
    INTRINSIC SIZE
    INTRINSIC MOVE_ALLOC
! 原维度：nPoints×3
    npoints = SIZE(points, 1)
    ALLOCATE(temp(3, npoints), source=0.0d0)
! 转置为3×nPoints
    DO i=1,npoints
      DO j=1,3
! 原(i,j) → 新(j,i)
        temp(j, i) = points(i, j)
      END DO
    END DO
    DEALLOCATE(points)
! 转置后points为3×nPoints
    CALL MOVE_ALLOC(temp, points)
!		!$AD call move_alloc_int(temp, face_nums)  ! Tapenade 使用（整数一维数组）
  END SUBROUTINE TRANSPOSEPOINTS

!  Differentiation of ltseuler in forward (tangent) mode (with options i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4):
!   variations   of useful results: [alloc*unit_vec in normalize]
!                [alloc*surfaceareas in smoothtimestepp] [alloc*timefluxes in smoothtimestepp]
!                [alloc*updated_dt in smoothtimestepp] [alloc*surfaceareas in smoothtimestep]
!                [alloc*timefluxes in smoothtimestep] [alloc*updated_dt in smoothtimestep]
!                [alloc*fluxresiduals in integratefluxes_unstructured3d]
!                [alloc*(sln.fluxresiduals) in integratefluxes_unstructured3d]
!                [alloc*(sln.cellfluxes) in decodesolution_3d]
!                [alloc*(sln.cellprimitives) in decodesolution_3d]
!                [alloc*deltas in facedeltas] [alloc*facevals in maxinterp]
!                [alloc*grad in greengaussgrad] [alloc*facevals in greengaussgrad]
!                [alloc*fd in unstructured_jstflux] [alloc*diffusionflux in unstructured_jstflux]
!                [alloc*eps2 in unstructured_jstflux] [alloc*eps in unstructured_jsteps]
!                [alloc*eps4 in unstructured_jsteps] [alloc*eps2 in unstructured_jsteps]
!                [alloc*rj in unstructured_jsteps] [alloc*sj in unstructured_jsteps]
!                [alloc*gradp in unstructured_jsteps] [alloc*p_matrix in unstructured_jsteps]
!                [alloc*p in unstructured_jsteps] [alloc*dt in solve]
!                [alloc*(*sln.facefluxes) in solve] [alloc*(*sln.fluxresiduals) in solve]
!                [alloc*(*sln.cellfluxes) in solve] [alloc*(*sln.cellstate) in solve]
!                [alloc*(*sln.cellprimitives) in solve] *([alloc*sln in solve].cellstate)
!                *([alloc*sln in solve].cellfluxes) *([alloc*sln in solve].cellprimitives)
!                *([alloc*sln in solve].fluxresiduals) *([alloc*sln in solve].facefluxes)
!                [alloc*facevel in cfl] [alloc*cellrhot in cfl]
!                [alloc*facerhot in cfl]
!   with respect to varying inputs: [alloc*unit_vec in normalize]
!                [alloc*surfaceareas in smoothtimestepp] [alloc*timefluxes in smoothtimestepp]
!                [alloc*updated_dt in smoothtimestepp] [alloc*surfaceareas in smoothtimestep]
!                [alloc*timefluxes in smoothtimestep] [alloc*updated_dt in smoothtimestep]
!                [alloc*fluxresiduals in integratefluxes_unstructured3d]
!                [alloc*(sln.fluxresiduals) in integratefluxes_unstructured3d]
!                [alloc*(sln.cellfluxes) in decodesolution_3d]
!                [alloc*(sln.cellprimitives) in decodesolution_3d]
!                [alloc*deltas in facedeltas] [alloc*facevals in maxinterp]
!                [alloc*grad in greengaussgrad] [alloc*facevals in greengaussgrad]
!                [alloc*(mesh.ccenters) in openfoammesh] [alloc*(mesh.cvols) in openfoammesh]
!                [alloc*(mesh.fcenters) in openfoammesh] [alloc*(mesh.favecs) in openfoammesh]
!                [alloc*fd in unstructured_jstflux] [alloc*diffusionflux in unstructured_jstflux]
!                [alloc*eps2 in unstructured_jstflux] [alloc*eps in unstructured_jsteps]
!                [alloc*eps4 in unstructured_jsteps] [alloc*eps2 in unstructured_jsteps]
!                [alloc*rj in unstructured_jsteps] [alloc*sj in unstructured_jsteps]
!                [alloc*gradp in unstructured_jsteps] [alloc*p_matrix in unstructured_jsteps]
!                [alloc*p in unstructured_jsteps] [alloc*dt in solve]
!                [alloc*(*sln.facefluxes) in solve] [alloc*(*sln.fluxresiduals) in solve]
!                [alloc*(*sln.cellfluxes) in solve] [alloc*(*sln.cellstate) in solve]
!                [alloc*(*sln.cellprimitives) in solve] *([alloc*sln in solve].cellstate)
!                *([alloc*sln in solve].cellfluxes) *([alloc*sln in solve].cellprimitives)
!                *([alloc*sln in solve].fluxresiduals) *([alloc*sln in solve].facefluxes)
!                [alloc*facevel in cfl] [alloc*cellrhot in cfl]
!                [alloc*facerhot in cfl]
!   Plus diff mem management of: dt:in-out mesh.cvols:in mesh.ccenters:in
!                mesh.favecs:in mesh.fcenters:in sln.cellstate:in
!                sln.cellfluxes:in-out sln.cellprimitives:in-out
!                sln.fluxresiduals:in-out sln.facefluxes:in
!9.timeDiscretizations.jl:更新解 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! 局部时间步长的欧拉方法.局部时间步长（Local Time Stepping, LTS）：为每个单元格独立计算时间步长
  SUBROUTINE LTSEULER_D(mesh, meshd, sln, slnd, boundaryconditions, &
&   fluid, dt, dtd)
    IMPLICIT NONE
    TYPE(MESHH), INTENT(IN) :: mesh
    TYPE(MESHH_DIFF), INTENT(IN) :: meshd
    TYPE(SOLUTIONSTATE), INTENT(INOUT) :: sln
    TYPE(SOLUTIONSTATE), INTENT(INOUT) :: slnd
    TYPE(BOUNDARYCONDITION), INTENT(IN) :: boundaryconditions(:)
    TYPE(FLUIDD), INTENT(IN) :: fluid
    REAL(kind=8), ALLOCATABLE, INTENT(INOUT) :: dt(:)
    REAL(kind=8), ALLOCATABLE, INTENT(INOUT) :: dtd(:)
    REAL(kind=8) :: targetcfl
    REAL(kind=8) :: targetcfld
    REAL(kind=8), ALLOCATABLE :: fluxresiduals(:, :), dt_val(:)
    REAL(kind=8), ALLOCATABLE :: fluxresidualsd(:, :), dt_vald(:)
    INTEGER(kind=8) :: ncells, nvars, maxoutput
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! 循环变量、总点数、单元顶点数
    INTEGER(kind=8) :: i, j, npts, npointspercell, l
! 存储单元的顶点索引（假设最多8个顶点
    INTEGER(kind=8) :: pointindices(8)
! 控制输出单元数量
    INTEGER(kind=8) :: print_dtd
! 控制输出单元数量
    INTEGER(kind=8) :: print_slnd
! 控制输出单元数量
    INTEGER(kind=8) :: print_resd
    INTRINSIC SIZE
    INTRINSIC MIN
    INTRINSIC NEW_LINE
    targetcfld = 0.0d0!dtd(1)
    targetcfl = dt(1)
    PRINT*, 'targetCFL ', targetcfl
    PRINT*, 'targetCFLd ', targetcfld
! 获取单元数
    ncells = SIZE(sln%cellstate, 1)
! 获取变量数
    nvars = SIZE(sln%cellstate, 2)
    ALLOCATE(fluxresidualsd(ncells, nvars), source=0.0d0)
    ALLOCATE(fluxresiduals(ncells, nvars), source=0.0d0)
! 显式分配并初始化
! 计算残差
    CALL UNSTRUCTURED_JSTFLUX_D(mesh, meshd, sln, slnd, &
&                         boundaryconditions, fluid, fluxresiduals, &
&                         fluxresidualsd)
    ncells = SIZE(sln%cellstate, 1)
    nvars = SIZE(fluxresiduals, 2)
    IF (15 .GT. ncells) THEN
      maxoutput = ncells
    ELSE
      maxoutput = 15
    END IF
!		write(*,*) "Flux residuals for first 5 cells:"
!		do i = 1, maxOutput
!		  write(*, '(A,I3,A,*(E12.6,1X))') "Cell ", i, ": ", (fluxResiduals(i,j), j=1,nVars)
!		end do
! 计算时间步长
    CALL CFL_D(ncells, mesh, meshd, sln, slnd, fluid, 1.0d0, dt, dtd)
! 输出前5个dt值
!		write(*,*) "First 5 dt values:"
!		do i = 1, min(5, size(dt))
!		    write(*,'(A,I3,A,E12.6)') "dt(", i, ") = ", dt(i)
!		end do
    dtd = targetcfld/dt - targetcfl*dtd/(dt*dt)
    dt = targetcfl/dt
! 输出前5个dt值
!		write(*,*) "First 5 dt values:"
!		do i = 1, min(5, size(dt))
!		    write(*,'(A,I3,A,E12.6)') "dt(", i, ") = ", dt(i)
!		end do
    CALL SMOOTHTIMESTEP_D(dt, dtd, mesh, meshd, 0.1d0, dt_val, dt_vald)
! 输出前5个dt值
!		write(*,*) "First 5 dt values:"
!		do i = 1, min(5, size(dt))
!		    write(*,'(A,I3,A,E12.6)') "dt(", i, ") = ", dt(i)
!		end do
    CALL SMOOTHTIMESTEPP_D(dt_val, dt_vald, mesh, meshd, 0.1d0, dt, dtd)
    IF (5 .GT. ncells) THEN
      print_resd = ncells
    ELSE
      print_resd = 5
    END IF
    PRINT *, NEW_LINE('a')//'除以体积后 fluxresiduals（微分残差） ==='
	WRITE(*, '(I5, *(ES12.4, 1X))') 2210, (fluxresiduals(2210, j), j=1, nvars)
    PRINT*, NEW_LINE('a')//&
&   '除以体积后 fluxresidualsd（微分残差） ==='
	WRITE(*, '(I5, *(ES12.4, 1X))') 2210, (fluxresidualsd(2210, j), j=1, nvars)
    IF (5 .GT. ncells) THEN
      print_slnd = ncells
    ELSE
      print_slnd = 5
    END IF
    PRINT*, NEW_LINE('a')//&
&   '更新前 sln%cellstate ==='
	WRITE(*, '(I5, *(ES12.4, 1X))') 2210, (sln%cellstate(2210, j), j=1, nvars)
    PRINT*, NEW_LINE('a')//&
&   '更新前slnd%cellstate（微分状态变量） ==='
!    PRINT*, '格式：单元索引 | 各变量微分状态'
!		DO i = 1, print_slnd
!			WRITE(*, '(I5, *(ES12.4, 1X))') i, (slnd%cellstate(i, j), j=1, nvars)
	WRITE(*, '(I5, *(ES12.4, 1X))') 2210, (slnd%cellstate(2210, j), j=1, nvars)
!		END DO
! 输出前5个单元的 dtd（微分时间步长）
!		print_dtd = MIN(5, SIZE(dtd))
    PRINT*, NEW_LINE('a')//&
&   ' dtd（微分时间步长） ==='
    PRINT*, '格式：单元索引 | dtd值'
!		DO i = 1, print_dtd
!		WRITE(*, '(I5, ES12.4)') i, dtd(i)
	WRITE(*, '(I5, ES12.4)') 2210, dtd(2210)
	PRINT *, '格式：单元索引 | dt值'
	WRITE(*, '(I5, ES12.4)') 2210, dt(2210)
	!		END DO
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! 用残差更新守恒变量（按广播匹配dt维度）
! 遍历每个变量
    DO j=1,nvars
! 遍历每个单元
      DO i=1,ncells
        slnd%cellstate(i, j) = slnd%cellstate(i, j) + dt(i)*&
&         fluxresidualsd(i, j) + fluxresiduals(i, j)*dtd(i)
        sln%cellstate(i, j) = sln%cellstate(i, j) + fluxresiduals(i, j)*&
&         dt(i)
      END DO
    END DO
    PRINT*, NEW_LINE('a')//&
&   '更新后2210:sln%cellstate ==='
	WRITE(*, '(I5, *(ES12.4, 1X))') 2210, (sln%cellstate(2210, j), j=1, nvars)
    PRINT*, NEW_LINE('a')//'slnd%cellstate（微分状态变量） ==='
    WRITE(*, '(I5, *(ES12.4, 1X))') 2210, (slnd%cellstate(2210, j), j=1, nvars)
    PRINT*, NEW_LINE('a')//&
&   '更新后2305:sln%cellstate ==='
	WRITE(*, '(I5, *(ES12.4, 1X))') 2305, (sln%cellstate(2305, j), j=1, nvars)
    PRINT*, NEW_LINE('a')//'slnd%cellstate（微分状态变量） ==='
    WRITE(*, '(I5, *(ES12.4, 1X))') 2305, (slnd%cellstate(2305, j), j=1, nvars)
! 输出前6个cellState
!		write(*,*) "First 6 cellState values:"
!		do i = 1, min(6, size(sln%cellState,1))
!		    write(*,'(A,I3,A,*(E12.6,1X))') "Cell ", i, ": ", (sln%cellState(i,j), j=1,size(sln%cellState,2))
!		end do
    CALL DECODESOLUTION_3D_D(sln, slnd, fluid) 
    PRINT*, NEW_LINE('a')//'sln%cellPrimitives（微分状态变量） ==='
    WRITE(*, '(I5, *(ES12.4, 1X))') 2210, (sln%cellPrimitives(2210, j), j=1, nvars) 
    PRINT*, NEW_LINE('a')//'slnd%cellPrimitives（微分状态变量） ==='
    WRITE(*, '(I5, *(ES12.4, 1X))') 2210, (slnd%cellPrimitives(2210, j), j=1, nvars)       
! 释放临时数组（可选，避免内存泄漏）
    IF (ALLOCATED(fluxresidualsd)) THEN
      DEALLOCATE(fluxresidualsd)
    END IF
    DEALLOCATE(fluxresiduals)
    IF (ALLOCATED(dt_vald)) THEN
      DEALLOCATE(dt_vald)
    END IF
    DEALLOCATE(dt_val)
  END SUBROUTINE LTSEULER_D

!9.timeDiscretizations.jl:更新解 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! 局部时间步长的欧拉方法.局部时间步长（Local Time Stepping, LTS）：为每个单元格独立计算时间步长
  SUBROUTINE LTSEULER(mesh, sln, boundaryconditions, fluid, dt)
    IMPLICIT NONE
    TYPE(MESHH), INTENT(IN) :: mesh
    TYPE(SOLUTIONSTATE), INTENT(INOUT) :: sln
    TYPE(BOUNDARYCONDITION), INTENT(IN) :: boundaryconditions(:)
    TYPE(FLUIDD), INTENT(IN) :: fluid
    REAL(kind=8), ALLOCATABLE, INTENT(INOUT) :: dt(:)
    REAL(kind=8) :: targetcfl
    REAL(kind=8), ALLOCATABLE :: fluxresiduals(:, :), dt_val(:)
    INTEGER(kind=8) :: ncells, nvars, maxoutput
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! 循环变量、总点数、单元顶点数
    INTEGER(kind=8) :: i, j, npts, npointspercell, l
! 存储单元的顶点索引（假设最多8个顶点
    INTEGER(kind=8) :: pointindices(8)
! 控制输出单元数量
    INTEGER(kind=8) :: print_dtd
! 控制输出单元数量
    INTEGER(kind=8) :: print_slnd
! 控制输出单元数量
    INTEGER(kind=8) :: print_resd
    INTRINSIC SIZE
    INTRINSIC MIN
    INTRINSIC NEW_LINE
    targetcfl = dt(1)
    PRINT*, 'targetCFL ', targetcfl
! 获取单元数
    ncells = SIZE(sln%cellstate, 1)
! 获取变量数
    nvars = SIZE(sln%cellstate, 2)
    ALLOCATE(fluxresiduals(ncells, nvars), source=0.0d0)
! 显式分配并初始化
! 计算残差
    CALL UNSTRUCTURED_JSTFLUX(mesh, sln, boundaryconditions, fluid, &
&                       fluxresiduals)
    ncells = SIZE(sln%cellstate, 1)
    nvars = SIZE(fluxresiduals, 2)
    IF (15 .GT. ncells) THEN
      maxoutput = ncells
    ELSE
      maxoutput = 15
    END IF
!		write(*,*) "Flux residuals for first 5 cells:"
!		do i = 1, maxOutput
!		  write(*, '(A,I3,A,*(E12.6,1X))') "Cell ", i, ": ", (fluxResiduals(i,j), j=1,nVars)
!		end do
! 计算时间步长
    CALL CFL(ncells, mesh, sln, fluid, 1.0d0, dt)
! 输出前5个dt值
!		write(*,*) "First 5 dt values:"
!		do i = 1, min(5, size(dt))
!		    write(*,'(A,I3,A,E12.6)') "dt(", i, ") = ", dt(i)
!		end do
    dt = targetcfl/dt
! 输出前5个dt值
!		write(*,*) "First 5 dt values:"
!		do i = 1, min(5, size(dt))
!		    write(*,'(A,I3,A,E12.6)') "dt(", i, ") = ", dt(i)
!		end do
    CALL SMOOTHTIMESTEP(dt, mesh, 0.1d0, dt_val)
! 输出前5个dt值
!		write(*,*) "First 5 dt values:"
!		do i = 1, min(5, size(dt))
!		    write(*,'(A,I3,A,E12.6)') "dt(", i, ") = ", dt(i)
!		end do
    CALL SMOOTHTIMESTEPP(dt_val, mesh, 0.1d0, dt)
    IF (5 .GT. ncells) THEN
      print_resd = ncells
    ELSE
      print_resd = 5
    END IF
    PRINT*, NEW_LINE('a')//&
&   '=== 前5个单元的 fluxresidualsd（微分残差） ==='
    PRINT*, '格式：单元索引 | 各变量微分残差'
    IF (5 .GT. ncells) THEN
      print_slnd = ncells
    ELSE
      print_slnd = 5
    END IF
    PRINT*, NEW_LINE('a')//&
&   '=== 前5个单元的 slnd%cellstate（微分状态变量） ==='
    PRINT*, '格式：单元索引 | 各变量微分状态'
!		DO i = 1, print_slnd
!			WRITE(*, '(I5, *(ES12.4, 1X))') i, (slnd%cellstate(i, j), j=1, nvars)
!		WRITE(*, '(I5, *(ES12.4, 1X))') 2210, (slnd%cellstate(2210, j), j=1, nvars)
!		END DO
! 输出前5个单元的 dtd（微分时间步长）
!		print_dtd = MIN(5, SIZE(dtd))
    PRINT*, NEW_LINE('a')//&
&   '=== 前5个单元的 dtd（微分时间步长） ==='
    PRINT*, '格式：单元索引 | dtd值'
!		DO i = 1, print_dtd
!		WRITE(*, '(I5, ES12.4)') i, dtd(i)
!		WRITE(*, '(I5, ES12.4)') 2210, dtd(i)
!		END DO
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! 用残差更新守恒变量（按广播匹配dt维度）
! 遍历每个变量
    DO j=1,nvars
! 遍历每个单元
      DO i=1,ncells
        sln%cellstate(i, j) = sln%cellstate(i, j) + fluxresiduals(i, j)*&
&         dt(i)
      END DO
    END DO
! 输出前6个cellState
!		write(*,*) "First 6 cellState values:"
!		do i = 1, min(6, size(sln%cellState,1))
!		    write(*,'(A,I3,A,*(E12.6,1X))') "Cell ", i, ": ", (sln%cellState(i,j), j=1,size(sln%cellState,2))
!		end do
    CALL DECODESOLUTION_3D(sln, fluid)
! 释放临时数组（可选，避免内存泄漏）
    DEALLOCATE(fluxresiduals)
    DEALLOCATE(dt_val)
  END SUBROUTINE LTSEULER

!  Differentiation of smoothtimestep in forward (tangent) mode (with options i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4):
!   variations   of useful results: [alloc*surfaceareas in smoothtimestep]
!                [alloc*timefluxes in smoothtimestep] [alloc*updated_dt in smoothtimestep]
!   with respect to varying inputs: [alloc*surfaceareas in smoothtimestep]
!                [alloc*timefluxes in smoothtimestep] [alloc*updated_dt in smoothtimestep]
!                [alloc*(mesh.favecs) in openfoammesh] dt
!   Plus diff mem management of: updated_dt:out mesh.favecs:in
! 时间步长平滑函数（用于局部时间步长方法）.局部时间步长在空间上可能剧烈变化，导致相邻单
!元格步长差异过大，引发数值振荡。
  SUBROUTINE SMOOTHTIMESTEP_D(dt, dtd, mesh, meshd, diffusioncoefficient&
&   , updated_dt, updated_dtd)
    IMPLICIT NONE
    REAL(kind=8), INTENT(IN) :: dt(:)
    REAL(kind=8), INTENT(IN) :: dtd(:)
    TYPE(MESHH), INTENT(IN) :: mesh
    TYPE(MESHH_DIFF), INTENT(IN) :: meshd
    REAL(kind=8), INTENT(IN), OPTIONAL :: diffusioncoefficient
!		real(kind=8), intent(out) :: updated_dt(:)
! 返回值，与输入的 dt 类型一致
    REAL(kind=8), ALLOCATABLE, INTENT(OUT) :: updated_dt(:)
    REAL(kind=8), ALLOCATABLE, INTENT(OUT) :: updated_dtd(:)
    INTEGER(kind=8) :: ncells, nfaces, nboundaries, nbdryfaces, f, &
&   ownercell, neighbourcell, i, meshinfo(4)
    INTEGER(kind=8), SAVE :: stat=0
    REAL(kind=8) :: coeff, timeflux, mag_val
    REAL(kind=8) :: timefluxd, mag_vald
    REAL(kind=8), ALLOCATABLE :: timefluxes(:), surfaceareas(:)
    REAL(kind=8), ALLOCATABLE :: timefluxesd(:), surfaceareasd(:)
    INTRINSIC PRESENT
    INTRINSIC MIN
    IF (PRESENT(diffusioncoefficient)) THEN
      coeff = diffusioncoefficient
    ELSE
      coeff = 0.2
    END IF
! 获取网格信息
    CALL UNSTRUCTUREDMESHINFO(mesh, meshinfo)
    ncells = meshinfo(1)
    nfaces = meshinfo(2)
    nboundaries = meshinfo(3)
    nbdryfaces = meshinfo(4)
    ALLOCATE(updated_dtd(ncells), source=0.0d0)
    updated_dtd = 0.0_8
    ALLOCATE(updated_dt(ncells), source=0.0d0)
! 初始化时间通量和表面积数组
    ALLOCATE(timefluxesd(ncells), source=0.0d0)
    timefluxesd = 0.0_8
    ALLOCATE(timefluxes(ncells), source=0.0d0)
    ALLOCATE(surfaceareasd(ncells), source=0.0d0)
    surfaceareasd = 0.0_8
    ALLOCATE(surfaceareas(ncells), source=0.0d0)
    timefluxesd = 0.0_8
    timefluxes = 0.0d0
    surfaceareasd = 0.0_8
    surfaceareas = 0.0d0
! 遍历所有内部面
    DO f=1,nfaces-nbdryfaces
! 主单元
      ownercell = mesh%faces(f, 1)
! 邻居单元
      neighbourcell = mesh%faces(f, 2)
! 计算时间步长差异通量
      CALL MAG_D(mesh%favecs(f, :), meshd%favecs(f, :), mag_val, &
&          mag_vald)
      timefluxd = mag_val*(dtd(ownercell)-dtd(neighbourcell)) + (dt(&
&       ownercell)-dt(neighbourcell))*mag_vald
      timeflux = (dt(ownercell)-dt(neighbourcell))*mag_val
! 累加表面积（用于归一化）
      surfaceareasd(ownercell) = surfaceareasd(ownercell) + mag_vald
      surfaceareas(ownercell) = surfaceareas(ownercell) + mag_val
      surfaceareasd(neighbourcell) = surfaceareasd(neighbourcell) + &
&       mag_vald
      surfaceareas(neighbourcell) = surfaceareas(neighbourcell) + &
&       mag_val
! 更新通量（守恒形式）
      timefluxesd(ownercell) = timefluxesd(ownercell) - timefluxd
      timefluxes(ownercell) = timefluxes(ownercell) - timeflux
      timefluxesd(neighbourcell) = timefluxesd(neighbourcell) + &
&       timefluxd
      timefluxes(neighbourcell) = timefluxes(neighbourcell) + timeflux
    END DO
! 应用扩散系数并归一化
    timefluxesd = coeff*timefluxesd/surfaceareas-coeff*timefluxes*surfaceareasd/&
&     (surfaceareas*surfaceareas)
    timefluxes = timefluxes*(coeff/surfaceareas)
! 确保只应用平滑（不增加时间步长）
    DO i=1,ncells
      IF (0.0d0 .GT. timefluxes(i)) THEN
        timefluxes(i) = timefluxes(i)
      ELSE
!        timefluxesd(i) = 0.0_8
        timefluxes(i) = 0.0d0
      END IF
    END DO
! 更新时间步长
    updated_dtd = dtd + timefluxesd
    updated_dt = dt + timefluxes
  END SUBROUTINE SMOOTHTIMESTEP_D

! 时间步长平滑函数（用于局部时间步长方法）.局部时间步长在空间上可能剧烈变化，导致相邻单
!元格步长差异过大，引发数值振荡。
  SUBROUTINE SMOOTHTIMESTEP(dt, mesh, diffusioncoefficient, updated_dt)
    IMPLICIT NONE
    REAL(kind=8), INTENT(IN) :: dt(:)
    TYPE(MESHH), INTENT(IN) :: mesh
    REAL(kind=8), INTENT(IN), OPTIONAL :: diffusioncoefficient
!		real(kind=8), intent(out) :: updated_dt(:)
! 返回值，与输入的 dt 类型一致
    REAL(kind=8), ALLOCATABLE, INTENT(OUT) :: updated_dt(:)
    INTEGER(kind=8) :: ncells, nfaces, nboundaries, nbdryfaces, f, &
&   ownercell, neighbourcell, i, meshinfo(4)
    INTEGER(kind=8), SAVE :: stat=0
    REAL(kind=8) :: coeff, timeflux, mag_val
    REAL(kind=8), ALLOCATABLE :: timefluxes(:), surfaceareas(:)
    INTRINSIC PRESENT
    INTRINSIC MIN
    IF (PRESENT(diffusioncoefficient)) THEN
      coeff = diffusioncoefficient
    ELSE
      coeff = 0.2
    END IF
! 获取网格信息
    CALL UNSTRUCTUREDMESHINFO(mesh, meshinfo)
    ncells = meshinfo(1)
    nfaces = meshinfo(2)
    nboundaries = meshinfo(3)
    nbdryfaces = meshinfo(4)
    ALLOCATE(updated_dt(ncells), source=0.0d0)
! 初始化时间通量和表面积数组
    ALLOCATE(timefluxes(ncells), source=0.0d0)
    ALLOCATE(surfaceareas(ncells), source=0.0d0)
    timefluxes = 0.0d0
    surfaceareas = 0.0d0
! 遍历所有内部面
    DO f=1,nfaces-nbdryfaces
! 主单元
      ownercell = mesh%faces(f, 1)
! 邻居单元
      neighbourcell = mesh%faces(f, 2)
! 计算时间步长差异通量
      CALL MAG(mesh%favecs(f, :), mag_val)
      timeflux = (dt(ownercell)-dt(neighbourcell))*mag_val
! 累加表面积（用于归一化）
      surfaceareas(ownercell) = surfaceareas(ownercell) + mag_val
      surfaceareas(neighbourcell) = surfaceareas(neighbourcell) + &
&       mag_val
! 更新通量（守恒形式）
      timefluxes(ownercell) = timefluxes(ownercell) - timeflux
      timefluxes(neighbourcell) = timefluxes(neighbourcell) + timeflux
    END DO
! 应用扩散系数并归一化
    timefluxes = timefluxes*(coeff/surfaceareas)
! 确保只应用平滑（不增加时间步长）
    DO i=1,ncells
      IF (0.0d0 .GT. timefluxes(i)) THEN
        timefluxes(i) = timefluxes(i)
      ELSE
        timefluxes(i) = 0.0d0
      END IF
    END DO
! 更新时间步长
    updated_dt = dt + timefluxes
  END SUBROUTINE SMOOTHTIMESTEP

!  Differentiation of smoothtimestepp in forward (tangent) mode (with options i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4):
!   variations   of useful results: [alloc*surfaceareas in smoothtimestepp]
!                [alloc*timefluxes in smoothtimestepp] [alloc*updated_dt in smoothtimestepp]
!   with respect to varying inputs: [alloc*surfaceareas in smoothtimestepp]
!                [alloc*timefluxes in smoothtimestepp] [alloc*updated_dt in smoothtimestepp]
!                [alloc*(mesh.favecs) in openfoammesh] dt
!   Plus diff mem management of: updated_dt:out mesh.favecs:in
  SUBROUTINE SMOOTHTIMESTEPP_D(dt, dtd, mesh, meshd, &
&   diffusioncoefficient, updated_dt, updated_dtd)
    IMPLICIT NONE
    REAL(kind=8), INTENT(IN) :: dt(:)
    REAL(kind=8), INTENT(IN) :: dtd(:)
    TYPE(MESHH), INTENT(IN) :: mesh
    TYPE(MESHH_DIFF), INTENT(IN) :: meshd
    REAL(kind=8), INTENT(IN), OPTIONAL :: diffusioncoefficient
!		real(kind=8), intent(out) :: updated_dt(:)
! 返回值，与输入的 dt 类型一致
    REAL(kind=8), ALLOCATABLE, INTENT(OUT) :: updated_dt(:)
    REAL(kind=8), ALLOCATABLE, INTENT(OUT) :: updated_dtd(:)
    INTEGER(kind=8) :: ncells, nfaces, nboundaries, nbdryfaces, f, &
&   ownercell, neighbourcell, i, meshinfo(4)
    INTEGER(kind=8), SAVE :: stat=0
    REAL(kind=8) :: coeff, timeflux, mag_val
    REAL(kind=8) :: timefluxd, mag_vald
    REAL(kind=8), ALLOCATABLE :: timefluxes(:), surfaceareas(:)
    REAL(kind=8), ALLOCATABLE :: timefluxesd(:), surfaceareasd(:)
    INTRINSIC PRESENT
    INTRINSIC MIN
    IF (PRESENT(diffusioncoefficient)) THEN
      coeff = diffusioncoefficient
    ELSE
      coeff = 0.2
    END IF
! 获取网格信息
    CALL UNSTRUCTUREDMESHINFO(mesh, meshinfo)
    ncells = meshinfo(1)
    nfaces = meshinfo(2)
    nboundaries = meshinfo(3)
    nbdryfaces = meshinfo(4)
    ALLOCATE(updated_dtd(ncells), source=0.0d0)
    updated_dtd = 0.0_8
    ALLOCATE(updated_dt(ncells), source=0.0d0)
! 初始化时间通量和表面积数组
    ALLOCATE(timefluxesd(ncells), source=0.0d0)
    timefluxesd = 0.0_8
    ALLOCATE(timefluxes(ncells), source=0.0d0)
    ALLOCATE(surfaceareasd(ncells), source=0.0d0)
    surfaceareasd = 0.0_8
    ALLOCATE(surfaceareas(ncells), source=0.0d0)
    timefluxesd = 0.0_8
    timefluxes = 0.0d0
    surfaceareasd = 0.0_8
    surfaceareas = 0.0d0
! 遍历所有内部面
    DO f=1,nfaces-nbdryfaces
! 主单元
      ownercell = mesh%faces(f, 1)
! 邻居单元
      neighbourcell = mesh%faces(f, 2)
! 计算时间步长差异通量
      CALL MAG_D(mesh%favecs(f, :), meshd%favecs(f, :), mag_val, &
&          mag_vald)
      timefluxd = mag_val*(dtd(ownercell)-dtd(neighbourcell)) + (dt(&
&       ownercell)-dt(neighbourcell))*mag_vald
      timeflux = (dt(ownercell)-dt(neighbourcell))*mag_val
! 累加表面积（用于归一化）
      surfaceareasd(ownercell) = surfaceareasd(ownercell) + mag_vald
      surfaceareas(ownercell) = surfaceareas(ownercell) + mag_val
      surfaceareasd(neighbourcell) = surfaceareasd(neighbourcell) + &
&       mag_vald
      surfaceareas(neighbourcell) = surfaceareas(neighbourcell) + &
&       mag_val
! 更新通量（守恒形式）
      timefluxesd(ownercell) = timefluxesd(ownercell) - timefluxd
      timefluxes(ownercell) = timefluxes(ownercell) - timeflux
      timefluxesd(neighbourcell) = timefluxesd(neighbourcell) + &
&       timefluxd
      timefluxes(neighbourcell) = timefluxes(neighbourcell) + timeflux
    END DO
! 应用扩散系数并归一化
    timefluxesd = coeff*(timefluxesd-timefluxes*surfaceareasd/&
&     surfaceareas)/surfaceareas
    timefluxes = timefluxes*(coeff/surfaceareas)
! 确保只应用平滑（不增加时间步长）
    DO i=1,ncells
      IF (0.0d0 .GT. timefluxes(i)) THEN
        timefluxes(i) = timefluxes(i)
      ELSE
!        timefluxesd(i) = 0.0_8
        timefluxes(i) = 0.0d0
      END IF
    END DO
! 更新时间步长
    updated_dtd = dtd + timefluxesd
    updated_dt = dt + timefluxes
  END SUBROUTINE SMOOTHTIMESTEPP_D

  SUBROUTINE SMOOTHTIMESTEPP(dt, mesh, diffusioncoefficient, updated_dt)
    IMPLICIT NONE
    REAL(kind=8), INTENT(IN) :: dt(:)
    TYPE(MESHH), INTENT(IN) :: mesh
    REAL(kind=8), INTENT(IN), OPTIONAL :: diffusioncoefficient
!		real(kind=8), intent(out) :: updated_dt(:)
! 返回值，与输入的 dt 类型一致
    REAL(kind=8), ALLOCATABLE, INTENT(OUT) :: updated_dt(:)
    INTEGER(kind=8) :: ncells, nfaces, nboundaries, nbdryfaces, f, &
&   ownercell, neighbourcell, i, meshinfo(4)
    INTEGER(kind=8), SAVE :: stat=0
    REAL(kind=8) :: coeff, timeflux, mag_val
    REAL(kind=8), ALLOCATABLE :: timefluxes(:), surfaceareas(:)
    INTRINSIC PRESENT
    INTRINSIC MIN
    IF (PRESENT(diffusioncoefficient)) THEN
      coeff = diffusioncoefficient
    ELSE
      coeff = 0.2
    END IF
! 获取网格信息
    CALL UNSTRUCTUREDMESHINFO(mesh, meshinfo)
    ncells = meshinfo(1)
    nfaces = meshinfo(2)
    nboundaries = meshinfo(3)
    nbdryfaces = meshinfo(4)
    ALLOCATE(updated_dt(ncells), source=0.0d0)
! 初始化时间通量和表面积数组
    ALLOCATE(timefluxes(ncells), source=0.0d0)
    ALLOCATE(surfaceareas(ncells), source=0.0d0)
    timefluxes = 0.0d0
    surfaceareas = 0.0d0
! 遍历所有内部面
    DO f=1,nfaces-nbdryfaces
! 主单元
      ownercell = mesh%faces(f, 1)
! 邻居单元
      neighbourcell = mesh%faces(f, 2)
! 计算时间步长差异通量
      CALL MAG(mesh%favecs(f, :), mag_val)
      timeflux = (dt(ownercell)-dt(neighbourcell))*mag_val
! 累加表面积（用于归一化）
      surfaceareas(ownercell) = surfaceareas(ownercell) + mag_val
      surfaceareas(neighbourcell) = surfaceareas(neighbourcell) + &
&       mag_val
! 更新通量（守恒形式）
      timefluxes(ownercell) = timefluxes(ownercell) - timeflux
      timefluxes(neighbourcell) = timefluxes(neighbourcell) + timeflux
    END DO
! 应用扩散系数并归一化
    timefluxes = timefluxes*(coeff/surfaceareas)
! 确保只应用平滑（不增加时间步长）
    DO i=1,ncells
      IF (0.0d0 .GT. timefluxes(i)) THEN
        timefluxes(i) = timefluxes(i)
      ELSE
        timefluxes(i) = 0.0d0
      END IF
    END DO
! 更新时间步长
    updated_dt = dt + timefluxes
  END SUBROUTINE SMOOTHTIMESTEPP

!###########################################################################################
!10.vectorFunctions.jl#####################################################################
!######################### 向量函数 ########################
!#函数：点积，叉积，模，转化为单位向量
! 情况1：向量 × 向量（均为1维数组）
  SUBROUTINE DOT_VEC_VEC(arg1, arg2, outt)
    IMPLICIT NONE
! 1维向量
    REAL(kind=8), INTENT(IN) :: arg1(:)
! 1维向量
    REAL(kind=8), INTENT(IN) :: arg2(:)
    REAL(kind=8), ALLOCATABLE, INTENT(INOUT) :: outt(:)
    INTEGER(kind=8) :: i, n
    INTRINSIC SIZE
    n = SIZE(arg1)
    IF (n .NE. SIZE(arg2)) THEN
      PRINT*, 'Error: Vectors must have same length'
      STOP
    ELSE
      ALLOCATE(outt(1), source=0.0d0)
      outt(1) = 0.0d0
      DO i=1,n
! 合法的1维数组索引
        outt(1) = outt(1) + arg1(i)*arg2(i)
      END DO
    END IF
  END SUBROUTINE DOT_VEC_VEC

!  Differentiation of cross in forward (tangent) mode (with options i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4):
!   variations   of useful results: cross_vec
!   with respect to varying inputs: v1 v2 cross_vec
! 3D向量叉积（仅适用于3元素向量）
  SUBROUTINE CROSS_D(v1, v1d, v2, v2d, cross_vec, cross_vecd)
    IMPLICIT NONE
! v1=(x1,y1,z1), v2=(x2,y2,z2)
    REAL(kind=8), INTENT(IN) :: v1(3), v2(3)
    REAL(kind=8), INTENT(IN) :: v1d(3), v2d(3)
    REAL(kind=8), INTENT(OUT) :: cross_vec(3)
    REAL(kind=8), INTENT(OUT) :: cross_vecd(3)
! 正确的叉乘公式（严格匹配Julia）
! y1z2 - z1y2
    cross_vecd(1) = v2(3)*v1d(2) + v1(2)*v2d(3) - v2(2)*v1d(3) - v1(3)*&
&     v2d(2)
    cross_vec(1) = v1(2)*v2(3) - v1(3)*v2(2)
! z1x2 - x1z2（修正符号）
    cross_vecd(2) = v2(1)*v1d(3) + v1(3)*v2d(1) - v2(3)*v1d(1) - v1(1)*&
&     v2d(3)
    cross_vec(2) = v1(3)*v2(1) - v1(1)*v2(3)
! x1y2 - y1x2
    cross_vecd(3) = v2(2)*v1d(1) + v1(1)*v2d(2) - v2(1)*v1d(2) - v1(2)*&
&     v2d(1)
    cross_vec(3) = v1(1)*v2(2) - v1(2)*v2(1)
  END SUBROUTINE CROSS_D

! 3D向量叉积（仅适用于3元素向量）
  SUBROUTINE CROSS(v1, v2, cross_vec)
    IMPLICIT NONE
! v1=(x1,y1,z1), v2=(x2,y2,z2)
    REAL(kind=8), INTENT(IN) :: v1(3), v2(3)
    REAL(kind=8), INTENT(OUT) :: cross_vec(3)
! 正确的叉乘公式（严格匹配Julia）
! y1z2 - z1y2
    cross_vec(1) = v1(2)*v2(3) - v1(3)*v2(2)
! z1x2 - x1z2（修正符号）
    cross_vec(2) = v1(3)*v2(1) - v1(1)*v2(3)
! x1y2 - y1x2
    cross_vec(3) = v1(1)*v2(2) - v1(2)*v2(1)
  END SUBROUTINE CROSS

!  Differentiation of mag in forward (tangent) mode (with options i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4):
!   variations   of useful results: sqrsum
!   with respect to varying inputs: vec
! 向量的模（2-范数）
  SUBROUTINE MAG_D(vec, vecd, sqrsum, sqrsumd)
    IMPLICIT NONE
    REAL(kind=8), INTENT(IN) :: vec(:)
    REAL(kind=8), INTENT(IN) :: vecd(:)
! 输出参数：原返回值
    REAL(kind=8), INTENT(OUT) :: sqrsum
    REAL(kind=8), INTENT(OUT) :: sqrsumd
    INTEGER(kind=8) :: i
    INTRINSIC SIZE
    INTRINSIC SQRT
    REAL(kind=8) :: temp
    sqrsum = 0.0d0
    sqrsumd = 0.0_8
    DO i=1,SIZE(vec)
! 累加元素平方
      sqrsumd = sqrsumd + 2*vec(i)*vecd(i)
      sqrsum = sqrsum + vec(i)**2
    END DO
! 开平方得模长
    temp = SQRT(sqrsum)
    IF (sqrsum .EQ. 0.0) THEN
      sqrsumd = 0.0_8
    ELSE
      sqrsumd = sqrsumd/(2.0*temp)
    END IF
    sqrsum = temp
  END SUBROUTINE MAG_D

! 向量的模（2-范数）
  SUBROUTINE MAG(vec, sqrsum)
    IMPLICIT NONE
    REAL(kind=8), INTENT(IN) :: vec(:)
! 输出参数：原返回值
    REAL(kind=8), INTENT(OUT) :: sqrsum
    INTEGER(kind=8) :: i
    INTRINSIC SIZE
    INTRINSIC SQRT
    sqrsum = 0.0d0
    DO i=1,SIZE(vec)
! 累加元素平方
      sqrsum = sqrsum + vec(i)**2
    END DO
! 开平方得模长
    sqrsum = SQRT(sqrsum)
  END SUBROUTINE MAG

!  Differentiation of normalize in forward (tangent) mode (with options i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4):
!   variations   of useful results: [alloc*unit_vec in normalize]
!   with respect to varying inputs: [alloc*unit_vec in normalize]
!                vec
!   Plus diff mem management of: unit_vec:out
! 向量归一化（转化为单位向量）
  SUBROUTINE NORMALIZE_D(vec, vecd, unit_vec, unit_vecd)
    IMPLICIT NONE
    REAL(kind=8), INTENT(IN) :: vec(:)
    REAL(kind=8), INTENT(IN) :: vecd(:)
    REAL(kind=8), ALLOCATABLE, INTENT(OUT) :: unit_vec(:)
    REAL(kind=8), ALLOCATABLE, INTENT(OUT) :: unit_vecd(:)
    REAL(kind=8) :: vec_mag
    REAL(kind=8) :: vec_magd
    INTRINSIC SIZE
! 调用mag函数
    CALL MAG_D(vec, vecd, vec_mag, vec_magd)
! 避免除以零
    IF (vec_mag .LT. 1.0d-12) THEN
      PRINT*, 'Error in normalize: Zero magnitude vector'
      STOP
    ELSE
      ALLOCATE(unit_vecd(SIZE(vec)), source=0.0d0)
      unit_vecd = 0.0_8
      ALLOCATE(unit_vec(SIZE(vec)), source=0.0d0)
! 每个元素除以模长
      unit_vecd = (vecd-vec*vec_magd/vec_mag)/vec_mag
      unit_vec = vec/vec_mag
    END IF
  END SUBROUTINE NORMALIZE_D

! 向量归一化（转化为单位向量）
  SUBROUTINE NORMALIZE(vec, unit_vec)
    IMPLICIT NONE
    REAL(kind=8), INTENT(IN) :: vec(:)
    REAL(kind=8), ALLOCATABLE, INTENT(OUT) :: unit_vec(:)
    REAL(kind=8) :: vec_mag
    INTRINSIC SIZE
! 调用mag函数
    CALL MAG(vec, vec_mag)
! 避免除以零
    IF (vec_mag .LT. 1.0d-12) THEN
      PRINT*, 'Error in normalize: Zero magnitude vector'
      STOP
    ELSE
      ALLOCATE(unit_vec(SIZE(vec)), source=0.0d0)
! 每个元素除以模长
      unit_vec = vec/vec_mag
    END IF
  END SUBROUTINE NORMALIZE

!  Differentiation of dot_product_real in forward (tangent) mode (with options i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4)
!:
!   variations   of useful results: result
!   with respect to varying inputs: a b
  SUBROUTINE DOT_PRODUCT_REAL_D(a, ad, b, bd, result, resultd, len_vec)
    IMPLICIT NONE
! 输入：A/B为1维向量；len_vec为向量长度（可选，适配Tapenade）
! 输出：点积结果（标量）
! 1维向量（现有调用的输入）
    REAL*8, INTENT(IN) :: a(:), b(:)
    REAL*8, INTENT(IN) :: ad(:), bd(:)
! 标量结果
    REAL*8, INTENT(OUT) :: result
    REAL*8, INTENT(OUT) :: resultd
! 新增：向量长度（可选，Tapenade用）
    INTEGER, INTENT(IN), OPTIONAL :: len_vec
! 局部：实际使用的向量长度
    INTEGER :: i, vec_len
    INTRINSIC PRESENT
    INTRINSIC SIZE
! 1. 确定向量长度：优先用显式传递的len_vec，否则用size(A)（兼容现有调用）
    IF (PRESENT(len_vec)) THEN
! Tapenade微分时，显式传递长度（如3）
      vec_len = len_vec
    ELSE
! 现有调用：默认用A的长度（不影响原有逻辑）
      vec_len = SIZE(a)
    END IF
! 2. 计算点积（直接用显式长度vec_len循环，避免Tapenade无法识别size(B)）
    result = 0.0d0
    resultd = 0.0_8
    DO i=1,vec_len
      resultd = resultd + b(i)*ad(i) + a(i)*bd(i)
      result = result + a(i)*b(i)
    END DO
  END SUBROUTINE DOT_PRODUCT_REAL_D

  SUBROUTINE DOT_PRODUCT_REAL(a, b, result, len_vec)
    IMPLICIT NONE
! 输入：A/B为1维向量；len_vec为向量长度（可选，适配Tapenade）
! 输出：点积结果（标量）
! 1维向量（现有调用的输入）
    REAL*8, INTENT(IN) :: a(:), b(:)
! 标量结果
    REAL*8, INTENT(OUT) :: result
! 新增：向量长度（可选，Tapenade用）
    INTEGER, INTENT(IN), OPTIONAL :: len_vec
! 局部：实际使用的向量长度
    INTEGER :: i, vec_len
    INTRINSIC PRESENT
    INTRINSIC SIZE
! 1. 确定向量长度：优先用显式传递的len_vec，否则用size(A)（兼容现有调用）
    IF (PRESENT(len_vec)) THEN
! Tapenade微分时，显式传递长度（如3）
      vec_len = len_vec
    ELSE
! 现有调用：默认用A的长度（不影响原有逻辑）
      vec_len = SIZE(a)
    END IF
! 2. 计算点积（直接用显式长度vec_len循环，避免Tapenade无法识别size(B)）
    result = 0.0d0
    DO i=1,vec_len
      result = result + a(i)*b(i)
    END DO
  END SUBROUTINE DOT_PRODUCT_REAL

!  Differentiation of compute_cfd in forward (tangent) mode (with options i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4):
!   variations   of useful results: [alloc*sol in initializeuniformsolution3d]
!   with respect to varying inputs: [alloc*point_update in airfoil_deformation_hh]
!   Plus diff mem management of: [alloc*sln in solve].cellstate:in-out
!                [alloc*sln in solve].cellfluxes:in-out [alloc*sln in solve].cellprimitives:in-out
!                [alloc*sln in solve].fluxresiduals:in-out [alloc*sln in solve].facefluxes:in-out
!                point_update:in
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! 11.NACA0012.jl!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! All file paths are relative to the repository's main directory, 'include' this script from there
!-----------------------------------------------------------------------------------#
! 变量赋值
!-----------------------------------------------------------------------------------#
  SUBROUTINE COMPUTE_CFD_D(point_update, point_updated, cellprimitives, &
&   cellprimitivesd)
    IMPLICIT NONE
    TYPE(FLUIDD) :: fluid
    TYPE(MESHH) :: mesh
    TYPE(MESHH_DIFF) :: meshd
! 输入：变形网格点
    REAL*8, ALLOCATABLE, INTENT(IN) :: point_update(:, :)
    REAL*8, ALLOCATABLE, INTENT(IN) :: point_updated(:, :)
    REAL(kind=8), ALLOCATABLE, INTENT(OUT) :: cellprimitives(:, :)
    REAL(kind=8), ALLOCATABLE, INTENT(OUT) :: cellprimitivesd(:, :)
    REAL(kind=8), ALLOCATABLE :: uunitvec(:)
    INTEGER(kind=8) :: ncells, meshinfo(4), f
    REAL(kind=8) :: p, t, u(3), a, machnum, pt, tt, mag_u
    CHARACTER(len=256) :: meshpath
    TYPE(BOUNDARYCONDITION), ALLOCATABLE :: boundaryconditions(:)
    INTRINSIC SQRT
    INTRINSIC ALLOCATED
    REAL(kind=8) :: arg1
! 初始化流体属性
    fluid = FLUIDD(cp=1005.0d0, r=287.05d0, gammaa=1.4d0)
! 初始化边界条件
    p = 100000.0d0
    t = 300.0d0
!	U = [ 33.30d0, 0d0, 0d0 ]
	U = [ 33.30d0, 0d0, 0d0 ]
!mach=0.096
!	U = [ 110.7091d0, 6.059633d0, 0d0 ]
!    u = (/33.30d0, 0.7d0, 0.0d0/)
    ALLOCATE(uunitvec(3), source=0.0d0)
    CALL NORMALIZE(u, uunitvec)
    arg1 = fluid%gammaa*fluid%r*t
    a = SQRT(arg1)
! 子程序调用：计算 U 的模长
    CALL MAG(u, mag_u)
! 用临时变量代入表达式
    machnum = mag_u/a
    PRINT*, 'machNum = ', machnum
    pt = p*(1.0d0+(fluid%gammaa-1.0d0)/2.0d0*machnum**2)**(fluid%gammaa/&
&     (fluid%gammaa-1.0d0))
    tt = t*(1.0d0+(fluid%gammaa-1.0d0)/2.0d0*machnum**2)
! 修正边界条件参数大小（原代码中params(4)分配与5个元素赋值不匹配）
    ALLOCATE(boundaryconditions(4))
    boundaryconditions(1)%type = wallboundary
    ALLOCATE(boundaryconditions(1)%params(0))
    boundaryconditions(2)%type = emptyboundary
    ALLOCATE(boundaryconditions(2)%params(0))
    boundaryconditions(3)%type = inletboundary
    ALLOCATE(boundaryconditions(3)%params(5))
! 改为5个参数（Pt, Tt, Ux, Uy, Uz）
    boundaryconditions(3)%params = (/pt, tt, uunitvec(1), uunitvec(2), &
&     uunitvec(3)/)
    boundaryconditions(4)%type = outletboundary
    ALLOCATE(boundaryconditions(4)%params(1))
    boundaryconditions(4)%params(1) = p
! 读取网格
    meshpath = 'mesh/OFairfoilMesh'
    CALL OPENFOAMMESH_D(meshpath, point_update, point_updated, mesh, &
&                 meshd)
    WRITE(*, *) 'test_First 5 mesh.cVols:'
!		do f = 1, min(5, size(mesh%cVols,1))
!write(*,'(A,I3,A,E12.6)') "Cell ", f, ": ", mesh%cVols(f)
!		write(*,'(A,I3,A,E12.6)') "Cell ", 2210, ": ", mesh%cVols(f)   
!		end do
! 修改后的代码
    CALL UNSTRUCTUREDMESHINFO(mesh, meshinfo)
    ncells = meshinfo(1)
    ALLOCATE(cellprimitivesd(ncells, 5), source=0.0d0)
    ALLOCATE(cellprimitives(ncells, 5), source=0.0d0)
! 初始化均匀解
    CALL INITIALIZEUNIFORMSOLUTION3D_D(mesh, p, t, u(1), u(2), u(3), &
&                                cellprimitives, cellprimitivesd)
    PRINT*, 'a1'
! 调用求解器（局部时间步长）
    CALL SOLVE_D(mesh, meshd, meshpath, cellprimitives, cellprimitivesd&
&          , boundaryconditions, point_update, point_updated)
    IF (ALLOCATED(boundaryconditions)) THEN
      DEALLOCATE(boundaryconditions)
    END IF
  END SUBROUTINE COMPUTE_CFD_D

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! 11.NACA0012.jl!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! All file paths are relative to the repository's main directory, 'include' this script from there
!-----------------------------------------------------------------------------------#
! 变量赋值
!-----------------------------------------------------------------------------------#
  SUBROUTINE COMPUTE_CFD(point_update, cellprimitives)
    IMPLICIT NONE
    TYPE(FLUIDD) :: fluid
    TYPE(MESHH) :: mesh
! 输入：变形网格点
    REAL*8, ALLOCATABLE, INTENT(IN) :: point_update(:, :)
    REAL(kind=8), ALLOCATABLE, INTENT(OUT) :: cellprimitives(:, :)
    REAL(kind=8), ALLOCATABLE :: uunitvec(:)
    INTEGER(kind=8) :: ncells, meshinfo(4), f
    REAL(kind=8) :: p, t, u(3), a, machnum, pt, tt, mag_u
    CHARACTER(len=256) :: meshpath
    TYPE(BOUNDARYCONDITION), ALLOCATABLE :: boundaryconditions(:)
    INTRINSIC SQRT
    INTRINSIC ALLOCATED
    REAL(kind=8) :: arg1
! 初始化流体属性
    fluid = FLUIDD(cp=1005.0d0, r=287.05d0, gammaa=1.4d0)
! 初始化边界条件
    p = 100000.0d0
    t = 300.0d0
!    U = [ 277.7091d0, 0d0, 0d0 ]
	U = [ 33.30d0, 0d0, 0d0 ]
!		U = [ 277.7091d0, 6.059633d0, 0d0 ]
!mach=0.096
!    u = (/33.30d0, 0.7d0, 0.0d0/)
    ALLOCATE(uunitvec(3), source=0.0d0)
    CALL NORMALIZE(u, uunitvec)
    arg1 = fluid%gammaa*fluid%r*t
    a = SQRT(arg1)
! 子程序调用：计算 U 的模长
    CALL MAG(u, mag_u)
! 用临时变量代入表达式
    machnum = mag_u/a
    PRINT*, 'machNum = ', machnum
    pt = p*(1.0d0+(fluid%gammaa-1.0d0)/2.0d0*machnum**2)**(fluid%gammaa/&
&     (fluid%gammaa-1.0d0))
    tt = t*(1.0d0+(fluid%gammaa-1.0d0)/2.0d0*machnum**2)
! 修正边界条件参数大小（原代码中params(4)分配与5个元素赋值不匹配）
    ALLOCATE(boundaryconditions(4))
    boundaryconditions(1)%type = wallboundary
    ALLOCATE(boundaryconditions(1)%params(0))
    boundaryconditions(2)%type = emptyboundary
    ALLOCATE(boundaryconditions(2)%params(0))
    boundaryconditions(3)%type = inletboundary
    ALLOCATE(boundaryconditions(3)%params(5))
! 改为5个参数（Pt, Tt, Ux, Uy, Uz）
    boundaryconditions(3)%params = (/pt, tt, uunitvec(1), uunitvec(2), &
&     uunitvec(3)/)
    boundaryconditions(4)%type = outletboundary
    ALLOCATE(boundaryconditions(4)%params(1))
    boundaryconditions(4)%params(1) = p
! 读取网格
    meshpath = 'mesh/OFairfoilMesh'
    CALL OPENFOAMMESH(meshpath, point_update, mesh)
    WRITE(*, *) 'test_First 5 mesh.cVols:'
!		do f = 1, min(5, size(mesh%cVols,1))
!write(*,'(A,I3,A,E12.6)') "Cell ", f, ": ", mesh%cVols(f)
!		write(*,'(A,I3,A,E12.6)') "Cell ", 2210, ": ", mesh%cVols(f)   
!		end do
! 修改后的代码
    CALL UNSTRUCTUREDMESHINFO(mesh, meshinfo)
    ncells = meshinfo(1)
    ALLOCATE(cellprimitives(ncells, 5), source=0.0d0)
! 初始化均匀解
    CALL INITIALIZEUNIFORMSOLUTION3D(mesh, p, t, u(1), u(2), u(3), &
&                              cellprimitives)
    PRINT*, 'a1'
! 调用求解器（局部时间步长）
    CALL SOLVE(mesh, meshpath, cellprimitives, boundaryconditions, &
&        point_update)
    IF (ALLOCATED(boundaryconditions)) THEN
      DEALLOCATE(boundaryconditions)
    END IF
  END SUBROUTINE COMPUTE_CFD

END MODULE BUFLOWMODULE_DIFF

