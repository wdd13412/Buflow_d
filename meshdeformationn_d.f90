!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.16 (develop) - 29 Jul 2025 17:17
!
MODULE MESHDEFORMATIONN_DIFF
!	use iso_fortran_env
  USE TYPESMODULE
  IMPLICIT NONE
! 2. 再禁用默认类型
  INTRINSIC VERIFY, FINDLOC, SYSTEM, MATMUL, DOT_PRODUCT, MOVE_ALLOC, &
&     NEW_LINE, HUGE, INT
! 仅保留外部声明    
  EXTERNAL DPOTRF, DPOTRI
! 仅 Tapenade 处理时取消注释（原代码编译时注释掉）
!include 'tapenade_includes.f90'  ! <<< 仅 Tapenade 用，原编译时注释
!非tapenade时call move_alloc_char(originalLines, newLines)

CONTAINS
!  Differentiation of airfoil_deformation_hh in forward (tangent) mode (with options i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 d
!r8 r4):
!   variations   of useful results: [alloc*point_update in airfoil_deformation_hh]
!   with respect to varying inputs: data_4d137
!   Plus diff mem management of: point_update:out
  SUBROUTINE AIRFOIL_DEFORMATION_HH_D(data_4d137, data_4d137d, &
&   point_update, point_updated)
    IMPLICIT NONE
    REAL*8, ALLOCATABLE :: wing_update(:, :)
    REAL*8, ALLOCATABLE :: wing_updated(:, :)
    REAL*8, INTENT(IN) :: data_4d137(:, :)
    REAL*8, INTENT(IN) :: data_4d137d(:, :)
    REAL*8, ALLOCATABLE, INTENT(INOUT) :: point_update(:, :)
    REAL*8, ALLOCATABLE, INTENT(INOUT) :: point_updated(:, :)
    REAL*8 :: rae2822_up(50, 2), rae2822_low(50, 2)
    REAL*8 :: x1(50), y_up(50), y_low(50), loca(2), xx(2), fun1_result(&
&   50), funk_result(50)
    REAL*8 :: s(100, 4), s_up(100, 2), s_low(100, 2)
    REAL*8 :: sd(100, 4), s_upd(100, 2), s_lowd(100, 2)
    REAL*8 :: f_up(50), f_low(50), yy_up(50), yy_low(50)
    REAL*8 :: f_upd(50), f_lowd(50), yy_upd(50), yy_lowd(50)
    REAL*8 :: avg_y_51
    REAL*8 :: avg_y_51d
    REAL*8 :: up_part(49, 2), row_51(2), low_part(49, 2)
    REAL*8 :: up_partd(49, 2), row_51d(2), low_partd(49, 2)
    INTEGER :: d, n, i, k
    REAL*8, ALLOCATABLE :: wing(:, :), inoutput(:, :)
    INTRINSIC SIZE
    INTRINSIC COS
    INTRINSIC ALLOCATED
    DOUBLE PRECISION :: arg1
    DOUBLE PRECISION :: arg1d
    ALLOCATE(inoutput(99, 2), source=0.0_real64)
    ALLOCATE(wing(99, 2), source=0.0_real64)
    ALLOCATE(wing_updated(99, 2), source=0.0_real64)
    ALLOCATE(wing_update(99, 2), source=0.0_real64)
! 1. 提取输入输出边界点（初始化inoutput）
    inoutput = CSV_READ('boundary_inoutput_xy.csv')
! 从文件读取翼型数据
    wing = CSV_READ('wing.csv')
! 提取上表面坐标
    rae2822_up = wing(1:50, :)
! 提取下表面坐标
    rae2822_low = wing(50:99, :)
! 提取坐标向量
    x1 = rae2822_up(:, 1)
    y_up = rae2822_up(:, 2)
    y_low = rae2822_low(:, 2)
    loca = (/1.0d0, 8.0d0/)
    xx = (/x1(1), x1(8)/)
! 处理变形参数
    d = SIZE(data_4d137, 2)
    s = 0.0d0
    sd = 0.0_8
    DO i=1,d
      DO k=1,SIZE(data_4d137, 1)
        arg1d = -(3.1415926535d0*data_4d137d(k, i)/2.0d0)
        arg1 = (1.0d0-data_4d137(k, i))/2.0d0*3.1415926535d0
        sd(k, i) = -(0.05d0*SIN(arg1)*arg1d)
        s(k, i) = 0.05d0*COS(arg1)!5.0D-300,5.0D-100,0.05d0
      END DO
    END DO
    s_upd = sd(:, 1:2)
    s_up = s(:, 1:2)
    s_lowd = sd(:, 3:4)
    s_low = s(:, 3:4)
    n = SIZE(s_up, 1)
! 计算变形
    IF (n .GT. 0) THEN
! 计算变形函数
! 第二个参数 50 是 x1 的长度
      CALL FUN1(x1, 50, fun1_result)
! 第二个参数 50 是 X（即 x1）的长度
      CALL FUNK(x1, 50, 2, funk_result)
      f_upd = fun1_result*s_upd(1, 1) + funk_result*s_upd(1, 2)
      f_up = fun1_result*s_up(1, 1) + funk_result*s_up(1, 2)
      f_lowd = fun1_result*s_lowd(1, 1) + funk_result*s_lowd(1, 2)
      f_low = fun1_result*s_low(1, 1) + funk_result*s_low(1, 2)
      yy_upd = f_upd
      yy_up = y_up + f_up
      yy_lowd = f_lowd
      yy_low = y_low + f_low
! 特殊处理重叠点
      avg_y_51d = (yy_upd(50)+yy_lowd(1))/2.0d0
      avg_y_51 = (yy_up(50)+yy_low(1))/2.0d0
! 构建更新后的翼型
      up_part(:, 1) = x1(1:49)
      up_partd = 0.0_8
      up_partd(:, 2) = yy_upd(1:49)
      up_part(:, 2) = yy_up(1:49)
      row_51(1) = x1(50)
      row_51d = 0.0_8
      row_51d(2) = avg_y_51d
      row_51(2) = avg_y_51
      low_part(:, 1) = rae2822_low(2:50, 1)
      low_partd = 0.0_8
      low_partd(:, 2) = yy_lowd(2:50)
      low_part(:, 2) = yy_low(2:50)
! 合并三部分
      IF (ALLOCATED(wing_updated)) wing_updated = 0.0_8
      wing_updated(1:49, :) = up_partd
      wing_update(1:49, :) = up_part
      wing_updated(50, :) = row_51d
      wing_update(50, :) = row_51
      wing_updated(51:99, :) = low_partd
      wing_update(51:99, :) = low_part
! 输出到文件
      CALL CSV_WRITE('wing_update.csv', wing_update, 99, 2)
      PRINT*, '翼型坐标已更新并保存至wing_update.csv'
! 释放临时分配的内存
      IF (ALLOCATED(inoutput)) THEN
        DEALLOCATE(inoutput)
      END IF
      IF (ALLOCATED(wing)) THEN
        DEALLOCATE(wing)
      END IF
      ALLOCATE(point_updated(18513, 3))
      ALLOCATE(point_update(18513, 3))
      PRINT*, "========================================"
      PRINT*, "输出wing_update的第一个点:"
      PRINT*, "wing_update(1,1) = ", wing_update(1,1)
      PRINT*, "wing_update(1,2) = ", wing_update(1,2)
      PRINT*, "输出wing_updated的第一个点:"
      PRINT*, "wing_updated(1,1) = ", wing_updated(1,1)
      PRINT*, "wing_updated(1,2) = ", wing_updated(1,2)
      PRINT*, "========================================"
      CALL MESHDEFORMATION_D(wing_update, wing_updated, point_update, &
&                      point_updated)
      PRINT*, "========================================"
	 !第300个点变化前:(0.942606 0.0121379 0)      
      PRINT*, "输出point_update的第300个点:"
      PRINT*, "point_update(300,1) = ", point_update(300,1)
      PRINT*, "point_update(300,2) = ", point_update(300,2)
      PRINT*, "point_update(300,3) = ", point_update(300,3)
      PRINT*, "输出point_updated的第300个点:"
      PRINT*, "point_updated(300,1) = ", point_updated(300,1)
      PRINT*, "point_updated(300,2) = ", point_updated(300,2)
      PRINT*, "point_updated(300,3) = ", point_updated(300,3)
      PRINT*, "========================================"
      IF (ALLOCATED(wing_update)) THEN
        IF (ALLOCATED(wing_updated)) THEN
          DEALLOCATE(wing_updated)
        END IF
        DEALLOCATE(wing_update)
      END IF
      PRINT*, 'aAd'
    ELSE
      PRINT*, '错误：无变形参数可用'
      STOP
    END IF

  CONTAINS
! 变形函数fun1
! 新增 n：x 的长度（显式维度）
    SUBROUTINE FUN1(x, n, result)
      IMPLICIT NONE
! 数组 x 的维度（如 50）
      INTEGER, INTENT(IN) :: n
! 用 n 声明 x 的维度
      REAL*8, INTENT(IN) :: x(n)
! 用 n 声明 result 的维度（与 x 一致）
      REAL*8, INTENT(OUT) :: result(n)
      INTRINSIC EXP
      result = x**0.25d0*(1.0d0-x)*EXP(-(20.0d0*x))
    END SUBROUTINE FUN1

! 变形函数funk
! 新增 n：X 的长度（显式维度）
    SUBROUTINE FUNK(x, n, k, result)
      IMPLICIT NONE
! 数组 X 的维度（如 50）
      INTEGER, INTENT(IN) :: n
! 用 n 声明 X 的维度
      REAL*8, INTENT(IN) :: x(n)
      INTEGER, INTENT(IN) :: k
! 用 n 声明 result 的维度
      REAL*8, INTENT(OUT) :: result(n)
      REAL*8 :: xxx(2), ee
      INTRINSIC LOG10
      INTRINSIC SIN
      DOUBLE PRECISION, DIMENSION(n) :: arg10
      xxx = (/x1(1), x1(8)/)
      ee = LOG10(0.5d0)/LOG10(xxx(k))
      arg10 = 3.1415926535d0*x**ee
      result = SIN(arg10)**3
    END SUBROUTINE FUNK

  END SUBROUTINE AIRFOIL_DEFORMATION_HH_D

  SUBROUTINE AIRFOIL_DEFORMATION_HH(data_4d137, point_update)
    IMPLICIT NONE
    REAL*8, ALLOCATABLE :: wing_update(:, :)
    REAL*8, INTENT(IN) :: data_4d137(:, :)
    REAL*8, ALLOCATABLE, INTENT(INOUT) :: point_update(:, :)
    REAL*8 :: rae2822_up(50, 2), rae2822_low(50, 2)
    REAL*8 :: x1(50), y_up(50), y_low(50), loca(2), xx(2), fun1_result(&
&   50), funk_result(50)
    REAL*8 :: s(100, 4), s_up(100, 2), s_low(100, 2)
    REAL*8 :: f_up(50), f_low(50), yy_up(50), yy_low(50)
    REAL*8 :: avg_y_51
    REAL*8 :: up_part(49, 2), row_51(2), low_part(49, 2)
    INTEGER :: d, n, i, k
    REAL*8, ALLOCATABLE :: wing(:, :), inoutput(:, :)
    INTRINSIC SIZE
    INTRINSIC COS
    INTRINSIC ALLOCATED
    DOUBLE PRECISION :: arg1
    ALLOCATE(inoutput(99, 2), source=0.0_real64)
    ALLOCATE(wing(99, 2), source=0.0_real64)
    ALLOCATE(wing_update(99, 2), source=0.0_real64)
! 1. 提取输入输出边界点（初始化inoutput）
    inoutput = CSV_READ('boundary_inoutput_xy.csv')
! 从文件读取翼型数据
    wing = CSV_READ('wing.csv')
! 提取上表面坐标
    rae2822_up = wing(1:50, :)
! 提取下表面坐标
    rae2822_low = wing(50:99, :)
! 提取坐标向量
    x1 = rae2822_up(:, 1)
    y_up = rae2822_up(:, 2)
    y_low = rae2822_low(:, 2)
    loca = (/1.0d0, 8.0d0/)
    xx = (/x1(1), x1(8)/)
! 处理变形参数
    d = SIZE(data_4d137, 2)
    s = 0.0d0
    DO i=1,d
      DO k=1,SIZE(data_4d137, 1)
        arg1 = (1.0d0-data_4d137(k, i))/2.0d0*3.1415926535d0
        s(k, i) = 0.05d0*COS(arg1)!5.0D-300
      END DO
    END DO
    s_up = s(:, 1:2)
    s_low = s(:, 3:4)
    n = SIZE(s_up, 1)
! 计算变形
    IF (n .GT. 0) THEN
! 计算变形函数
! 第二个参数 50 是 x1 的长度
      CALL FUN1(x1, 50, fun1_result)
! 第二个参数 50 是 X（即 x1）的长度
      CALL FUNK(x1, 50, 2, funk_result)
      f_up = fun1_result*s_up(1, 1) + funk_result*s_up(1, 2)
      f_low = fun1_result*s_low(1, 1) + funk_result*s_low(1, 2)
      yy_up = y_up + f_up
      yy_low = y_low + f_low
! 特殊处理重叠点
      avg_y_51 = (yy_up(50)+yy_low(1))/2.0d0
! 构建更新后的翼型
      up_part(:, 1) = x1(1:49)
      up_part(:, 2) = yy_up(1:49)
      row_51(1) = x1(50)
      row_51(2) = avg_y_51
      low_part(:, 1) = rae2822_low(2:50, 1)
      low_part(:, 2) = yy_low(2:50)
! 合并三部分
      wing_update(1:49, :) = up_part
      wing_update(50, :) = row_51
      wing_update(51:99, :) = low_part
! 输出到文件
      CALL CSV_WRITE('wing_update.csv', wing_update, 99, 2)
      PRINT*, '翼型坐标已更新并保存至wing_update.csv'
! 释放临时分配的内存
      IF (ALLOCATED(inoutput)) THEN
        DEALLOCATE(inoutput)
      END IF
      IF (ALLOCATED(wing)) THEN
        DEALLOCATE(wing)
      END IF
      ALLOCATE(point_update(18513, 3))
      CALL MESHDEFORMATION(wing_update, point_update)
      IF (ALLOCATED(wing_update)) THEN
        DEALLOCATE(wing_update)
      END IF
    ELSE
      PRINT*, '错误：无变形参数可用'
      STOP
    END IF
    PRINT*, 'aAd'

  CONTAINS
! 变形函数fun1
! 新增 n：x 的长度（显式维度）
    SUBROUTINE FUN1(x, n, result)
      IMPLICIT NONE
! 数组 x 的维度（如 50）
      INTEGER, INTENT(IN) :: n
! 用 n 声明 x 的维度
      REAL*8, INTENT(IN) :: x(n)
! 用 n 声明 result 的维度（与 x 一致）
      REAL*8, INTENT(OUT) :: result(n)
      INTRINSIC EXP
      result = x**0.25d0*(1.0d0-x)*EXP(-(20.0d0*x))
    END SUBROUTINE FUN1

! 变形函数funk
! 新增 n：X 的长度（显式维度）
    SUBROUTINE FUNK(x, n, k, result)
      IMPLICIT NONE
! 数组 X 的维度（如 50）
      INTEGER, INTENT(IN) :: n
! 用 n 声明 X 的维度
      REAL*8, INTENT(IN) :: x(n)
      INTEGER, INTENT(IN) :: k
! 用 n 声明 result 的维度
      REAL*8, INTENT(OUT) :: result(n)
      REAL*8 :: xxx(2), ee
      INTRINSIC LOG10
      INTRINSIC SIN
      DOUBLE PRECISION, DIMENSION(n) :: arg10
      xxx = (/x1(1), x1(8)/)
      ee = LOG10(0.5d0)/LOG10(xxx(k))
      arg10 = 3.1415926535d0*x**ee
      result = SIN(arg10)**3
    END SUBROUTINE FUNK

  END SUBROUTINE AIRFOIL_DEFORMATION_HH

!  Differentiation of meshdeformation in forward (tangent) mode (with options i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4):
!   variations   of useful results: [alloc*point_update in airfoil_deformation_hh]
!   with respect to varying inputs: [alloc*wing_update in airfoil_deformation_hh]
!   Plus diff mem management of: wing_update:in point_update:in
  SUBROUTINE MESHDEFORMATION_D(wing_update, wing_updated, point_update, &
&   point_updated)
    IMPLICIT NONE
    CHARACTER(len=256) :: meshpath
    REAL*8, ALLOCATABLE, INTENT(IN) :: wing_update(:, :)
    REAL*8, ALLOCATABLE, INTENT(IN) :: wing_updated(:, :)
    REAL*8, ALLOCATABLE, INTENT(INOUT) :: point_update(:, :)
    REAL*8, ALLOCATABLE, INTENT(INOUT) :: point_updated(:, :)
    CHARACTER(len=256) :: pointsfilepath
    REAL(kind=8), ALLOCATABLE :: points(:, :), mat_inv(:, :)
    INTEGER :: npoints, nwing, ninoutput, ncontrol, i, j, k, pt, line, &
&   iostat, len_str, linecount
    REAL(kind=8), ALLOCATABLE :: wing_coords(:, :), wing_update_coords(:&
&   , :), inoutput_coords(:, :), r_row(:), phi_row(:)
    REAL(kind=8), ALLOCATABLE :: wing_update_coordsd(:, :)
    REAL(kind=8), ALLOCATABLE :: control_points(:, :), d_wing_x(:), &
&   d_wing_y(:), d_inoutput_x(:), d_inoutput_y(:)
    REAL(kind=8), ALLOCATABLE :: d_wing_xd(:), d_wing_yd(:)
    REAL(kind=8), ALLOCATABLE :: d_control_x(:), d_control_y(:), &
&   d_mesh_x(:), d_mesh_y(:), d_mesh_z(:)
    REAL(kind=8), ALLOCATABLE :: d_control_xd(:), d_control_yd(:), &
&   d_mesh_xd(:), d_mesh_yd(:)
    REAL(kind=8), ALLOCATABLE :: phi(:, :), weights_x(:), weights_y(:), &
&   distances(:)
    REAL(kind=8), ALLOCATABLE :: weights_xd(:), weights_yd(:)
    REAL(kind=8) :: epsilonn, diff(2), r, x, y, z, d_nomal
    CHARACTER(len=256), ALLOCATABLE :: originallines(:), newdatalines(:)&
&   , newlines(:)
    INTEGER :: nline, datastartline
    REAL*8, ALLOCATABLE :: wing(:, :), inoutput(:, :)
    INTRINSIC TRIM
    INTRINSIC SIZE
    INTRINSIC ALLOCATED
    INTRINSIC SUM
    INTRINSIC SQRT
    REAL(kind=8), DIMENSION(2) :: arg1
    REAL(kind=8) :: arg2
    PRINT*, 'aAa'
    meshpath = 'mesh/OFairfoilMesh'
    pointsfilepath = TRIM(meshpath)//'/points'
    ALLOCATE(points(18513, 3), source=0.0d0)
! 空数组初始化
    points = READOFPOINTSFILEF(pointsfilepath)
    npoints = SIZE(points, 1)
    IF (.NOT.ALLOCATED(wing)) THEN
      ALLOCATE(wing(99, 2), source=0.0_real64)
    END IF
    IF (.NOT.ALLOCATED(inoutput)) THEN
      ALLOCATE(inoutput(99, 2), source=0.0_real64)
    END IF
    inoutput = CSV_READ('boundary_inoutput_xy.csv')
    wing = CSV_READ('wing.csv')
    nwing = SIZE(wing_update, 1)
    ninoutput = SIZE(inoutput, 1)
    ALLOCATE(wing_coords(nwing, 2))
    ALLOCATE(wing_update_coordsd(nwing, 2))
    ALLOCATE(wing_update_coords(nwing, 2))
    ALLOCATE(inoutput_coords(ninoutput, 2))
    DO i=1,nwing
      wing_coords(i, :) = wing(i, :)
      wing_update_coordsd(i, :) = wing_updated(i, :)
      wing_update_coords(i, :) = wing_update(i, :)
    END DO
    DO i=1,ninoutput
      inoutput_coords(i, :) = inoutput(i, :)
    END DO
    ncontrol = nwing + ninoutput
    ALLOCATE(control_points(ncontrol, 2))
    control_points(1:nwing, :) = wing_coords
    control_points(nwing+1:ncontrol, :) = inoutput_coords
    ALLOCATE(d_wing_xd(nwing))
    ALLOCATE(d_wing_x(nwing))
    ALLOCATE(d_wing_yd(nwing))
    ALLOCATE(d_wing_y(nwing))
    IF (ALLOCATED(d_wing_xd)) d_wing_xd = 0.0_8
    d_wing_xd = wing_update_coordsd(:, 1)
    d_wing_x = wing_update_coords(:, 1) - wing_coords(:, 1)
    IF (ALLOCATED(d_wing_yd)) d_wing_yd = 0.0_8
    d_wing_yd = wing_update_coordsd(:, 2)
    d_wing_y = wing_update_coords(:, 2) - wing_coords(:, 2)
    ALLOCATE(d_inoutput_x(ninoutput))
    ALLOCATE(d_inoutput_y(ninoutput))
    d_inoutput_x = 0.0d0
    d_inoutput_y = 0.0d0
    ALLOCATE(d_control_xd(ncontrol))
    ALLOCATE(d_control_x(ncontrol))
    ALLOCATE(d_control_yd(ncontrol))
    ALLOCATE(d_control_y(ncontrol))
    IF (ALLOCATED(d_control_xd)) d_control_xd = 0.0_8
    d_control_xd(1:nwing) = d_wing_xd
    d_control_x(1:nwing) = d_wing_x
    d_control_xd(nwing+1:ncontrol) = 0.0_8
    d_control_x(nwing+1:ncontrol) = d_inoutput_x
    IF (ALLOCATED(d_control_yd)) d_control_yd = 0.0_8
    d_control_yd(1:nwing) = d_wing_yd
    d_control_y(1:nwing) = d_wing_y
    d_control_yd(nwing+1:ncontrol) = 0.0_8
    d_control_y(nwing+1:ncontrol) = d_inoutput_y
    d_nomal = 1.0d0/4.5d0
    epsilonn = 0.9560721680067801d0
    ALLOCATE(d_mesh_xd(npoints))
    ALLOCATE(d_mesh_x(npoints))
    ALLOCATE(d_mesh_yd(npoints))
    ALLOCATE(d_mesh_y(npoints))
    ALLOCATE(d_mesh_z(npoints))
    d_mesh_xd = 0.0_8
    d_mesh_x = 0.0d0
    d_mesh_yd = 0.0_8
    d_mesh_y = 0.0d0
    d_mesh_z = 0.0d0
    ALLOCATE(r_row(ncontrol))
    ALLOCATE(phi_row(ncontrol))
    ALLOCATE(phi(ncontrol, ncontrol))
    DO j=1,ncontrol
      DO k=1,ncontrol
        diff = control_points(j, :) - control_points(k, :)
        arg1 = diff**2
        arg2 = SUM(arg1)
        r_row(k) = SQRT(arg2)
      END DO
      CALL GAUSSIAN_RBF_ARRAY(r_row, epsilonn, phi_row)
      phi(j, :) = phi_row
    END DO
    ALLOCATE(weights_xd(ncontrol), source=0.0d0)
    ALLOCATE(weights_x(ncontrol), source=0.0d0)
! 预初始化
    ALLOCATE(weights_yd(ncontrol), source=0.0d0)
    ALLOCATE(weights_y(ncontrol), source=0.0d0)
    ALLOCATE(mat_inv(ncontrol, ncontrol), source=0.0d0)
! 2. 调用简化版 inverse（仅传 3 个参数，无 info_out）
    CALL INVERSE(ncontrol, phi, mat_inv)
! 3. 矩阵乘法（用 mat_inv 替代原 inverse(phi)，维度明确）
    CALL MATMUL_REAL_D(mat_inv, d_control_x, d_control_xd, weights_x, &
&                weights_xd)
    CALL MATMUL_REAL_D(mat_inv, d_control_y, d_control_yd, weights_y, &
&                weights_yd)
! 4. 释放逆矩阵（用完即释，避免内存占用）
    IF (ALLOCATED(mat_inv)) THEN
      DEALLOCATE(mat_inv)
    END IF
    ALLOCATE(distances(ncontrol))
    DO pt=1,npoints
      DO j=1,ncontrol
        diff = points(pt, 1:2) - control_points(j, :)
        arg1 = diff**2
        arg2 = SUM(arg1)
        distances(j) = SQRT(arg2)
      END DO
      CALL GAUSSIAN_RBF_ARRAY(distances, epsilonn, phi_row)
!计算网格点的位移d_mesh_x,d_mesh_y
      CALL DOT_PRODUCT_REALL_D(weights_x, weights_xd, phi_row, d_mesh_x(&
&                        pt), d_mesh_xd(pt))
      CALL DOT_PRODUCT_REALL_D(weights_y, weights_yd, phi_row, d_mesh_y(&
&                        pt), d_mesh_yd(pt))
    END DO
    point_updated = 0.0_8
    point_update = points
    DO pt=1,npoints
      point_updated(pt, 1) = point_updated(pt, 1) + d_mesh_xd(pt)
      point_update(pt, 1) = point_update(pt, 1) + d_mesh_x(pt)
      point_updated(pt, 2) = point_updated(pt, 2) + d_mesh_yd(pt)
      point_update(pt, 2) = point_update(pt, 2) + d_mesh_y(pt)
    END DO
    PRINT*, 'aAb'
!        if (allocated(point_update)) deallocate(point_update)
    IF (ALLOCATED(points)) THEN
      DEALLOCATE(points)
    END IF
    IF (ALLOCATED(wing_coords)) THEN
      DEALLOCATE(wing_coords)
    END IF
    IF (ALLOCATED(wing_update_coords)) THEN
      IF (ALLOCATED(wing_update_coordsd)) THEN
        DEALLOCATE(wing_update_coordsd)
      END IF
      DEALLOCATE(wing_update_coords)
    END IF
    IF (ALLOCATED(inoutput_coords)) THEN
      DEALLOCATE(inoutput_coords)
    END IF
    IF (ALLOCATED(control_points)) THEN
      DEALLOCATE(control_points)
    END IF
    IF (ALLOCATED(d_wing_x)) THEN
      IF (ALLOCATED(d_wing_xd)) THEN
        DEALLOCATE(d_wing_xd)
      END IF
      DEALLOCATE(d_wing_x)
    END IF
    IF (ALLOCATED(d_wing_y)) THEN
      IF (ALLOCATED(d_wing_yd)) THEN
        DEALLOCATE(d_wing_yd)
      END IF
      DEALLOCATE(d_wing_y)
    END IF
    IF (ALLOCATED(d_inoutput_x)) THEN
      DEALLOCATE(d_inoutput_x)
    END IF
    IF (ALLOCATED(d_inoutput_y)) THEN
      DEALLOCATE(d_inoutput_y)
    END IF
    IF (ALLOCATED(d_control_x)) THEN
      IF (ALLOCATED(d_control_xd)) THEN
        DEALLOCATE(d_control_xd)
      END IF
      DEALLOCATE(d_control_x)
    END IF
    IF (ALLOCATED(d_control_y)) THEN
      IF (ALLOCATED(d_control_yd)) THEN
        DEALLOCATE(d_control_yd)
      END IF
      DEALLOCATE(d_control_y)
    END IF
    IF (ALLOCATED(d_mesh_x)) THEN
      IF (ALLOCATED(d_mesh_xd)) THEN
        DEALLOCATE(d_mesh_xd)
      END IF
      DEALLOCATE(d_mesh_x)
    END IF
    IF (ALLOCATED(d_mesh_y)) THEN
      IF (ALLOCATED(d_mesh_yd)) THEN
        DEALLOCATE(d_mesh_yd)
      END IF
      DEALLOCATE(d_mesh_y)
    END IF
    IF (ALLOCATED(d_mesh_z)) THEN
      DEALLOCATE(d_mesh_z)
    END IF
    IF (ALLOCATED(r_row)) THEN
      DEALLOCATE(r_row)
    END IF
    IF (ALLOCATED(phi_row)) THEN
      DEALLOCATE(phi_row)
    END IF
    IF (ALLOCATED(phi)) THEN
      DEALLOCATE(phi)
    END IF
    IF (ALLOCATED(weights_x)) THEN
      IF (ALLOCATED(weights_xd)) THEN
        DEALLOCATE(weights_xd)
      END IF
      DEALLOCATE(weights_x)
    END IF
    IF (ALLOCATED(weights_y)) THEN
      IF (ALLOCATED(weights_yd)) THEN
        DEALLOCATE(weights_yd)
      END IF
      DEALLOCATE(weights_y)
    END IF
    IF (ALLOCATED(distances)) THEN
      DEALLOCATE(distances)
    END IF
    IF (ALLOCATED(originallines)) THEN
      DEALLOCATE(originallines)
    END IF
    IF (ALLOCATED(newdatalines)) THEN
      DEALLOCATE(newdatalines)
    END IF
    IF (ALLOCATED(newlines)) THEN
      DEALLOCATE(newlines)
    END IF
    IF (ALLOCATED(wing)) THEN
      DEALLOCATE(wing)
    END IF
! 释放本地wing
    IF (ALLOCATED(inoutput)) THEN
      DEALLOCATE(inoutput)
    END IF
    PRINT*, 'aAc'
  END SUBROUTINE MESHDEFORMATION_D

  SUBROUTINE MESHDEFORMATION(wing_update, point_update)
    IMPLICIT NONE
    CHARACTER(len=256) :: meshpath
    REAL*8, ALLOCATABLE, INTENT(IN) :: wing_update(:, :)
    REAL*8, ALLOCATABLE, INTENT(INOUT) :: point_update(:, :)
    CHARACTER(len=256) :: pointsfilepath
    REAL(kind=8), ALLOCATABLE :: points(:, :), mat_inv(:, :)
    INTEGER :: npoints, nwing, ninoutput, ncontrol, i, j, k, pt, line, &
&   iostat, len_str, linecount
    REAL(kind=8), ALLOCATABLE :: wing_coords(:, :), wing_update_coords(:&
&   , :), inoutput_coords(:, :), r_row(:), phi_row(:)
    REAL(kind=8), ALLOCATABLE :: control_points(:, :), d_wing_x(:), &
&   d_wing_y(:), d_inoutput_x(:), d_inoutput_y(:)
    REAL(kind=8), ALLOCATABLE :: d_control_x(:), d_control_y(:), &
&   d_mesh_x(:), d_mesh_y(:), d_mesh_z(:)
    REAL(kind=8), ALLOCATABLE :: phi(:, :), weights_x(:), weights_y(:), &
&   distances(:)
    REAL(kind=8) :: epsilonn, diff(2), r, x, y, z, d_nomal
    CHARACTER(len=256), ALLOCATABLE :: originallines(:), newdatalines(:)&
&   , newlines(:)
    INTEGER :: nline, datastartline
    REAL*8, ALLOCATABLE :: wing(:, :), inoutput(:, :)
    INTRINSIC TRIM
    INTRINSIC SIZE
    INTRINSIC ALLOCATED
    INTRINSIC SUM
    INTRINSIC SQRT
    REAL(kind=8), DIMENSION(2) :: arg1
    REAL(kind=8) :: arg2
    PRINT*, 'aAa'
    meshpath = 'mesh/OFairfoilMesh'
    pointsfilepath = TRIM(meshpath)//'/points'
    ALLOCATE(points(18513, 3), source=0.0d0)
! 空数组初始化
    points = READOFPOINTSFILEF(pointsfilepath)
    npoints = SIZE(points, 1)
    IF (.NOT.ALLOCATED(wing)) THEN
      ALLOCATE(wing(99, 2), source=0.0_real64)
    END IF
    IF (.NOT.ALLOCATED(inoutput)) THEN
      ALLOCATE(inoutput(99, 2), source=0.0_real64)
    END IF
    inoutput = CSV_READ('boundary_inoutput_xy.csv')
    wing = CSV_READ('wing.csv')
    nwing = SIZE(wing_update, 1)
    ninoutput = SIZE(inoutput, 1)
    ALLOCATE(wing_coords(nwing, 2))
    ALLOCATE(wing_update_coords(nwing, 2))
    ALLOCATE(inoutput_coords(ninoutput, 2))
    DO i=1,nwing
      wing_coords(i, :) = wing(i, :)
      wing_update_coords(i, :) = wing_update(i, :)
    END DO
    DO i=1,ninoutput
      inoutput_coords(i, :) = inoutput(i, :)
    END DO
    ncontrol = nwing + ninoutput
    ALLOCATE(control_points(ncontrol, 2))
    control_points(1:nwing, :) = wing_coords
    control_points(nwing+1:ncontrol, :) = inoutput_coords
    ALLOCATE(d_wing_x(nwing))
    ALLOCATE(d_wing_y(nwing))
    d_wing_x = wing_update_coords(:, 1) - wing_coords(:, 1)
    d_wing_y = wing_update_coords(:, 2) - wing_coords(:, 2)
    ALLOCATE(d_inoutput_x(ninoutput))
    ALLOCATE(d_inoutput_y(ninoutput))
    d_inoutput_x = 0.0d0
    d_inoutput_y = 0.0d0
    ALLOCATE(d_control_x(ncontrol))
    ALLOCATE(d_control_y(ncontrol))
    d_control_x(1:nwing) = d_wing_x
    d_control_x(nwing+1:ncontrol) = d_inoutput_x
    d_control_y(1:nwing) = d_wing_y
    d_control_y(nwing+1:ncontrol) = d_inoutput_y
    d_nomal = 1.0d0/4.5d0
    epsilonn = 0.9560721680067801d0
    ALLOCATE(d_mesh_x(npoints))
    ALLOCATE(d_mesh_y(npoints))
    ALLOCATE(d_mesh_z(npoints))
    d_mesh_x = 0.0d0
    d_mesh_y = 0.0d0
    d_mesh_z = 0.0d0
    ALLOCATE(r_row(ncontrol))
    ALLOCATE(phi_row(ncontrol))
    ALLOCATE(phi(ncontrol, ncontrol))
    DO j=1,ncontrol
      DO k=1,ncontrol
        diff = control_points(j, :) - control_points(k, :)
        arg1 = diff**2
        arg2 = SUM(arg1)
        r_row(k) = SQRT(arg2)
      END DO
      CALL GAUSSIAN_RBF_ARRAY(r_row, epsilonn, phi_row)
      phi(j, :) = phi_row
    END DO
    ALLOCATE(weights_x(ncontrol), source=0.0d0)
! 预初始化
    ALLOCATE(weights_y(ncontrol), source=0.0d0)
    ALLOCATE(mat_inv(ncontrol, ncontrol), source=0.0d0)
! 2. 调用简化版 inverse（仅传 3 个参数，无 info_out）
    CALL INVERSE(ncontrol, phi, mat_inv)
! 3. 矩阵乘法（用 mat_inv 替代原 inverse(phi)，维度明确）
    CALL MATMUL_REAL(mat_inv, d_control_x, weights_x)
    CALL MATMUL_REAL(mat_inv, d_control_y, weights_y)
! 4. 释放逆矩阵（用完即释，避免内存占用）
    IF (ALLOCATED(mat_inv)) THEN
      DEALLOCATE(mat_inv)
    END IF
    ALLOCATE(distances(ncontrol))
    DO pt=1,npoints
      DO j=1,ncontrol
        diff = points(pt, 1:2) - control_points(j, :)
        arg1 = diff**2
        arg2 = SUM(arg1)
        distances(j) = SQRT(arg2)
      END DO
      CALL GAUSSIAN_RBF_ARRAY(distances, epsilonn, phi_row)
!计算网格点的位移d_mesh_x,d_mesh_y
      CALL DOT_PRODUCT_REALL(weights_x, phi_row, d_mesh_x(pt))
      CALL DOT_PRODUCT_REALL(weights_y, phi_row, d_mesh_y(pt))
    END DO
    point_update = points
    DO pt=1,npoints
      point_update(pt, 1) = point_update(pt, 1) + d_mesh_x(pt)
      point_update(pt, 2) = point_update(pt, 2) + d_mesh_y(pt)
    END DO
    PRINT*, 'aAb'
!        if (allocated(point_update)) deallocate(point_update)
    IF (ALLOCATED(points)) THEN
      DEALLOCATE(points)
    END IF
    IF (ALLOCATED(wing_coords)) THEN
      DEALLOCATE(wing_coords)
    END IF
    IF (ALLOCATED(wing_update_coords)) THEN
      DEALLOCATE(wing_update_coords)
    END IF
    IF (ALLOCATED(inoutput_coords)) THEN
      DEALLOCATE(inoutput_coords)
    END IF
    IF (ALLOCATED(control_points)) THEN
      DEALLOCATE(control_points)
    END IF
    IF (ALLOCATED(d_wing_x)) THEN
      DEALLOCATE(d_wing_x)
    END IF
    IF (ALLOCATED(d_wing_y)) THEN
      DEALLOCATE(d_wing_y)
    END IF
    IF (ALLOCATED(d_inoutput_x)) THEN
      DEALLOCATE(d_inoutput_x)
    END IF
    IF (ALLOCATED(d_inoutput_y)) THEN
      DEALLOCATE(d_inoutput_y)
    END IF
    IF (ALLOCATED(d_control_x)) THEN
      DEALLOCATE(d_control_x)
    END IF
    IF (ALLOCATED(d_control_y)) THEN
      DEALLOCATE(d_control_y)
    END IF
    IF (ALLOCATED(d_mesh_x)) THEN
      DEALLOCATE(d_mesh_x)
    END IF
    IF (ALLOCATED(d_mesh_y)) THEN
      DEALLOCATE(d_mesh_y)
    END IF
    IF (ALLOCATED(d_mesh_z)) THEN
      DEALLOCATE(d_mesh_z)
    END IF
    IF (ALLOCATED(r_row)) THEN
      DEALLOCATE(r_row)
    END IF
    IF (ALLOCATED(phi_row)) THEN
      DEALLOCATE(phi_row)
    END IF
    IF (ALLOCATED(phi)) THEN
      DEALLOCATE(phi)
    END IF
    IF (ALLOCATED(weights_x)) THEN
      DEALLOCATE(weights_x)
    END IF
    IF (ALLOCATED(weights_y)) THEN
      DEALLOCATE(weights_y)
    END IF
    IF (ALLOCATED(distances)) THEN
      DEALLOCATE(distances)
    END IF
    IF (ALLOCATED(originallines)) THEN
      DEALLOCATE(originallines)
    END IF
    IF (ALLOCATED(newdatalines)) THEN
      DEALLOCATE(newdatalines)
    END IF
    IF (ALLOCATED(newlines)) THEN
      DEALLOCATE(newlines)
    END IF
    IF (ALLOCATED(wing)) THEN
      DEALLOCATE(wing)
    END IF
! 释放本地wing
    IF (ALLOCATED(inoutput)) THEN
      DEALLOCATE(inoutput)
    END IF
    PRINT*, 'aAc'
  END SUBROUTINE MESHDEFORMATION

!  Differentiation of matmul_real in forward (tangent) mode (with options i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4):
!   variations   of useful results: c
!   with respect to varying inputs: b
! 矩阵×向量乘法子程序：C = A * B（A: m×k 二维矩阵, B: k 一维向量, C: m 一维向量）
  SUBROUTINE MATMUL_REAL_D(a, b, bd, c, cd)
    IMPLICIT NONE
! 输入：A为二维矩阵（m行k列），B为一维向量（长度k）
    REAL*8, INTENT(IN) :: a(:, :), b(:)
    REAL*8, INTENT(IN) :: bd(:)
! 输出：C为一维向量（长度m，与A的行数一致）
    REAL*8, INTENT(OUT) :: c(:)
    REAL*8, INTENT(OUT) :: cd(:)
! 局部变量：矩阵/向量维度、循环变量
    INTEGER :: m, k, i, l
    INTRINSIC SIZE
! 初始化结果向量为0
    c = 0.0d0
! 获取维度并检查合法性
! A的行数（结果C的长度必须等于m）
    m = SIZE(a, 1)
! A的列数（必须等于B的长度）
    k = SIZE(a, 2)
! 检查维度匹配：A的列数 = B的长度
    IF (k .NE. SIZE(b)) THEN
      WRITE(*, *) 'Error in matmul_real: A列数（', k, &
&     '）≠ B长度（', SIZE(b), '）'
      STOP
    ELSE IF (SIZE(c) .NE. m) THEN
! 检查结果C的长度 = A的行数
      WRITE(*, *) 'Error in matmul_real: C长度（', SIZE(c), &
&     '）≠ A行数（', m, '）'
      STOP
    ELSE
      cd = 0.0_8
! 矩阵×向量乘法核心逻辑（m×k 乘 k×1 = m×1）
! 遍历A的每一行（结果C的每个元素）
      DO i=1,m
! 遍历A的列/B的元素（累加求和）
        DO l=1,k
          cd(i) = cd(i) + a(i, l)*bd(l)
          c(i) = c(i) + a(i, l)*b(l)
        END DO
      END DO
    END IF
  END SUBROUTINE MATMUL_REAL_D

! 矩阵×向量乘法子程序：C = A * B（A: m×k 二维矩阵, B: k 一维向量, C: m 一维向量）
  SUBROUTINE MATMUL_REAL(a, b, c)
    IMPLICIT NONE
! 输入：A为二维矩阵（m行k列），B为一维向量（长度k）
    REAL*8, INTENT(IN) :: a(:, :), b(:)
! 输出：C为一维向量（长度m，与A的行数一致）
    REAL*8, INTENT(OUT) :: c(:)
! 局部变量：矩阵/向量维度、循环变量
    INTEGER :: m, k, i, l
    INTRINSIC SIZE
! 初始化结果向量为0
    c = 0.0d0
! 获取维度并检查合法性
! A的行数（结果C的长度必须等于m）
    m = SIZE(a, 1)
! A的列数（必须等于B的长度）
    k = SIZE(a, 2)
! 检查维度匹配：A的列数 = B的长度
    IF (k .NE. SIZE(b)) THEN
      WRITE(*, *) 'Error in matmul_real: A列数（', k, &
&     '）≠ B长度（', SIZE(b), '）'
      STOP
    ELSE IF (SIZE(c) .NE. m) THEN
! 检查结果C的长度 = A的行数
      WRITE(*, *) 'Error in matmul_real: C长度（', SIZE(c), &
&     '）≠ A行数（', m, '）'
      STOP
    ELSE
! 矩阵×向量乘法核心逻辑（m×k 乘 k×1 = m×1）
! 遍历A的每一行（结果C的每个元素）
      DO i=1,m
! 遍历A的列/B的元素（累加求和）
        DO l=1,k
          c(i) = c(i) + a(i, l)*b(l)
        END DO
      END DO
    END IF
  END SUBROUTINE MATMUL_REAL

!  Differentiation of dot_product_reall in forward (tangent) mode (with options i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4 i4 dr8 r4
!):
!   variations   of useful results: result
!   with respect to varying inputs: a
! 向量点积子程序：result = A · B（A和B需等长）
  SUBROUTINE DOT_PRODUCT_REALL_D(a, ad, b, result, resultd)
    IMPLICIT NONE
! 输入参数：两个待做点积的向量（real*8 类型）
    REAL*8, INTENT(IN) :: a(:), b(:)
    REAL*8, INTENT(IN) :: ad(:)
! 输出参数：点积结果（标量）
    REAL*8, INTENT(OUT) :: result
    REAL*8, INTENT(OUT) :: resultd
! 局部变量：向量长度、循环变量
    INTEGER :: len_a, len_b, i
    INTRINSIC SIZE
! 1. 获取向量长度并检查合法性（点积要求两向量等长）
    len_a = SIZE(a)
    len_b = SIZE(b)
    IF (len_a .NE. len_b) THEN
      WRITE(*, *) 'Error in dot_product_real: 向量长度不匹配！'
      WRITE(*, *) 'A长度 = ', len_a, '，B长度 = ', len_b
! 终止程序，避免错误计算
      STOP
    ELSE
! 2. 循环计算点积（元素相乘累加）
! 初始化结果
      result = 0.0d0
      resultd = 0.0_8
      DO i=1,len_a
        resultd = resultd + b(i)*ad(i)
        result = result + a(i)*b(i)
      END DO
    END IF
  END SUBROUTINE DOT_PRODUCT_REALL_D

! 向量点积子程序：result = A · B（A和B需等长）
  SUBROUTINE DOT_PRODUCT_REALL(a, b, result)
    IMPLICIT NONE
! 输入参数：两个待做点积的向量（real*8 类型）
    REAL*8, INTENT(IN) :: a(:), b(:)
! 输出参数：点积结果（标量）
    REAL*8, INTENT(OUT) :: result
! 局部变量：向量长度、循环变量
    INTEGER :: len_a, len_b, i
    INTRINSIC SIZE
! 1. 获取向量长度并检查合法性（点积要求两向量等长）
    len_a = SIZE(a)
    len_b = SIZE(b)
    IF (len_a .NE. len_b) THEN
      WRITE(*, *) 'Error in dot_product_real: 向量长度不匹配！'
      WRITE(*, *) 'A长度 = ', len_a, '，B长度 = ', len_b
! 终止程序，避免错误计算
      STOP
    ELSE
! 2. 循环计算点积（元素相乘累加）
! 初始化结果
      result = 0.0d0
      DO i=1,len_a
        result = result + a(i)*b(i)
      END DO
    END IF
  END SUBROUTINE DOT_PRODUCT_REALL

  SUBROUTINE GAUSSIAN_RBF_ARRAY(r_array, epsilon, phi_array)
    IMPLICIT NONE
    REAL(kind=8), INTENT(IN) :: r_array(:)
    REAL(kind=8), INTENT(IN) :: epsilon
    REAL(kind=8), INTENT(OUT) :: phi_array(SIZE(r_array))
    REAL(kind=8), PARAMETER :: d_nomal=1.0d0/4.5d0
    INTEGER :: i
    INTRINSIC SIZE
    DO i=1,SIZE(r_array)
      phi_array(i) = (1.0d0-d_nomal*r_array(i))**2
    END DO
  END SUBROUTINE GAUSSIAN_RBF_ARRAY

  SUBROUTINE INVERSE(n, mat, mat_inv)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: n
    REAL(kind=8), INTENT(IN) :: mat(n, n)
    REAL(kind=8), INTENT(INOUT) :: mat_inv(n, n)
    INTEGER, SAVE :: info=0, i, j
! 临时存储错误信息
    CHARACTER(len=256) :: err_msg
    EXTERNAL DPOTRF
    EXTERNAL DPOTRI
    mat_inv = mat
! Cholesky分解
    CALL DPOTRF('L', n, mat_inv, n, info)
    IF (info .NE. 0) WRITE(err_msg, '(a,i0,a)') &
&                    'inverse: Cholesky decomposition failed (info=', &
&                    info, ')'
! 矩阵求逆
    CALL DPOTRI('L', n, mat_inv, n, info)
    IF (info .NE. 0) WRITE(err_msg, '(a,i0,a)') &
&                    'inverse: Inversion failed (info=', info, ')'
! 填充上三角部分（对称矩阵）
    DO i=1,n
      DO j=i+1,n
        mat_inv(i, j) = mat_inv(j, i)
      END DO
    END DO
  END SUBROUTINE INVERSE

  FUNCTION READOFPOINTSFILEF(filepath) RESULT (points)
    IMPLICIT NONE
    CHARACTER(len=*), INTENT(IN) :: filepath
    REAL(kind=8), ALLOCATABLE :: points(:, :)
    CHARACTER(len=256), ALLOCATABLE :: lines(:)
    INTEGER :: startline, pcount, i, nlines, iostat, file_unit
    CHARACTER(len=256) :: line, bracketsremoved
    REAL(kind=8) :: coords(3)
    INTRINSIC TRIM
    INTRINSIC LEN_TRIM
    file_unit = GET_FREE_UNIT()
    OPEN(unit=file_unit, file=filepath, status='old', action='read', &
&  iostat=iostat) 
    IF (iostat .NE. 0) THEN
      PRINT*, 'Error: Can''t open points file: ', TRIM(filepath)
      ALLOCATE(points(0, 3))
      RETURN
    ELSE
      nlines = 0
      DO 
        READ(file_unit, '(a)', iostat=iostat) 
        IF (iostat .NE. 0) THEN
          REWIND(file_unit) 
          ALLOCATE(lines(nlines))
          DO i=1,nlines
            READ(file_unit, '(a)') lines(i)
          END DO
          CLOSE(file_unit) 
          CALL OFFILE_FINDNITEMSS(lines, startline, pcount)
          IF (pcount .LE. 0) THEN
            PRINT*, 'Error: Invalid point count in ', TRIM(filepath)
            DEALLOCATE(lines)
            ALLOCATE(points(0, 3))
            RETURN
          ELSE
            ALLOCATE(points(pcount, 3))
            DO i=1,pcount
              line = TRIM(lines(startline+i-1))
              bracketsremoved = line(2:LEN_TRIM(line)-1)
              READ(bracketsremoved, *) coords
              points(i, :) = coords
            END DO
            DEALLOCATE(lines)
          END IF
          GOTO 100
        ELSE
          nlines = nlines + 1
        END IF
      END DO
    END IF
 100 CONTINUE
  END FUNCTION READOFPOINTSFILEF

  SUBROUTINE OFFILE_FINDNITEMSS(filelines, startline, itemcount)
    IMPLICIT NONE
    CHARACTER(len=*), INTENT(IN) :: filelines(:)
    INTEGER, INTENT(OUT) :: startline, itemcount
    INTEGER :: i, pos, iostat
    CHARACTER(len=256) :: line
    INTRINSIC SIZE
    INTRINSIC TRIM
    INTRINSIC INDEX
    itemcount = 0
    startline = 0
    DO i=1,SIZE(filelines)
      line = TRIM(filelines(i))
      pos = INDEX(line, 'nPoints') + INDEX(line, 'nFaces') + INDEX(line&
&       , 'size')
      IF (pos .NE. 0) THEN
        READ(line(pos:), *, iostat=iostat) itemcount
        IF (itemcount .GT. 0) THEN
          startline = i + 2
          RETURN
        END IF
      END IF
    END DO
    DO i=1,SIZE(filelines)
      IF (ISNUMBER(TRIM(filelines(i)))) THEN
        READ(filelines(i), *, iostat=iostat) itemcount
        IF (itemcount .GT. 0) THEN
          startline = i + 2
          RETURN
        END IF
      END IF
    END DO
    DO i=1,SIZE(filelines)
      IF (INDEX(filelines(i), '(') .GT. 0) THEN
        startline = i + 1
        GOTO 100
      END IF
    END DO
 100 itemcount = 0
    DO i=startline,SIZE(filelines)
      IF (INDEX(filelines(i), ')') .GT. 0) THEN
        GOTO 110
      ELSE
        itemcount = itemcount + 1
      END IF
    END DO
 110 CONTINUE
  END SUBROUTINE OFFILE_FINDNITEMSS

! 辅助函数：获取空闲单元号
  INTEGER FUNCTION GET_FREE_UNIT()
    IMPLICIT NONE
    INTEGER :: i, iostat
    LOGICAL :: opened
    DO i=10,999
      INQUIRE(unit=i, opened=opened, iostat=iostat) 
      IF (.NOT.opened .AND. iostat .EQ. 0) THEN
        get_free_unit = i
        RETURN
      END IF
    END DO
  END FUNCTION GET_FREE_UNIT

  FUNCTION CSV_READ(filename) RESULT (data)
    IMPLICIT NONE
    CHARACTER(len=*), INTENT(IN) :: filename
    REAL*8, ALLOCATABLE :: data(:, :)
    INTEGER :: unit, i, j, nrows, ncols
!		open(newunit=unit, file=filename, status='old')
! 用自定义函数获取有效单元号
    unit = GET_FREE_UNIT()
    OPEN(unit=unit, file=filename, status='old') 
    READ(unit, *) nrows, ncols
    ALLOCATE(data(nrows, ncols))
    DO i=1,nrows
      READ(unit, *) (data(i, j), j=1,ncols)
    END DO
    CLOSE(unit) 
  END FUNCTION CSV_READ

! CSV写入函数（实际使用空格分隔文件）
  SUBROUTINE CSV_WRITE(filename, data, nrows, ncols)
    IMPLICIT NONE
    CHARACTER(len=*), INTENT(IN) :: filename
    INTEGER, INTENT(IN) :: nrows, ncols
    REAL*8, INTENT(IN) :: data(nrows, ncols)
    INTEGER :: unit, i, j
! 打开文件
!		open(newunit=unit, file=filename, status='replace')
    unit = GET_FREE_UNIT()
    OPEN(unit=unit, file=filename, status='replace') 
! 写入行数和列数
    WRITE(unit, '(i5, i5)') nrows, ncols
! 写入数据
    DO i=1,nrows
      WRITE(unit, '(99f10.6)') (data(i, j), j=1,ncols)
    END DO
    CLOSE(unit) 
  END SUBROUTINE CSV_WRITE

! 辅助函数：判断是否为数字
  LOGICAL FUNCTION ISNUMBER(str)
    IMPLICIT NONE
    CHARACTER(len=*), INTENT(IN) :: str
    REAL(kind=8) :: num
    INTEGER :: iostat
    isnumber = .false.
    READ(str, *, iostat=iostat) num
    IF (iostat .EQ. 0) isnumber = .true.
  END FUNCTION ISNUMBER

END MODULE MESHDEFORMATIONN_DIFF

